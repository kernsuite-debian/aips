        DEFINE GRDCC(CMS,CMP,GRD,NY,N)
"-----------------------------------------------------------------------
"! FPS VFC routine: Grid Clean components and DFT them.
"# AP-appl
"-----------------------------------------------------------------------
";  Copyright (C) 1995
";  Associated Universities, Inc. Washington DC, USA.
";
";  This program is free software; you can redistribute it and/or
";  modify it under the terms of the GNU General Public License as
";  published by the Free Software Foundation; either version 2 of
";  the License, or (at your option) any later version.
";
";  This program is distributed in the hope that it will be useful,
";  but WITHOUT ANY WARRANTY; without even the implied warranty of
";  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
";  GNU General Public License for more details.
";
";  You should have received a copy of the GNU General Public
";  License along with this program; if not, write to the Free
";  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
";  MA 02139, USA.
";
";  Correspondence concerning AIPS should be addressed as follows:
";         Internet email: aipsmail@nrao.edu.
";         Postal address: AIPS Project Office
";                         National Radio Astronomy Observatory
";                         520 Edgemont Road
";                         Charlottesville, VA 22903-2475 USA
"-----------------------------------------------------------------------
"-----------------------------------------------------------------------
"   FPS AP-120B array processor Vector function chainer routine.
"   GRDCC is a utility routine for MX subroutine MXSGRD.  GRDCC
"   does a direct Fourier transform on components in vector CMS to
"   vector CMP, FFTs in Y, then swaps zero to the center.
"   Then adds the previous GRID value.  Output is in vector
"   CMP.  Finally GRDCC prepares CMS and the phase ramp values for
"   the next call.
"
"    Inputs:  All P I*4
"     CMS    Base address of component vector, increment=5:
"              0 = Y (cells, integer)
"              1 = Flux * cos(ux)
"              2 = Flux * sin(ux)
"              3 = cos(x)
"              4 = sin(x)
"     CMP    Base address of complex output row. (increment = 2)
"     GRD    Base address of previous grid. (increment=2)
"     NY     Length of row (number of complex values)
"     N      Number of components in vector CMS
"-----------------------------------------------------------------------
         LOCAL NY2,CMS1,CMS3,CMPH
"-----------------------------------------------------------------------
"                                       Setup pointers etc.
         IF N<=0 GOTO S999
         NY2 = NY * 2
         SP09 = CMS
         CMS1 = SP09 + 1
         CMS3 = SP09 + 3
         SP09 = CMP
         CMPH = SP09 + NY
"                                       Clear CMP (output vector)
         CALL VCLR (CMP, 1, NY2)
"                                       DFT in X
         CALL DIRADD (CMS, 5, CMP, N)
"                                       FFT in Y
         CALL CFFT (CMP, NY, 1)
"                                       Swap zero to center.
         CALL VSWAP (CMP, 1, CMPH, 1, NY)
"                                       Add previous grid.
         CALL VADD (CMP, 1, GRD, 1, CMP, 1, NY2)
"                                       Rotate DFT for next call
         CALL CVMUL (CMS1, 5, CMS3, 5, CMS1, 5, N, 1)
S999:    END
