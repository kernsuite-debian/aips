#!/bin/sh
# UPDCONTROL
#-------------------------------------------------------------------
#! Copy UPDATE control files from the server
## Update UNIX
#-----------------------------------------------------------------------
#;  Copyright (C) 1995-2016
#;  Associated Universities, Inc. Washington DC, USA.
#;
#;  This program is free software; you can redistribute it and/or
#;  modify it under the terms of the GNU General Public License as
#;  published by the Free Software Foundation; either version 2 of
#;  the License, or (at your option) any later version.
#;
#;  This program is distributed in the hope that it will be useful,
#;  but WITHOUT ANY WARRANTY; without even the implied warranty of
#;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#;  GNU General Public License for more details.
#;
#;  You should have received a copy of the GNU General Public
#;  License along with this program; if not, write to the Free
#;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
#;  MA 02139, USA.
#;
#;  Correspondence concerning AIPS should be addressed as follows:
#;         Internet email: aipsmail@nrao.edu.
#;         Postal address: AIPS Project Office
#;                         National Radio Astronomy Observatory
#;                         520 Edgemont Road
#;                         Charlottesville, VA 22903-2475 USA
#-----------------------------------------------------------------------
#   Copy the UPDATE control files from the server, sort them and
#   remove duplicate entries and entries already processed. The
#   checksums of the transaction files are checked against values
#   obtained from the server to attempt to ensure that they have not
#   been corrupted during transfer.
#
#   In addition, a mail message is sent to people on MailList if
#   changes are detected to the preprocesor (PP.FOR), file, the
#   NEWEST.C program or other critical routines.
#
#   A check for $master/$VERS/UPDATE/$VERS.UPD is also done, to ensure
#   that the TST or NEW you ask for is what we consider TST or NEW,
#   respectively.  This prevents inadvertent cross-version copying.
#
#   Inputs:
#      ClientName            Name of client (for e-mail msg when needed)
#      ServerName            Name of server
#      MasterRoot            AIPS master root directory on server
#      MasterArch            AIPS master architecture needed for Clients
#      ServerUpd             Relative pathname of server UPDATE
#                             directory
#      VerName               AIPS version name
#      Vers                  OLD, NEW or TST
#      LogFile               Name of log file
#      ErrorFile             Name of error log
#      MailList              People to notify of changes
#      RunTime               Todays date.
#      UpdClient             YES or NO.  YES if we wait for master's
#                            midnight job to complete.
#      UpdMini               YES or NO.  YES for XAS/TV stuff only.
#                            See UPDCONFIG for description.
#
# Generic version.  Verbose if done interactively.
# Should work on BSD or SVR4 variants of Unix (also Posix).
#-------------------------------------------------------------------
Status=OK
Tries=0
Done=True
sumcmd="sum"
case $ARCH in
#                                       System V checksum is different
   HP | HP2 | SOL* | SUL | SGI) sumcmd="sum -r";;
esac
#                                       Should I wait for master to
#                                       finish?
if [ "$UpdClient" = YES ] ; then
#                                       Try to copy LASTGOOD.DAT from
#                                       the server. If the copy fails
#                                       or the contents of
#                                       LASTGOOD.DAT are the same as
#                                       LASTCOMLNK.DAT then wait 30
#                                       minutes and try again up to a
#                                       maximum of MaxTries times
   Done=False
   while [ \( "$Done" = "False" \) -a \
           \( "$Tries" != "$MaxTries" \) ] ; do
      rm -f *.UPD LASTGOOD.DAT.$ServerName
      [ -t 1 ] && echo "UPDCONTROL - trying to get LASTGOOD.DAT"
      if UPDCOPYSUB \
       $MasterRoot/$VerName/$MasterArch/UPDATE/LASTGOOD.DAT \
       `pwd`/LASTGOOD.DAT.$ServerName ; then
         if diff -s LASTGOOD.DAT.$ServerName LASTCOMLNK.DAT \
          > /dev/null ; then
            echo "UPDCONTROL - But `pwd`/LASTGOOD.DAT.$ServerName" \
                 >> $LogFile
            echo "UPDCONTROL - is the same as `pwd`/COMLNK.DAT." \
                 >> $LogFile
            echo "UPDCONTROL - Will wait 30 minutes and try again." \
                 >> $LogFile
            [ -t 1 ] && echo "UPDCONTROL - sleeping 30 minutes..."
            sleep 1800
         else
            Done=True
         fi
      fi
      Tries=`expr $Tries + 1`
   done
   if [ "$Done" != "True" ] ; then
      Status=FAILED
      echo "UPDCONTROL - Tried $Tries times to get LASTGOOD.DAT from" \
           "$ServerName" | \
            tee -a $ErrorFile >> $LogFile
      echo "UPDCONTROL - It's either identical to COMLNK.DAT here or" \
           "the copy attempts failed" | \
            tee -a $ErrorFile >> $LogFile
   fi
else

   # CVS should handle this, so if UpdCVS, skip it.
   if [ "$UpdCVS" != YES -a "$UpdRsync" != YES ] ; then
#                                       We're not a client, so we need
#                                       to check the cross-version file
#                                       on the master, to make sure what
#                                       it thinks is TST is what we
#                                       think it is too.
      [ -t 1 ] && echo "UPDCONTROL - Checking cross-version file"
#                                       Example of what we want is
#                                       master/TST/UPDATE/31DEC17.UPD
      fff=$MasterRoot/$Vers/UPDATE/${VerName}.UPD
      [ -f ${VerName}.UPD ] && /bin/rm -f ${VerName}.UPD
      Done=False; Tries=1
      while [ \( "$Done" = "False" \) -a \
              \( "$Tries" != "$MaxTries" \) ] ; do
         if UPDCOPYSUB $fff ${VerName}.UPD ; then
            echo "UPDCONTROL - verified that $Vers is indeed $VerName" \
             >> $LogFile
            [ -t 1 ] && echo "UPDCONTROL - $Vers is indeed $VerName"
            Done="True"
         fi
         Tries=`expr $Tries + 1`
      done
      if [ "$Done" = "True" ] ; then
#         [ -t 1 ] && echo "UPDCONTROL - Creating LASTGOOD.DAT.$ServerName"
         [ -t 1 ] && echo "UPDCONTROL - Syncing LASTGOOD.DAT.$ServerName"
#         echo $RunTime > LASTGOOD.DAT.$ServerName
         cp $AIPS_ROOT/$VerName/UPDATE/LASTCVS.DAT LASTGOOD.DAT.$ServerName
      else
         echo "UPDCONTROL - cannot verify $Vers=$VerName on master"
          >> $LogFile
         [ -t 1 ] && echo "UPDCONTROL - $Vers not $VerName on master?"
         Status=FAILED
      fi
   else
#      [ -t 1 ] && echo "UPDCONTROL - Creating LASTGOOD.DAT.$ServerName"
      [ -t 1 ] && echo "UPDCONTROL - Syncing LASTGOOD.DAT.$ServerName"
#         echo $RunTime > LASTGOOD.DAT.$ServerName
         cp $AIPS_ROOT/$VerName/UPDATE/LASTCVS.DAT LASTGOOD.DAT.$ServerName
   fi

fi
#                                       If LASTGOOD.DAT was copied
#                                       get the control files
if [ "$Status" = "OK" ] ; then

   # Again, if we are using cvs, then UPDCVS has taken care of this.
   if [ "$UpdCVS" != YES -a "$UpdRsync" != YES ] ; then

      [ -t 1 ] && echo "UPDCONTROL - Getting the 5 update files"
      for file in COMRPL.UPD COMLNK.UPD PUTBCK.UPD REASONS.UPD REMOVE.UPD
      do
         if [ "$Status" = "OK" ] ; then
#                                       Different place on master
            fff=$MasterRoot/$Vers/UPDATE/$file
            [ "$UpdClient" = YES ] && \
               fff=$MasterRoot/$VerName/$MasterArch/UPDATE/$file
#
            [ -t 1 ] && echo "UPDCONTROL - getting $fff -> $file"
            if UPDCOPYSUB $fff $file ; then
#                                       that worked, get checksum
               sumhere=`$sumcmd $file | awk '{print $1}'`
               if UPDCOPYSUB ${fff}.SUM ${file}.SUM ; then
                  sumthere=`cat ${file}.SUM | awk '{print $1}'`
                  if [ $sumhere -ne $sumthere ] ; then
#                                       Checksums do not match, bail out
                     Status=FAILED
                     [ -t 1 ] && echo "UPDCONTROL - $file checksum mismatch"
                     [ -t 1 ] && echo "UPDCONTROL - $sumhere, $sumthere"
                     echo "UPDCONTROL - $file checksum mismatch" \
                          | tee -a $ErrorFile >> $LogFile
                  else
#                                       Yep, copy most to old copy
#                                       Is this still necessary????
                     grep -v '(ADDITION)' $file > $file.OLD
                     [ -t 1 ] && echo \
                        "UPDCONTROL - copied to $file.OLD minus additions"
                  fi
               else
                  [ -t 1 ] && echo "UPDCONTROL - cannot copy checksum file"
                  Status=FAILED
               fi
            else
               [ -t 1 ] && echo "UPDCONTROL - failed"
               Status=FAILED
            fi
         fi
      done
   fi
fi
#                                       If all transaction files were
#                                       copied successfully then
#                                       remove PUTBCK entries made
#                                       obsolete by REMOVE.UPD
#
#                                       done by master long ago
if [ "$Status" = "OK" ] ; then
#  sort +3 REMOVE.UPD > REMOVE.TMP
#   sort -k 4 REMOVE.UPD > REMOVE.TMP
#  sort +3 PUTBCK.UPD > PUTBCK.TMP
   sort -k 4 PUTBCK.UPD > PUTBCK.TMP
   [ -t 1 ] && echo \
      "UPDCONTROL - sort PUTBCK"
#  UPDOBSLT PUTBCK.TMP REMOVE.TMP | sort +2 -3 +1 -2 > PUTBCK.UPD
#  UPDOBSLT PUTBCK.TMP REMOVE.TMP | sort -k 3 -k 2 > PUTBCK.UPD
   sort -k 3,3 -k 2,2 PUTBCK.TMP > PUTBCK.UPD
   [ -t 1 ] && echo \
      "UPDCONTROL - UPDOBSLT done, new PUTBCK.UPD"
fi
#                                       If all copied, remove AIPSWHO,
#                                       AIPSGRIP; they are local to CV.
#                                       Don't bother with removed files.
if [ "$Status" = "OK" ] ; then
   cat PUTBCK.UPD | \
    awk '$5 != "AIPSWHO" && $5 != "AIPSGRIP" {print $0}' >PUTBCK.TMP.2
   rm -f PUTBCK.UPD; mv PUTBCK.TMP.2 PUTBCK.UPD
#                                       Regenerate checksum in case we
#                                       are a master for another MNJ.
   rm -f PUTBCK.UPD.SUM
   $sumcmd PUTBCK.UPD | awk '{print $1}' >PUTBCK.UPD.SUM
fi
#                                       If that worked get the last
#                                       good dates
if [ "$Status" = "OK" ] ; then
   LASTREMOVE=`cat LASTREMOVE.DAT`; export LASTREMOVE
   if [ "$LASTREMOVE" = "" ] ; then
      echo "" | tee -a $ErrorFile >> $LogFile
      echo "UPDCONTROL - `pwd`/LASTREMOVE.DAT = $LASTREMOVE" \
              | tee  -a $ErrorFile >> $LogFile
      echo "" | tee -a $ErrorFile >> $LogFile
      [ -t 1 ] && echo \
         "UPDCONTROL - Err: `pwd`/LASTREMOVE.DAT = $LASTREMOVE"
      Status=FAILED
   fi
fi
if [ "$Status" = "OK" ] ; then
   LASTCOPY=`cat LASTCOPY.DAT`; export LASTCOPY
   if [ "$LASTCOPY" = "" ] ; then
      echo "" | tee -a $ErrorFile >> $LogFile
      echo "UPDCONTROL - `pwd`/LASTCOPY.DAT = $LASTCOPY" \
              | tee  -a $ErrorFile >> $LogFile
      echo "" | tee -a $ErrorFile >> $LogFile
      [ -t 1 ] && echo "UPDCONTROL - Err: `pwd`/LASTCOPY.DAT = $LASTCOPY"
      Status=FAILED
   fi
fi
if [ "$Status" = "OK" ] ; then
   LASTCOMRPL=`cat LASTCOMRPL.DAT`; export LASTCOMRPL
   if [ "$LASTCOMRPL" = "" ] ; then
      echo "" | tee -a $ErrorFile >> $LogFile
      echo "UPDCONTROL - `pwd`/LASTCOMRPL.DAT = $LASTCOMRPL" \
              | tee -a $ErrorFile >> $LogFile
      echo "" | tee -a $ErrorFile >> $LogFile
      [ -t 1 ] && echo \
        "UPDCONTROL - Err: `pwd`/LASTCOMRPL.DAT = $LASTCOMRPL"
      Status=FAILED
   fi
fi
if [ "$Status" = "OK" ] ; then
   LASTCOMLNK=`cat LASTCOMLNK.DAT`; export LASTCOMLNK
   if [ "$LASTCOMLNK" = "" ] ; then
      echo "" | tee -a $ErrorFile >> $LogFile
      echo "UPDCONTROL - `pwd`/LASTCOMLNK.DAT = $LASTCOMLNK" \
              | tee  -a $ErrorFile >> $LogFile
      echo "" | tee -a $ErrorFile >> $LogFile
      [ -t 1 ] && echo \
         "UPDCONTROL - Err: `pwd`/LASTCOMLNK.DAT = $LASTCOMLNK"
      Status=FAILED
   fi
fi
#                                       If everything is still OK
#                                       then record the last good
#                                       dates in the log file
if [ "$Status" = "OK" ] ; then
   echo ""                                               >> $LogFile
   echo "UPDCONTROL - `pwd`/LASTREMOVE.DAT = $LASTREMOVE" >> $LogFile
   echo "UPDCONTROL - `pwd`/LASTCOPY.DAT = $LASTCOPY"     >> $LogFile
   echo "UPDCONTROL - `pwd`/LASTCOMRPL.DAT = $LASTCOMRPL" >> $LogFile
   echo "UPDCONTROL - `pwd`/LASTCOMLNK.DAT = $LASTCOMLNK" >> $LogFile
   echo ""                                               >> $LogFile
#                                       Select all entries newer than
#                                       LASTREMOVE from REMOVE.UPD
#                                       then sort and eliminate
#                                       redundancies.
   [ -t 1 ] && echo "UPDCONTROL - calling UPDSRTUNQ REMOVE"
   UPDSRTUNQ REMOVE $LASTREMOVE
#                                       Initialize REASONS.UNQ with a
#                                       header for the update report.
   echo ""                                               >  REASONS.UNQ
   echo ""                                               >> REASONS.UNQ
   echo "UPDCONTROL - Reasons for file updates on `date -u` (UT)" >> REASONS.UNQ
   echo ""                                               >> REASONS.UNQ
#                                       Append REASONS.UPD entries
#                                       later than LASTCOPY.
   [ -t 1 ] && echo "UPDCONTROL - calling UPDLSTDAT REASONS.UPD"
   UPDLSTDAT REASONS.UPD $LASTCOPY >> REASONS.UNQ
#                                       For all other files, select
#                                       entries later than the last
#                                       update, sort and remove
#                                       redundant and obsolete entries
   [ -t 1 ] && echo "UPDCONTROL - calling UPDSRTUNQ PUTBCK"
   UPDSRTUNQ PUTBCK $LASTCOPY
#                                       Select relevant changes from
#                                       PUTBCK.UNQ and add them to
#                                       COMRPL.UPD amd COMLNK.UPD
#                                       as appropriate.
   [ -t 1 ] && echo "UPDCONTROL - applying COMRPL/LNK.ADD to .UPD files"
   sed -n -f $SYSLOCAL/COMRPL.ADD PUTBCK.UNQ >> COMRPL.UPD
   sed -n -f $SYSLOCAL/COMLNK.ADD PUTBCK.UNQ >> COMLNK.UPD
#                                       Ignore AIPSSRC COMRPLs and
#                                       COMLNKs from "quarterly" update.
#                                       (there really shouldn't be any!)
   [ -t 1 ] && echo "UPDCONTROL - removing any aipssrc compiles/links"
   grep -v aipssrc COMRPL.UPD > COMRPL.TMP; mv COMRPL.TMP COMRPL.UPD
   grep -v aipssrc COMLNK.UPD > COMLNK.TMP; mv COMLNK.TMP COMLNK.UPD
#                                       Sort and uniquify entries
   [ -t 1 ] && echo "UPDCONTROL - Calling UPDSRTUNQ COMRPL"
   UPDSRTUNQ COMRPL $LASTCOMRPL
   [ -t 1 ] && echo "UPDCONTROL - Calling UPDSRTUNQ COMLNK"
   UPDSRTUNQ COMLNK $LASTCOMLNK
   [ -t 1 ] && echo "UPDCONTROL - Done."
#                                       If mini-job, weed out the
#                                       entries we don't want.
   if [ "$UpdMini" = "YES" ] ; then
      [ -t 1 ] && echo "UPDCONTROL - Weeding out for mini-MNJ"
#                                       May want to move this into its
#                                       own file at some point...
#                                       List of modules to be serviced
#                                       by the mini-midnight job
      if [ "$UpdMiniPRG" = "" ] ; then
         MINIPRG="AIPNOT:MSGSRV AIPNOT:TEKSRV AIPNOT:TVSERV AIPNOT:TPMON"
      else
         MINIPRG="$UpdMiniPRG"
      fi
      MINIAREAS=""
      m=`cat COMLNK.UNQ | wc -l`
      rm -f COMLNK.TMP; touch COMLNK.TMP
      for i in $MINIPRG ; do
         miniarea=`echo $i | awk -F: '{print $1}'`
         miniprog=`echo $i | awk -F: '{print $2}'`
         if [ "$MINIAREAS" = "" ] ; then
            MINIAREAS=$miniarea
#                                       Did we already get this area?
         elif echo $MINIAREAS | grep $miniarea >/dev/null 2>/dev/null
         then
            : skip it
         else
#                                       Nope, so add it to our list.
            MINIAREAS="$MINIAREAS $miniarea"
         fi
#                                       Also, extract this program only
#                                       if it is in the transaction log.
         grep "$miniarea * $miniprog" COMLNK.UNQ >>COMLNK.TMP \
          2>/dev/null
         if [ $? = 0 ] ; then
            [ -t 1 ] && echo "UPDCONTROL - added $miniarea/$miniprog"
         fi
      done
      mv COMLNK.TMP COMLNK.UNQ
      n=`cat COMLNK.UNQ | wc -l`
      [ -t 1 ] && \
         echo "UPDCONTROL - trimmed tasks, $n of $m left in COMLNK.UPD"
      echo "UPDCONTROL - trimmed tasks, $n of $m left in COMLNK.UPD" \
       >>$LogFile
#                                       Subroutines are trickier.  Scan
#                                       each program and make a list of
#                                       areas that are needed by the
#                                       subset of AIPS tasks.
      MINILIB=""
      for i in $MINIAREAS ; do
         j='$'$i; j=`eval echo $j`
         k=`LIBS $j`
         k=`eval echo $k`
         MINILIB="$MINILIB $k"
      done
      MINILIB=`echo $MINILIB | \
               awk '{ for (i=1; i<=NF; i++) printf "%s\n",$i}' | \
               sort -u`
#                                       Now see if any entries in the
#                                       COMRPL transaction file have
#                                       modules that would go in any of
#                                       the libraries.
      m=`cat COMRPL.UNQ | wc -l`
      rm -f COMRPL.TMP; touch COMRPL.TMP
      cat COMRPL.UNQ | while read line ; do
         i=`echo $line | awk '{print "$"$5"/"$6}'`
         a=`echo $line | awk '{print $5}'`
#                                       extract the relevant library
#                                       based on the area.
         lib=`grep ':0:\$'$a'$' $SYSLOCAL/LIBR.DAT | \
              sed -e 's,/SUBLIB.*,,g' -e 's,\\$,,g'`
         if echo $MINILIB | grep $lib >/dev/null 2>/dev/null ; then
            echo $line >>COMRPL.TMP
         fi
      done
      mv COMRPL.TMP COMRPL.UNQ
      n=`cat COMRPL.UNQ | wc -l`
      [ -t 1 ] && \
         echo "UPDCONTROL - trimmed subs,  $n of $m left in COMRPL.UPD"
      echo "UPDCONTROL - trimmed subs,  $n of $m left in COMRPL.UPD" \
       >>$LogFile
   fi
#                                       Intercept changes to SYSLOCAL stuff
#
   spfile=${RunTime}.SPECIAL; touch $spfile
   [ -t 1 ] && echo "UPDCONTROL - created temporary file $spfile"
#                                       but not for binary
   if [ $UpdRsync = "NO" ] ; then
#                                       Also SYSUNIX stuff
      for i in PP.FOR F2PS.C F2TEXT.C NEWEST.C REVENV.C ZTRLOP.C
      do
         ufile="PUTBCK.UNQ"
         if grep \ $i $ufile >/dev/null
         then
            echo "The UPDATE job has detected changes to $i" >>$spfile
            echo "for $VerName on $ClientName at `date -u` (UT)." >>$spfile
            echo "Please rebuild it as soon as possible." >>$spfile
#                                       Really need to give instructions
            case $i in
               PP.FOR|ZTRLOP.C)
                  echo "For PP.FOR: cd $SYSLOCAL" >>$spfile
                  echo "gcc  -c -I$INC ZTRLOP.c" >>$spfile
                  echo "g77 -O -o PP.EXE PP.f ZTRLOP.o" >>$spfile
                  echo "IBM and HP machines need more done" >>$spfile
                  ;;
               F2PS.C|F2TEXT.C|NEWEST.C|REVENV.C)
                  echo "For F2PS, F2TEXT, NEWEST, REVENV" >>$spfile
                  echo "cd $SYSLOCAL" >>$spfile
                  echo "rm NAME.c (where NAME is one of the above)" >>$spfile
                  echo "ln -s $SYSUNIX/NAME.C NAME.c" >>$spfile
                  echo "gcc -O -o NAME NAME.c" >>$spfile
                  echo "(Use the correct C compiler above)" >>$spfile
                  ;;
            esac
            [ -t 1 ] && echo "UPDCONTROL - $i change detected"
         fi
      done
   fi
#                                       and TPMON
   if [ -s COMLNK.UNQ ] ; then
      if grep TPMON COMLNK.UNQ >/dev/null
      then
         echo "The UPDATE job has detected a COMLNK TPMON for" >>$spfile
         echo "version $VerName on $ClientName at `date -u` (UT)." >>$spfile
         echo "Please restart TPMON daemons on $ARCH systems." >>$spfile
         [ -t 1 ] && echo "UPDCONTROL - TPMON found in COMLNK.UPD"
      fi
   fi
#                                       LIBR.DAT may be a problem...
   if grep \ LIBR\.DAT PUTBCK.UNQ >/dev/null
   then
      echo "The UPDATE job has detected a LIBR.DAT change for" >>$spfile
      echo "version $VerName on $ClientName at `date -u` (UT)." >>$spfile
      echo "It MAY be that it applies to architecture $ARCH;" >>$spfile
      echo "(Sorry, this dumb script can't tell for sure)" >>$spfile
      echo "if so, you  should copy $TST/$ARCH/SYSTEM/LIBR.DAT" >>$spfile
      echo "to your $SYSLOCAL area." >>$spfile
      [ -t 1 ] && echo "UPDCONTROL - LIBR.DAT found in PUTBCK.UPD"
   fi
#                                       Now see if there's stuff to mail
   if [ -s $spfile ] ; then
      [ -t 1 ] && echo "UPDCONTROL - mailing special file to $MailList"
      echo "UPDCONTROL - special action needed by aips mgr, notice" \
           "emailed" >> $LogFile
      [ "$MailList" = "" ] && MailList="$LOGNAME"
      if [ "$MailList" != "" ] ; then
         subj="$VerName $ARCH needs extra work"
         case $ARCH in
            SUN4|LINUX*|LNX64|IBM|MAC*)
               mail -s "$subj" $MailList <$spfile;;
            *) echo "Subject: $subj" >$spfile.tmp
               cat $spfile >>$spfile.tmp
               mail $MailList <$spfile.tmp
               rm -f $spfile.tmp;;
         esac
      fi
      rm -f $spfile
   else
      [ -t 1 ] && echo "UPDCONTROL - nothing special, removing $spfile"
      rm -f $spfile
   fi
#                                       Regenerate checksum in case we
#                                       are a master for another MNJ.
   for i in COMRPL COMLNK ; do
      [ -t 1 ] && echo "UPDCONTROL - regenerating $i.UPD.SUM"
      rm -f $i.UPD.SUM
      $sumcmd $i.UPD | awk '{print $1}' >$i.UPD.SUM
   done
fi
#
if [ "$Status" = "OK" ] ; then
   echo "UPDCONTROL - Everything seems in order" >> $LogFile
   exit 0
else
   echo "UPDCONTROL - Status is $Status, exiting with abnormal error" \
        "code" | tee -a $ErrorFile >> $LogFile
   exit 1
fi
