$ TDEPEND
$---------------------------------------------------------------
$! Procedures for time-dependent imaging
$# RUN POPS IMAGING
$---------------------------------------------------------------
$;  Copyright (C) 2014
$;  Associated Universities, Inc. Washington DC, USA.
$;
$;  This program is free software; you can redistribute it/or
$;  and/or modify it under the terms of the GNU General Public
$;  License as published by the Free Software Foundation; either
$;  version 2 of the License, or (at your option) any later
$;  version.
$;
$;  This program is distributed in the hope that it will be
$;  useful, but WITHOUT ANY WARRANTY; without even the implied
$;  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
$;  PURPOSE.  See the GNU General Public License for more
$;  details.
$;
$;  You should have received a copy of the GNU General Public
$;  License along with this program; if not, write to the Free
$;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
$;  MA 02139, USA.
$;
$;  Correspondence concerning AIPS should be addressed as
$;  follows:
$;         Internet email: aipsmail@nrao.edu.
$;         Postal address: AIPS Project Office
$;                         National Radio Astronomy Observatory
$;                         520 Edgemont Road
$;                         Charlottesville, VA 22903-2475 USA
$---------------------------------------------------------------
PROCEDURE TDEF_VARS
$------------------------------------------------------------
*   Define variables for TDEPEND procedures.
$------------------------------------------------------------
   SCALAR    td_ntime, td_field, td_wait, td_tempf, td_sorc
   SCALAR    td_piece
   ARRAY     td_times(100)
   STRING*6  td_task, td_class
   STRING*8  td_step
   RETURN; FINISH
*
PROCEDURE TD_FINDN
$------------------------------------------------------------
*   Set TD_NTIME from TD_TIMES
$------------------------------------------------------------
    td_ntime = 99;
    for i = 100 to 2 by -1;
       if (td_times(i) <= 0) then; td_ntime = i - 2; end; end
    return; finish
*
PROCEDURE TD_MAKCL (td_tempf, td_class)
$------------------------------------------------------------
*   Set IN2CLASS from TD_FIELD
$------------------------------------------------------------
    td_class = 'ICL' !! char (td_tempf)
    if (td_tempf < 100) then;
       td_class = 'ICL0' !! char (td_tempf); end
    if (td_tempf < 10) then;
       td_class = 'ICL00' !! char (td_tempf); end
    return; finish
*
PROCEDURE TD_SETASK (td_task)
$------------------------------------------------------------
*   Sets default task; vget tdepend; task = ..
$------------------------------------------------------------
    task = td_task; default
    task = td_step; vget; task = td_task
    return; finish
*
PROCEDURE TD_GO
$------------------------------------------------------------
*   Does debug printing if requested and tels TASK to GO.
$------------------------------------------------------------
    if (prtlev>0.5) then; inputs; end
    if (prtlev>1.5) then; imhead; end
    go
    return; finish
*
PROCEDURE TD_ZAP
$------------------------------------------------------------
*   Checks that the name is okay and if so:
*   Does debug printing if requested and then ZAPs the file
$------------------------------------------------------------
    chkname
    if (error=0) then;
       if (prtlev>2.5) then; inputs zap; end
       if (prtlev>3.5) then; imhead; end
       zap;
    else
       if ((prtlev>0.5) ! (error>0)) then;
          inputs zap; print 'error =', error; end;
       end;  error = 0
    return; finish
*
PROCEDURE TD_SSCAN (td_sorc, td_piece)
$------------------------------------------------------------
*   Fills td_times from NX table
$------------------------------------------------------------
   inext = 'nx'; keyword='num row'; getthead; y = keyvalue(1)
   j=0; tt = invers; invers=1; td_times=0
   for i = 1:y;
      pixxy = i, 3, 1; tabget
      if (keyvalue(1) = td_sorc) then;
         pixxy = i, 1, 1; tabget; xx = keyvalue(1)
         pixxy = i, 2, 1; tabget; yy = keyvalue(1)
         td_piece = max (1,td_piece);
         xx = xx - yy/2.; yy = yy/td_piece
         if (j=0) then;
            J = 1; td_times(j)= xx
         else
            td_times(j) = (td_times(j) + xx)/2; end
         for x = 1:td_piece; j = j + 1; xx = xx + yy;
            td_times(j) = xx; end
            end; end; invers = tt
   if (prtlev>0.5) then; print y, 'scans';
      print j-1, 'intervals'; end
   if (prtlev>1.5) then; print 'td-times', td_times; end
   return; finish
*
PROCEDURE TD_SCANS (td_sorc)
$------------------------------------------------------------
*   Fills td_times from NX table
$------------------------------------------------------------
   inext = 'nx'; keyword='num row'; getthead; y = keyvalue(1)
   j=0; tt = invers; invers=1; td_times=0
   for i = 1:y;
      pixxy = i, 3, 1; tabget
      if (keyvalue(1) = td_sorc) then;
         pixxy = i, 1, 1; tabget; xx = keyvalue(1)
         pixxy = i, 2, 1; tabget; yy = keyvalue(1)
         td_piece = max (1,td_piece);
         xx = xx - yy/2.; yy = xx + yy;
         if (j=0) then;
            J = 1; td_times(j)= xx
         else
            td_times(j) = (td_times(j) + xx)/2
            end
         j = j + 1; td_times(j) = yy; end
         end; invers = tt
   if (prtlev>0.5) then; print y, 'scans';
      print j-1, 'intervals'; end
   if (prtlev>1.5) then; print 'td-times', td_times; end
   return; finish
*
PROCEDURE TD_STEP3
$------------------------------------------------------------
*   Makes first version of APPEND
$------------------------------------------------------------
    td_findn; if (td_ntime <= 0) then; return; end
    vnum = 36 - getpopsn; td_step = 'TD_STEP3'; task=td_step
    vput; td_wait = dowait; dowait = true;
*
    FOR I = 1:TD_NTIME;
*                                               split
       td_setask ('split'); outname=inname; outclass='ISPLIT'
       timerang=td_times(i),0,0,-0.01,td_times(i+1),0,0,0.01
       outseq=i; nchav=0; chinc=1; td_go
*                                               imagr
       td_setask ('imagr'); inclass='ISPLIT'; indisk=outdisk
       td_field=nfield+1; nfield = td_field; outname=inname
       inseq=i; outseq=i; td_go
*                                               uvsub
       td_setask ('uvsub'); inclass='ISPLIT'; inseq=i;
       indisk=outdisk; in2name=inname; in2seq=i;
       in2disk=outdisk; outname=inname;
       td_makcl (td_field, in2class); nmaps=1
       outclass='IUVSUB'; outseq=i; factor 0; flux=0; td_go
*                                               indxr
       td_setask('indxr'); inclass='IUVSUB'; inseq=i;
       indisk=outdisk; cparm = 0,30,-1; td_go
*                                               rename #1
       task = td_step; vget
       if (i = 1) then;
          inclass='IUVSUB'; inseq=i; indisk=outdisk
          outclass='APPEND'; outseq=1; rename
*                                               dbapp
       else;
          td_setask ('dbapp'); inclass='IUVSUB'; inseq=i
          indisk=outdisk; outclass='APPEND'; outseq=1;
          td_go; td_zap
          end
*                                               clean up
       inclass='ISPLIT'; inseq=i; indisk=outdisk;
       intype = 'UV'; td_zap; inclass='iuvsub'; td_zap
       intype='MA'; inclass = 'icl*'; detime=0; doconfrm=-2
       alldest; inclass='ibm*'; alldest
       end
    dowait = td_wait
    return; finish
*
PROCEDURE TD_STEP5
$------------------------------------------------------------
*   Makes later version of APPEND
$------------------------------------------------------------
    td_findn; if (td_ntime <= 0) then; return; end
    vnum = 36 - getpopsn; td_step = 'TD_STEP5'; task=td_step
    vput; td_wait = dowait; dowait = true;
*                                               kill APPEND
    inname=outname; inclass='append'; indisk=outdisk; inseq=1
    intype='UV'; td_zap
*                                               kill old TRGT
    intype='MA'
    for j = 1:ngauss; indisk=outdisk; td_makcl (j,inclass)
       inclass= 'TRGT' !! substr(inclass,5,6); inseq=i
       for i = 1:td_ntime; inseq=i; td_zap; end; end
    intype='UV'
*                                               loop
    FOR I = 1:TD_NTIME;
*                                               split
       td_setask ('split'); outname=inname; outclass='ISPLIT'
       timerang=td_times(i),0,0,-0.01,td_times(i+1),0,0,0.01
       outseq=i; nchav=0; chinc=1; td_go
*                                               uvsub non-target
       td_setask ('uvsub'); inclass='ISPLIT'; indisk outdisk
       outname=inname; outclass='ISOURC'; outseq=i; factor 0
       inseq=i; flux=0; td_go
*                                               imagr
       td_setask ('imagr'); inclass='ISOURC'; indisk=outdisk
       inseq=i; nfield=1; outname=inname; outseq=i;
       docal=-1; clr2name; td_go
*                                               uvsub
       td_setask ('uvsub'); inclass='ISPLIT'; indisk=outdisk
       in2name=inname; in2seq=i; in2disk=outdisk
       in2class = 'ICL001'; nmaps=ngauss;  outclass='IUVSUB'
       outname=inname; inseq=i; outseq=i; flux=0; td_go
*                                               indxr
       td_setask('indxr'); inclass='IUVSUB'; inseq=i;
       indisk=outdisk; cparm = 0,30,-1; td_go
*                                               rename target
       task = td_step; vget
       for j = 1:ngauss; indisk=outdisk; td_makcl (j,inclass)
          outclass= 'TRGT' !! substr(inclass,5,6); outseq=i
          inseq=i; rename; end
*                                               rename #1
       if (i = 1) then;
          inclass='IUVSUB'; inseq=i; indisk=outdisk
          outclass='APPEND'; outseq=1; rename
*                                               dbapp
       else;
          td_setask ('dbapp'); inclass='IUVSUB'; inseq=i
          indisk=outdisk; outclass='APPEND'; outseq=1; GO
          td_zap
          end
*                                               clean up
       inclass='ISPLIT'; inseq=i; indisk=outdisk; intype='UV'
       td_zap; inclass='IUVSUB'; td_zap;
       inclass='ISOURC'; td_zap
       ngauss = max(1,ngauss); intype='ma'
       for j = 1:ngauss; td_makcl (j, inclass);
          inclass = 'IBM' !! substr(inclass,4,6); td_zap;
          end; end
*
    dowait = td_wait
    return; finish
