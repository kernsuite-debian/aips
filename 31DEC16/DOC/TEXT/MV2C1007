@@
G. LISTINGS OF THE INSTALLATION COMMAND PROCEDURES
 
 
 
             ILOAD.COM
 
$!ILOAD.COM
$!----------------------------------------------------------------------
$!;  Copyright (C) 1995
$!;  Associated Universities, Inc. Washington DC, USA.
$!;
$!;  This program is free software; you can redistribute it and/or
$!;  modify it under the terms of the GNU General Public License as
$!;  published by the Free Software Foundation; either version 2 of
$!;  the License, or (at your option) any later version.
$!;
$!;  This program is distributed in the hope that it will be useful,
$!;  but WITHOUT ANY WARRANTY; without even the implied warranty of
$!;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
$!;  GNU General Public License for more details.
$!;
$!;  You should have received a copy of the GNU General Public
$!;  License along with this program; if not, write to the Free
$!;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
$!;  MA 02139, USA.
$!;
$!;  Correspondence concerning AIPS should be addressed as follows:
$!;         Internet email: aipsmail@nrao.edu.
$!;         Postal address: AIPS Project Office
$!;                         National Radio Astronomy Observatory
$!;                         520 Edgemont Road
$!;                         Charlottesville, VA 22903-2475 USA
$!----------------------------------------------------------------------
$!---------------------------------------------------------------------
$!  This is the first of the two main command procedure for installing
$!  AIPS.  This procedure will prompt the user for the AIPS system
$!  parameters, directory names, etc. needed to install AIPS.  Then the
$!  procedure creates the necessary subdirectories and loads the souce
$!  code from tape and into the correct subdirectories.  The user can
$!  then make any needed changes to the source code.  The user can
$!  compile the code and create the necessary AIPS data files by
$!  running the second main installation procedure BUILD.COM.
$!  This procedure should be run with the default directory
$!  set to the directory corresponding to [AIPS] and the default
$!  disk set to the AIPS default disk.  The tape drive should be
$!  mounted with the DCL command:
$!
$!  MOUNT /FOREIGN tape_drive_physical_name DUMMY TAPE:
$!
$!  then the initial command procedures should be copied with the DCL
$!  command:
$!
$!  BACKUP  TAPE:START.BCK []/NEW_VERSION
$!
$!  then type in @ILOAD and answer the questions, if you can.
$!---------------------------------------------------------------------
$!
$  ERROR :== " "
$!
$! Prompt for AIPS parameters.
$    @IPROMPTP
$! Prompt for AIPS logical names and write file ASSIGNL.COM
$    @IPROMPTL
$    IF (ERROR .EQS. "EXIT") THEN GOTO FINI
$!
$! Create the subdirectories we need.
$    @ICREATE
$!
$! Write file [AIPS.new.DOC.TEXT]SYSPARM to be used by program FILAI2.
$    @ISYSPARM
$!
$! Copy the rest of our stuff from tape.
$    WRITE SYS$OUTPUT " "
$    WRITE SYS$OUTPUT "Reading the rest of AIPS from tape."
$    READ_TAPE:
$    ON ERROR THEN GOTO TAPE_ERROR
$    BACKUP /NOREWIND TAPE:COM.BCK    'NEWDIR']/NEW_VER
$    BACKUP /NOREWIND TAPE:INC.BCK    'NEWDIR'.INC]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPSUB.BCK 'NEWDIR'.AIPS.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPPGM.BCK 'NEWDIR'.AIPS.PGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPZPV.BCK 'NEWDIR'.AIPS.ZPGM.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPVMS.BCK 'NEWDIR'.AIPS.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLSUB.BCK 'NEWDIR'.APL.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLPGM.BCK 'NEWDIR'.APL.PGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLAPG.BCK 'NEWDIR'.APL.APGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLVMS.BCK 'NEWDIR'.APL.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLIIS.BCK 'NEWDIR'.APL.YSUB.IIS]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLDEA.BCK 'NEWDIR'.APL.YSUB.DEA]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLM75.BCK 'NEWDIR'.APL.YSUB.M75]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTSUB.BCK 'NEWDIR'.NOTST.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTPGM.BCK 'NEWDIR'.NOTST.PGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTAPG.BCK 'NEWDIR'.NOTST.APGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTVMS.BCK 'NEWDIR'.NOTST.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:FPSSUB.BCK 'NEWDIR'.FPS.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:FPSVMS.BCK 'NEWDIR'.FPS.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:SAPSUB.BCK 'NEWDIR'.PSAP.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:SAPVMS.BCK 'NEWDIR'.PSAP.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:HELP.BCK   'NEWDIR'.HELP]/NEW_VER
$    BACKUP /NOREWIND TAPE:DOCTXT.BCK 'NEWDIR'.DOC.TEXT]/NEW_VER
$    BACKUP /NOREWIND TAPE:CHANGE.BCK 'NEWDIR'.HIST]/NEW_VER
$    DISMOUNT TAPE:
$    GOTO FINI
$!
$!     Error handler for tape.
$        TAPE_ERROR:
$        WRITE SYS$OUTPUT " "
$        WRITE SYS$OUTPUT "** tape error **"
$        INQUIRE OPTION "ENTER 1=MOUNT TAPE, 2=TRY AGAIN, 3=EXIT"
$        IF (OPTION .EQS. "2") THEN GOTO READ_TAPE
$        IF (OPTION .EQS. "3") THEN GOTO FINI
$        IF (OPTION .NES. "1") THEN GOTO TAPE_ERROR
$!       Mount tape for user.
$          ON ERROR THEN GOTO TAPE_ERROR
$          INQUIRE MT "ENTER TAPE PHYSICAL NAME (WITH :)"
$          MOUNT /FOREIGN 'MT' DUMMY TAPE:
$          GOTO READ_TAPE
$!
$ FINI:
$ WRITE SYS$OUTPUT "The next installation command procedure is IBUILD."
$ EXIT
@@
 
 
 
             IBUILD.COM
 
$!IBUILD.COM
$!---------------------------------------------------------------------
$!  This is the second of two main command procedures for installing
$!  AIPS. This procedure should be run after running ILOAD and after
$!  making any necessary changes to the source code.  This procedure
$!  will build all object module libraries, compile the subroutines,
$!  put them into the libraries, and compile and link all programs.
$!  Finally all the data files needed for AIPS are created.
$!  This procedure should be run with the default directory set to the
$!  directory corresponding to [AIPS] and the default disk set to
$!  the AIPS areas' default disk.  To run this procedure type @IBUILD.
$!  This procedure executes command file ASSIGNL.COM to activate
$!  necessary logical assignments.  Program FILAI2 reads file SYSPARM.
$!  Both of these files are created by the first main command procedure
$!  LOAD.COM.
$!---------------------------------------------------------------------
$!
$!  Find out about AP.
$   ASK:
$     INQUIRE INP "ENTER: 0=USE PSEUDO AP CODE, 1=AP AVAILABLE"
$     GOTAP == INP
$     IF (INP .EQS. "0") THEN GOTO REST
$     IF (INP .NES. "1") THEN GOTO ASK
$!
$!      Ask about FPS directories and device.
$         ASK_FPS:
$         ON WARNING THEN GOTO OPT_ASK
$         WRITE SYS$OUTPUT -
            "ENTER DEVICE AND DIRECTORY OF FPS LIBRARIES AS dev:[dir]"
$         INQUIRE DEV "ENTER "
$         FPSAREA :== 'DEV'
$         WRITE SYS$OUTPUT " "
$         WRITE SYS$OUTPUT "THE LIBRARIES IN YOUR FPS AREA ARE:"
$         DIR /COL=1 'DEV'*.OLB
$         WRITE SYS$OUTPUT " "
$         WRITE SYS$OUTPUT -
            "THE ONES USED BY ILINKAP.COM AND ILINKAN.COM ARE:"
$         WRITE SYS$OUTPUT "HSRLIB.OLB"
$         WRITE SYS$OUTPUT "FPSLIB.OLB"
$         WRITE SYS$OUTPUT " "
$         WRITE SYS$OUTPUT -
            "IF A DIFFERENCE EXISTS YOU MUST EDIT THE LINK STATEMENTS"
$         WRITE SYS$OUTPUT "IN ILINKAP.COM AND ILINKAN.COM"
$         OPT_ASK:
$         WRITE SYS$OUTPUT " "
$         INQUIRE OPTION "1=RE-ENTER FPS DEVICE, 2=CONTINUE, 3=EXIT"
$         IF (OPTION .EQS. "1") THEN GOTO ASK_FPS
$         IF (OPTION .EQS. "3") THEN GOTO FINI
$         IF (OPTION .NES. "2") THEN GOTO OPT_ASK
$!
$   REST:
$   SET NOON
$   SET ON
$!  Make sure logical names are set.
$     @ASSIGNL
$!  Find directory name for NEW area.
$     NEW := 'F$LOGICAL("NEW")'
$     END = 'F$LOCATE("]",NEW)'
$     NEWDIR :== 'F$EXTRACT(0,END,NEW)'
$!  Make logical assignment for INCLUDE source code.
$     ASS 'NEWDIR'.INC]  INCS
$
$   SET NOON
$!  Collect a copy of all error messages in file ERROR.DAT
$     OPEN /WRITE ERR_FILE ERROR.DAT
$     ASS ERR_FILE SYS$ERROR
$!
$!  Create libraries, compile and insert subroutines in all areas.
$     @ICOMPAL
$     @ICOMPAI
$     @ICOMPAP
$     @ICOMPNS
$     @ICOMPPS
$!    still experimental     @ICOMPIC
$     WRITE ERR_FILE " "
$     WRITE ERR_FILE "** FINISHED SUBROUTINE COMPILATIONS **"
$     WRITE ERR_FILE " "
$!
$!  Link AIPS and utility programs , all standard tasks, all not
$!  standard tasks, all programs that utilize the AP or pseudo AP
$!  and not standard AP programs.
$     @ILINKA
$     @ILINKT
$     @ILINKNS
$     @ILINKAP
$     @ILINKAN
$!
$!    Vax start routine
$       FOR 'NEWDIR'.AIPS.ZPGM.VMS]ZSTRTA
$       LINK /EXE='NEWDIR'.LOAD]ZSTRTA.EXE ZSTRTA, 'NEWDIR'.APL]SUBLIB/LIB
$       DEL ZSTRTA.OBJ;*
$!    Batch fixup routine
$       FOR 'NEWDIR'.AIPS.ZPGM.VMS]ZSTRTS
$       LINK /EXE='NEWDIR'.LOAD]ZSTRTS.EXE ZSTRTS, 'NEWDIR'.APL]SUBLIB/LIB
$       DEL ZSTRTS.OBJ;*
$!    VAX stop routine.
$       FOR 'NEWDIR'.AIPS.ZPGM.VMS]ZSTOPA
$       LINK /EXE='NEWDIR'.LOAD]ZSTOPA.EXE  ZSTOPA
$       DEL ZSTOPA.OBJ.*
$     WRITE ERR_FILE " "
$     WRITE ERR_FILE "** FINISHED LINKING TASKS **"
$!
$   CLOSE ERR_FILE
$   DEASS SYS$ERROR
$!
$!  Run file builder/init program that reads inputs from file SYSPARM.
$     WRITE SYS$OUTPUT "BUILDING/INITIALIZING DATA FILES"
$     RUN 'NEWDIR'.LOAD]FILAI2
$!
$!  Run POPSGN to initialize memory (ME) files.
$     WRITE SYS$OUTPUT "INITIALIZING MAIN MEMORY FILES."
$!    This assignment might not exist.
$       WRITE SYS$OUTPUT "ignore NOLOGNAM message if it occurs."
$       DEASS FOR005
$     WRITE SYS$OUTPUT "ignore '>' when it appears."
$     RUN 'NEWDIR'.LOAD]POPSGN
011500POPSDAT
<CR>
$! This assignment will be set in LOGIN from now on.
$    ASS TT:  FOR005
$!
$ FINI:
$ EXIT
@@
 
 
 
             ISHORTINS.COM
 
$!ISHORTINS.COM
$!---------------------------------------------------------------------
$!  This is a short cut command procedure for installing AIPS.  No
$!  links or compiles are done.  The executable modules are copied from
$!  tape.  Also an option is available to not copy the source code from
$!  tape.  This procedure only works for VMS 3.0 with an
$!  array processor.  This procedure should be run with the default
$!  directory set to the directory corresponding to [AIPS] and the
$!  default disk set to the AIPS areas default disk.  Before running
$!  this procedure the tape drive should be mounted with the DCL
$!  command:
$!
$!  MOUNT /FOREIGN tape_drive_physical_name DUMMY TAPE:
$!
$!  then the initial command procedures should be copied with the DCL
$!  command:
$!
$!  BACKUP  TAPE:START.BCK []/NEW_VERSION
$!
$!  then type in @ISHORTINS and answer the questions, if you can.
$!---------------------------------------------------------------------
$!
$  ERROR :== " "
$!
$! Prompt for AIPS parameters.
$    @IPROMPTP
$! Prompt for AIPS logical names and write file ASSIGNL.COM
$    @IPROMPTL
$    IF (ERROR .EQS. "EXIT") THEN GOTO FINI
$!
$  REST:
$! Create the subdirectories we need.
$    @ICREATE
$!
$! Write file [AIPS.new.DOC.TEXT]SYSPARM to be used by program FILAI2.
$    @ISYSPARM
$!
$! Copy the rest of our stuff from tape.
$    WRITE SYS$OUTPUT " "
$    SOURCEQ:
$      INQUIRE ANSWER99 -
         "DO YOU WANT THE SOURCE CODE COPIED. 0=NO, 1=YES"
$      IF (ANSWER99.EQS."0") THEN GOTO SKIP_SOURCE
$      IF (ANSWER99.NES."1") THEN GOTO SOURCEQ
$!
$    WRITE SYS$OUTPUT " "
$    WRITE SYS$OUTPUT "Reading the rest of AIPS from tape."
$    READ_TAPE:
$    ON ERROR THEN GOTO TAPE_ERROR
$    BACKUP /NOREWIND TAPE:COM.BCK    'NEWDIR']/NEW_VER
$    BACKUP /NOREWIND TAPE:INC.BCK    'NEWDIR'.INC]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPSUB.BCK 'NEWDIR'.AIPS.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPPGM.BCK 'NEWDIR'.AIPS.PGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPZPV.BCK 'NEWDIR'.AIPS.ZPGM.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPVMS.BCK 'NEWDIR'.AIPS.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:AIPIIS.BCK 'NEWDIR'.AIPS.YSUB.IIS]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLSUB.BCK 'NEWDIR'.APL.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLPGM.BCK 'NEWDIR'.APL.PGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLAPG.BCK 'NEWDIR'.APL.APGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLVMS.BCK 'NEWDIR'.APL.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:APLIIS.BCK 'NEWDIR'.APL.YSUB.IIS]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTSUB.BCK 'NEWDIR'.NOTST.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTPGM.BCK 'NEWDIR'.NOTST.PGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTAPG.BCK 'NEWDIR'.NOTST.APGM]/NEW_VER
$    BACKUP /NOREWIND TAPE:NOTVMS.BCK 'NEWDIR'.NOTST.ZSUB.VMS]/NEW_VER
$    BACKUP /NOREWIND TAPE:FPSSUB.BCK 'NEWDIR'.FPS.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:SAPSUB.BCK 'NEWDIR'.PSAP.SUB]/NEW_VER
$    BACKUP /NOREWIND TAPE:SAPVMS.BCK 'NEWDIR'.PSAP.ZSUB.VMS]/NEW_VER
$    SKIP_SOURCE:
$    BACKUP /NOREWIND TAPE:HELP.BCK   'NEWDIR'.HELP]/NEW_VER
$    BACKUP /NOREWIND TAPE:DOCTXT.BCK 'NEWDIR'.DOC.TEXT]/NEW_VER
$    BACKUP /NOREWIND TAPE:CHANGE.BCK 'NEWDIR'.HIST]/NEW_VER
$!                                   Determine volume name. A "C" on
$!                                   the end indicates a 6250 tape was
$!                                   sent.
$    VOL = F$GETDVI(TAPE,"VOLNAM")
$    ABC = F$EXTRACT(5,1,VOL)
$    IF (ABC .EQS. "C") THEN GOTO REST
$       DISMOUNT TAPE:
$       NXTTAP:
$       ON ERROR THEN GOTO NXTTAP:
$       INQUIRE TAPU -
          "Mount tape AIPS2 on the same drive. Enter Y when ready"
$       IF (TAPU .NES. "Y") THEN GOTO NXTTAP
$       MOUNT /FOR 'TAPE' DUMMY TAPE:
$       SET NOON
$ REST:
$    BACKUP /NOREWIND TAPE:EXE.BCK    'NEWDIR'.LOAD]/NEW_VER
$    BACKUP /NOREWIND TAPE:SAPEXE.BCK 'NEWDIR'.PSAP.LOAD]/NEW_VER
$    BACKUP /NOREWIND TAPE:LAIPS.BCK  'NEWDIR'.AIPS]/NEW_VER
$    BACKUP /NOREWIND TAPE:LAPL.BCK   'NEWDIR'.APL]/NEW_VER
$    BACKUP /NOREWIND TAPE:LNOTST.BCK 'NEWDIR'.NOTST]/NEW_VER
$    BACKUP /NOREWIND TAPE:LFPS.BCK   'NEWDIR'.FPS]/NEW_VER
$    BACKUP /NOREWIND TAPE:LPSAP.BCK  'NEWDIR'.PSAP]/NEW_VER
$    DISMOUNT TAPE:
$    GOTO SKIP
$!
$!     Error handler for tape.
$        TAPE_ERROR:
$        WRITE SYS$OUTPUT " "
$        WRITE SYS$OUTPUT "** tape error **"
$        INQUIRE OPTION "ENTER 1=MOUNT TAPE, 2=TRY AGAIN, 3=EXIT"
$        IF (OPTION .EQS. "2") THEN GOTO READ_TAPE
$        IF (OPTION .EQS. "3") THEN GOTO FINI
$        IF (OPTION .NES. "1") THEN GOTO TAPE_ERROR
$!       Mount tape for user.
$          ON ERROR THEN GOTO TAPE_ERROR
$          INQUIRE MT "ENTER TAPE PHYSICAL NAME (WITH :)"
$          MOUNT /FOREIGN 'MT' DUMMY TAPE:
$          GOTO READ_TAPE
$!
$ SKIP:
$!  Make sure logical names are set.
$     @ASSIGNL
$!
$!  Run file builder/init program that reads inputs from file SYSPARM.
$     WRITE SYS$OUTPUT "BUILDING/INITIALIZING DATA FILES"
$     RUN 'NEWDIR'.LOAD]FILAI2
$!
$!  Run POPSGN to initialize memory (ME) files.
$     WRITE SYS$OUTPUT "INITIALIZING MAIN MEMORY FILES."
$!    This assignment might not exist.
$       WRITE SYS$OUTPUT "ignore deassign message if it occurs."
$       SET NOON
$       DEASS FOR005
$     WRITE SYS$OUTPUT "ignore '>' when it appears."
$     RUN 'NEWDIR'.LOAD]POPSGN
011500POPSDAT
<CR>
$! This assignment will be set in LOGIN from now on.
$    ASS TT:  FOR005
$ FINI:
$ EXIT
@@
 
 
 
             IPROMPTP.COM
 
$!IPROMPTP.COM
$!---------------------------------------------------------------------
$!  This routine prompts for all AIPS parameters.
$!  OUTPUTS:
$!    ANSWER'I'  INT   The system parameters.
$!    QUEST'I'   STR   A description of the system parameters.
$!    NO_QUEST   INT   The number of system parameters (start with 1).
$!    TVANS'I'   INT   Number of graphics planes and image planes for
$!                     each TV device.
$!    TVQUEST'I' STR   A description of the TVANS'I'.
$!    COMPUTER   STR   A name for the local computer system.
$!---------------------------------------------------------------------
$!
$! Initialization and defaults.
$    QUEST1 :== " NO. OF DISK DRIVES                 "
$    ANSWER1 == 1
$    UPPER_LIM1 = 9
$    LOWER_LIM1 = 1
$    QUEST2 :== " NO OF TAPE DRIVES                  "
$    ANSWER2 == 1
$    UPPER_LIM2 = 9
$    LOWER_LIM2 = 1
$    QUEST3 :== " NO OF LINES PER CRT PAGE           "
$    ANSWER3 == 24
$    UPPER_LIM3 = 100
$    LOWER_LIM3 = 4
$    QUEST4 :== " NO OF LINES PER PRINT PAGE         "
$    ANSWER4 == 61
$    UPPER_LIM4 = 500
$    LOWER_LIM4 = 4
$    QUEST5 :== " NO OF BATCH QUEUES                 "
$    ANSWER5 == 2
$    UPPER_LIM5 = 2
$    LOWER_LIM5 = 0
$    QUEST6 :== " PLOTTER NO OF X DOTS PER PAGE      "
$    ANSWER6 == 2112
$    UPPER_LIM6 = 10000
$    LOWER_LIM6 = 10
$    QUEST7 :== " PLOTTER NO OF Y DOTS PER PAGE      "
$    ANSWER7 == 1600
$    UPPER_LIM7 = 10000
$    LOWER_LIM7 = 10
$    QUEST8 :== " PLOTTER NO OF X DOTS PER CHARACTER "
$    ANSWER8 == 20
$    UPPER_LIM8 = 10000
$    LOWER_LIM8 = 2
$    QUEST9 :== " PLOTTER NO OF Y DOTS PER CHARACTER "
$    ANSWER9 == 25
$    UPPER_LIM9 = 10000
$    LOWER_LIM9 = 2
$    QUEST10 :== "NO OF INTERACTIVE AIPS             "
$    ANSWER10 == 3
$    UPPER_LIM10 = 6
$    LOWER_LIM10 = 1
$    QUEST11 :== "NO OF WORDS IN AP (IN 1024 S)      "
$    ANSWER11 == 64
$    UPPER_LIM11 = 256
$    LOWER_LIM11 = 1
$    QUEST12 :== "NO OF TV DEVICES AVAILABLE         "
$    ANSWER12 == 1
$    UPPER_LIM12 = 9
$    LOWER_LIM12 = 0
$    QUEST13 :== "NO OF GRAPHICS TERMINALS           "
$    ANSWER13 == 1
$    UPPER_LIM13 = 9
$    LOWER_LIM13 = 0
$    QUEST14 :== "NO OF X DOTS PER MM ON PRINTER     "
$    ANSWER14 :== "7.83"
$    QUEST15 :== "NO OF X DOTS PER MM ON GRAPHICS    "
$    ANSWER15 :== "5.00"
$    QUEST16 :== "NO OF USERS ALLOWED ACCESS TO TVS  "
$    ANSWER16 == 1
$    UPPER_LIM16 = 6
$    LOWER_LIM16 = 0
$    QUEST17 :== "NO OF USERS ALLOWED ACCESS TO TKS  "
$    ANSWER17 == 1
$    UPPER_LIM17 = 6
$    LOWER_LIM17 = 0
$    QUEST18 :== "NO ENTRIES IN PRIVATE CATALOGS     "
$    ANSWER18 == 300
$    UPPER_LIM18 =  1000
$    LOWER_LIM18 = -1000
$    QUEST19 :== "NO OF RESERVED AIPS TERMINALS      "
$    ANSWER19 == 0
$    UPPER_LIM19 = 9
$    LOWER_LIM19 = 0
$    QUEST20 :== "NO OF MESSAGE TERMINALS            "
$    ANSWER20 == 1
$    UPPER_LIM20 = 9
$    LOWER_LIM20 = 0
$    QUEST21 :== "NO OF REMOTE GRAPHICS TERMINALS    "
$    ANSWER21 == 0
$    UPPER_LIM21 = 9
$    LOWER_LIM21 = 0
$    QUEST22 :== "MAXIMUM ALLOWED USER NUMBER        "
$    ANSWER22 == 800
$    UPPER_LIM22 = 4095
$    LOWER_LIM22 = 10
$    NO_QUEST == 22
$!
$  PRINT:
$    I = 0
$    WRITE SYS$OUTPUT -
       "NO.  PARAMETER                             VALUE"
$    LOOP:
$      I = I + 1
$      WRITE SYS$OUTPUT I,"   ", QUEST'I', "   ", ANSWER'I'
$      IF I .LT. NO_QUEST  THEN GOTO LOOP
$
$  SELECT:
$    ON WARNING THEN GOTO SELECT
$    INQUIRE OPTION ">>> ENTER NUMBER FOR CHANGE, 0=PRINT, -1=FINISHED "
$    IF OPTION .EQ. -1 THEN GOTO TVSTUF
$    IF OPTION .EQ. 0  THEN GOTO PRINT
$    IF (OPTION .LT. 1) .OR. (OPTION .GT. NO_QUEST) THEN GOTO SELECT
$!
$!   Ask for option.
$      ASK:
$        ON WARNING THEN GOTO ASK
$        WRITE SYS$OUTPUT QUEST'OPTION'
$        INQUIRE TEMPO "ENTER"
$        IF (OPTION.EQ.14) .OR. (OPTION.EQ.15) THEN GOTO SPECIAL
$        IF (TEMPO.GE.LOWER_LIM'OPTION') .AND. -
           (TEMPO.LE.UPPER_LIM'OPTION') THEN GOTO OK
$!
$          WRITE SYS$OUTPUT " *RANGE ERROR* ", -
             "ACCEPTIBLE RANGE: ",LOWER_LIM'OPTION', -
             " TO ",UPPER_LIM'OPTION'
           GOTO ASK
$!
$        OK:
$        ANSWER'OPTION' :== 'TEMPO'
$        GOTO SELECT
$!
$        SPECIAL:
$!       Floating point treated as characters.
$           ANSWER'OPTION' :== 'TEMPO'
$           GOTO SELECT
$!
$ TVSTUF:
$ WRITE SYS$OUTPUT " "
$ NOTVQUEST = ANSWER12 * 2
$ IF (ANSWER12.LT.1) THEN GOTO FINI
$                                  ! Set default values for TV parms.
$ K = 1
$ I = 1
$ TVDEF:
$   IF (I.GT.ANSWER12) THEN GOTO ENDDEF
$   TVQUEST'K' :== "NUMBER OF IMAGE PLANES IN TV DEVICE ''I'   "
$   TVANS'K' == 4
$   K = K + 1
$   TVQUEST'K' :== "NUMBER OF GRAPHICS PLANES IN TV DEVICE ''I'"
$   TVANS'K' == 4
$   K = K + 1
$   I = I + 1
$ GOTO TVDEF
$ ENDDEF:
$                                  ! Loop for number of TV devices.
$ TVPRINT:
$    WRITE SYS$OUTPUT " "
$    WRITE SYS$OUTPUT "TV PARAMETERS"
$    WRITE SYS$OUTPUT -
       "NO.  PARAMETER                             VALUE"
$   K = 1
$   TVLOOP:
$     IF (K .GT. NOTVQUEST) THEN GOTO ENDTV
$     WRITE SYS$OUTPUT K, "   ",TVQUEST'K', "     ",TVANS'K'
$     K = K + 1
$   GOTO TVLOOP
$   ENDTV:
$   TVSELECT:
$     ON WARNING THEN GOTO TVSELECT
$     INQUIRE OPTION -
 ">>> ENTER NUMBER TO CHANGE, 0=PRINT, -1=FINISHED, -2=1ST PARM SET "
$     IF OPTION .EQ. -1 THEN GOTO FINI
$     IF OPTION .EQ. -2 THEN GOTO PRINT
$     IF OPTION .EQ. 0  THEN GOTO TVPRINT
$     IF (OPTION .LT. 1) .OR. (OPTION .GT. NOTVQUEST) THEN GOTO TVSELECT
$!
$!   Ask for option.
$     TVASK:
$       ON WARNING THEN GOTO TVASK
$       WRITE SYS$OUTPUT TVQUEST'OPTION'
$       INQUIRE TEMPO "ENTER"
$       IF (TEMPO.GE.1) .AND. -
          (TEMPO.LE.10) THEN GOTO TVOK
$!
$         WRITE SYS$OUTPUT " *RANGE ERROR* ", -
            "ACCEPTIBLE RANGE: 1 TO 10"
          GOTO TVASK
$!
$       TVOK:
$       TVANS'OPTION' :== 'TEMPO'
$       GOTO TVSELECT
$ FINI:
$! Ask for the computer descriptor.
$    WRITE SYS$OUTPUT " "
$    ID:
$      WRITE SYS$OUTPUT -
         "ENTER A 20 CHARACTER STRING IDENTIFYING YOUR LOCAL SYSTEM"
$      INQUIRE TEMP "ENTER"
$      IF (TEMP .EQS. "") THEN GOTO ID
$    COMPUTER :== 'TEMP'
$!
$ EXIT
@@
 
 
 
             IPROMPTL.COM
 
$!IPROMPTL.COM
$!---------------------------------------------------------------------
$!  This command procedure will prompt for information necessary to
$!  make all the logical assignments used in AIPS.  A command procedure
$!  ASSIGNL.COM containing commands to make these logical assignments
$!  will be created.
$!  The assignments made in ASSIGNL.COM need to be in effect before AIPS
$!  is executed.  The options are:
$!     1. Call ASSIGNL.COM in LOGIN.COM
$!     2. Make the group logical assignments in the SYSTARTUP command
$!        procedure (this is the ideal solution, since it produces
$!        no messy system messages when loging in).
$!  INPUTS:
$!    ANSWER1  INT  Number of disk drives (data areas).
$!    ANSWER2  INT  Number of tape drives.
$!    ANSWER5  INT  Number of batch queues.
$!    ANSWER12 INT  Number of TV devices available.
$!    ANSWER13 INT  Number of graphics/user terminal matches.
$!    ANSWER19 INT  Number of reserved AIPS terminals.
$!    ANSWER20 INT  Number of message terminals.
$!    ANSWER21 INT  Number of remote graphics terminals.
$!  OUTPUTS:
$!    DATA'I'  STR  The data subdirectories on the available disks.
$!    TOPDIR   STR  The directory corresponding to [AIPS
$!    NEWDIR   STR  The directory corresponding to [AIPS.new
$!    ASSIGNL.COM   A text file containing the group logical
$!                  assignments needed for AIPS.
$!---------------------------------------------------------------------
$!
$! Current directory must correspond to [AIPS]
$
$    TDIR := 'F$LOGICAL("SYS$DISK")''F$DIRECTORY()'
$    WRITE SYS$OUTPUT " "
$    WRITE SYS$OUTPUT -
      "THE DEFAULT IS ", TDIR, -
      " AND SHOULD CORRESPOND TO [AIPS]."
$    CHECK:
$      INQUIRE OPTION "ENTER: 1=YES IT DOES, CONTINUE. 2=NO, EXIT"
$      IF (OPTION .EQS. "2") THEN GOTO START_OVER
$      IF (OPTION .NES. "1") THEN GOTO CHECK
$!
$  SUBDIRS:
$!   Find out what we need to use for NEW.
$      WRITE SYS$OUTPUT " "
$      WRITE SYS$OUTPUT -
        "ENTER STRING TO USE FOR NEW VERSION. " , -
        "USUALLY A DATE LIKE 15NOV84"
$      WRITE SYS$OUTPUT "(ALL ALPHANUMERIC CHARACTERS PLEASE)"
       INQUIRE NDIR "ENTER"
$!   Find out what we need to use for OLD.
$      WRITE SYS$OUTPUT "ENTER STRING TO USE FOR OLD VERSION ", -
         "(<CR> MEANS OLD=NEW)"
$      INQUIRE ODIR "ENTER"
$      IF (ODIR.EQS."") THEN ODIR = NDIR
$!
$!   Build directory names.
$      END = 'F$LOCATE("]", TDIR)'
$      TOPDIR :== 'F$EXTRACT(0,END,TDIR)'
$      NEWDIR :== 'TOPDIR'.'NDIR'
$      OLDDIR :== 'TOPDIR'.'ODIR'
$
$!   Let user verify his basic directories.
$      WRITE SYS$OUTPUT " "
$      WRITE SYS$OUTPUT "THE NEW AREA IS ", NEWDIR, "]"
$      WRITE SYS$OUTPUT "THE OLD AREA IS ", OLDDIR, "]"
$      WRITE SYS$OUTPUT " "
$      INQUIRE ANSWER "ENTER: 1 = OK, 2 = I NEED TO RE-ENTER"
$      IF (ANSWER.NES."1") THEN GOTO SUBDIRS
$
$! Enter
$! Prompt for data area names.
$!   We know what disk 1 data area is.
$      DATA1 :== 'TOPDIR'.DATA]
$    I = 2
$    DATA_LOOP:
$      ON WARNING THEN GOTO ERROR
$      IF I .GT. ANSWER1 THEN GOTO END_DATA
$      WRITE SYS$OUTPUT "ENTER PHYSICAL NAME (WITH :) FOR DISK ",I
$      INQUIRE DISK "ENTER"
$!
$!     Verify that a directory exists for this disk.
$        TDIR := 'DISK''F$DIRECTORY()'
$        END = 'F$LOCATE("]", TDIR)'
$        DIRECT := 'F$EXTRACT(0,END,TDIR)'
$        OPEN /WRITE TEMP 'DIRECT']TEMP.DAT
$        CLOSE TEMP
$        DEL 'DIRECT']TEMP.DAT.*
$!
$!     Set DATAi equal to proper subdirectory.
$        DATA'I' :== 'DIRECT'.DATA]
$        I = I + 1
$      GOTO DATA_LOOP
$      END_DATA:
$!
$! Prompt for tape drives.
$    SET NOON
$    SET ON
$    I = 1
$    TAPE_LOOP:
$      QUEST := "ENTER PHYSICAL NAME FOR TAPE "'I'-
         " (WITH :)"
$      INQUIRE PHY_TAPE "''QUEST'"
$!     Verify at least a : is in the name.
$        LENGTH = 'F$LENGTH(PHY_TAPE)'
$        POSITION = 'F$LOCATE(":",PHY_TAPE)
$        IF (POSITION .EQ. LENGTH) THEN GOTO TAPE_LOOP
$!
$!     Set TAPEi equal to proper physical name.
$        TAPE'I' := 'PHY_TAPE'
$        I = I + 1
$        IF (I .LE. ANSWER2) THEN GOTO TAPE_LOOP
$!
$! Reserved AIPS terminals.
$    I = 0
$    RESERVE_LOOP:
$      I = I + 1
$      IF (I .GT. ANSWER19) THEN GOTO END_RESERVE
$        RESERVE:
$          QUEST := "ENTER PHYSICAL NAME FOR RESERVED TERMINAL " 'I' -
             " (WITH :)"
$          INQUIRE TERM "''QUEST'"
$!         Verify at least a : is in the name.
$            LENGTH = 'F$LENGTH(TERM)'
$            POSITION = 'F$LOCATE(":",TERM)
$            IF (POSITION .EQ. LENGTH) THEN GOTO RESERVE
$            RESERVE'I' := 'TERM'
$          GOTO RESERVE_LOOP
$        END_RESERVE:
$!
$! TVs if any.
$    IF (ANSWER12.LE.0) THEN GOTO END_TV
$!  See what kind of tv is available.
$   ASKTV:
$      INQUIRE TYPE "ENTER TV TYPE : 1=IIS (M70), 2=IIS (M75), 3=DEANZA"
$      TVDIR == " "
$      IF (TYPE.EQS."1") THEN TVDIR = ".APL.YSUB.IIS]"
$      IF (TYPE.EQS."2") THEN TVDIR = ".APL.YSUB.M75]"
$      IF (TYPE.EQS."3") THEN TVDIR = ".APL.YSUB.DEA]"
$      IF (TVDIR.EQS." ") THEN GOTO ASKTV
$      DEF_TV:
$        INQUIRE TV0 "ENTER DEFAULT TV DEVICE (WITH :)"
$!       Verify at least a : is in the name.
$          LENGTH = 'F$LENGTH(TV0)'
$          POSITION = 'F$LOCATE(":",TV0)
$          IF (POSITION .EQ. LENGTH) THEN GOTO DEF_TV
$      I = 1
$      TV_LOOP:
$        QUEST := "ENTER PHYSICAL NAME FOR TV DEVICE " 'I' -
           " (WITH :)"
$          INQUIRE TERM "''QUEST'"
$!         Verify at least a : is in the name.
$            LENGTH = 'F$LENGTH(TERM)'
$            POSITION = 'F$LOCATE(":",TERM)
$            IF (POSITION .EQ. LENGTH) THEN GOTO TV_LOOP
$            TV'I' := 'TERM'
$        TV_USER:
$          QUEST := "ENTER PHYSICAL NAME FOR TV USER TERMINAL " 'I' -
             " (WITH :)"
$          INQUIRE TERM "''QUEST'"
$!         Verify at least a : is in the name.
$            LENGTH = 'F$LENGTH(TERM)'
$            POSITION = 'F$LOCATE(":",TERM)
$            IF (POSITION .EQ. LENGTH) THEN GOTO TV_USER
$          TVUSER'I' := 'TERM'
$        I = I + 1
$        IF (I .LE. ANSWER12) THEN GOTO TV_LOOP
$      END_TV:
$!
$! Prompt for message terminals and corresponding users if any.
$    I = 1
$    MESS_LOOP:
$      IF (I.GT.ANSWER20) THEN GOTO END_MESS
$        MESSAGE:
$          QUEST := "ENTER PHYSICAL NAME FOR MESSAGE TERMINAL " 'I' -
             " (WITH :)"
$          INQUIRE TERM "''QUEST'"
$!         Verify at least a : is in the name.
$            LENGTH = 'F$LENGTH(TERM)'
$            POSITION = 'F$LOCATE(":",TERM)
$            IF (POSITION .EQ. LENGTH) THEN GOTO MESS_LOOP
$          MESS'I' := 'TERM'
$!
$        USER:
$          QUEST := "ENTER PHYSICAL NAME FOR MATCHING USER TERMINAL " -
             'I' " (WITH :)"
$          INQUIRE TERM "''QUEST'"
$!         Verify at least a : is in the name.
$            LENGTH = 'F$LENGTH(TERM)'
$            POSITION = 'F$LOCATE(":",TERM)
$            IF (POSITION .EQ. LENGTH) THEN GOTO USER
$          USER'I' := 'TERM'
$      I = I + 1
$      GOTO MESS_LOOP
$      END_MESS:
$!
$! Prompt for graphics terminals and matching user terminals if any.
$    IF (ANSWER13 .LE. 0) THEN GOTO END_GRPH
$      DEF_GRPH:
$        INQUIRE GRPH0 "ENTER DEFAULT GRAPHICS TERMINAL (WITH :)"
$!       Verify at least a : is in the name.
$          LENGTH = 'F$LENGTH(GRPH0)'
$          POSITION = 'F$LOCATE(":",GRPH0)'
$          IF (POSITION .EQ. LENGTH) THEN GOTO DEF_GRPH
$      I = 1
$      GRPH_LOOP:
$        IF (I .GT. ANSWER13) THEN GOTO END_GRPH
$          GRPHAGE:
$            QUEST := "ENTER PHYSICAL NAME FOR GRAPHICS TERMINAL " 'I' -
               " (WITH :)"
$            INQUIRE TERM "''QUEST'"
$!           Verify at least a : is in the name.
$              LENGTH = 'F$LENGTH(TERM)'
$              POSITION = 'F$LOCATE(":",TERM)
$              IF (POSITION .EQ. LENGTH) THEN GOTO GRPHAGE
$              GRPH'I' := 'TERM'
$!
$          GPH_USER:
$            QUEST := "ENTER PHYSICAL NAME FOR MATCHING USERS TERMINAL " -
                'I' " (WITH :)"
$            INQUIRE TERM "''QUEST'"
$!           Verify at least a : is in the name.
$              LENGTH = 'F$LENGTH(TERM)'
$              POSITION = 'F$LOCATE(":",TERM)
$              IF (POSITION .EQ. LENGTH) THEN GOTO GPH_USER
$              GPH_USER'I' := 'TERM'
$        I = I + 1
$        GOTO GRPH_LOOP
$      END_GRPH:
$!
$! Remote users if any.
$    I = 0
$    REMOTE_LOOP:
$      I = I + 1
$      IF (I .GT. ANSWER21) THEN GOTO END_REMOTE
$        REMOTE:
$          QUEST := "ENTER PHYSICAL NAME FOR REMOTE TERMINAL " 'I' -
             " (WITH :)"
$          INQUIRE TERM "''QUEST'"
$!         Verify at least a : is in the name.
$            LENGTH = 'F$LENGTH(TERM)'
$            POSITION = 'F$LOCATE(":",TERM)
$            IF (POSITION .EQ. LENGTH) THEN GOTO REMOTE
$            REMOTE'I' := 'TERM'
$          GOTO REMOTE_LOOP
$        END_REMOTE:
$!
$! Prompt for batch terminal if batch exists.
$    IF (ANSWER5 .NE. 0) THEN -
       INQUIRE BATT0 "ENTER MESSAGE TERMINAL FOR BATCH JOBS"
$!
$! Ask for device queue for plotter.
$    PLOOP:
$      INQUIRE PLOTTER -
         "ENTER DEVICE QUEUE FOR PLOTTER. (WITH :) <CR>=NONE"
$      IF (PLOTTER .EQS. "") THEN GOTO END_PLOOP
$!       Verify at least a : is in the name.
$          LENGTH = 'F$LENGTH(PLOTTER)'
$          POSITION = 'F$LOCATE(":",PLOTTER)
$          IF (POSITION .EQ. LENGTH) THEN GOTO PLOOP
$      END_PLOOP:
$!
$! Build command file with correct assignments.
$    OPEN /WRITE ASSIGN ASSIGNL.COM
$!
$!   Precursor comments.
       WRITE ASSIGN "$! ASSIGNL"
       WRITE ASSIGN -
"$!********************************************************************"
       WRITE ASSIGN -
         "$! ASSIGNL assigns all group logicals needed for AIPS."
       WRITE ASSIGN "$!"
$!   Version identifiers.
$      WRITE ASSIGN -
         "$!                            General version identifiers"
$      WRITE ASSIGN "$ ASS/GROUP ",NEWDIR,"]  NEW"
$      WRITE ASSIGN "$ ASS/GROUP ",OLDDIR,"]  OLD"
$!
$!   Data areas.
$      WRITE ASSIGN "$!                            AIPS data areas"
$      I = 0
$      LOOP1:
$        I = I + 1
$        J = I - 1
$        WRITE ASSIGN "$ASS /GROUP ",DATA'I',"  DA0",J
$        IF (I .LT. ANSWER1) THEN GOTO LOOP1
$!
$!   Reserved AIPS terminals
$      WRITE ASSIGN -
         "$!                            Reserved AIPS terminals"
$      I = 0
$      LOOP2:
$        I = I + 1
$        IF (I.GT.ANSWER19) THEN GOTO END2
$          WRITE ASSIGN "$ASS /GROUP ",RESERVE'I',"  RESSTT",I
$          GOTO LOOP2
$        END2:
$!
$!   Message terminals
       WRITE ASSIGN "$!                           ", -
         "List message terminals w AIPS terminals"
$      WRITE ASSIGN -
         "$!                            and default message terminal"
$      WRITE ASSIGN "$ASS /GROUP TT:     TASKTT0"
$      I = 0
$      LOOP3:
$        I = I + 1
$        IF (I.GT.ANSWER20) THEN GOTO END3
$          WRITE ASSIGN "$ASS /GROUP ",MESS'I',"  TASKTT",I
$          WRITE ASSIGN "$ASS /GROUP ",USER'I',"  AIPSTT",I
$          GOTO LOOP3
$        END3:
$!
$!
$!  Batch message terminal
$     WRITE ASSIGN -
        "$!                            AIPS Batch emergency terminal"
$     IF (ANSWER5 .NE. 0) THEN -
$       WRITE ASSIGN "$ASS /GROUP ",BATT0,"  BATTT"
$!
$!  Graphics terminals.
$     IF (ANSWER13 .EQ. 0) THEN GOTO END4
$     WRITE ASSIGN -
        "$!                            TEK lists:", -
        " define TK, users, default"
$     WRITE ASSIGN "$ASS /GROUP ",GRPH0,"  TEKTK0"
$     I = 0
$     LOOP4:
$       I = I + 1
$       IF (I .GT. ANSWER13) THEN GOTO END4
$         WRITE ASSIGN "$ASS /GROUP ",GRPH'I',"  TEKTK",I
$         WRITE ASSIGN "$ASS /GROUP ",GPH_USER'I',"  AITKTT",I
$       GOTO LOOP4
$       END4:
$!
$!  TV lists
$     WRITE ASSIGN -
        "$!                            TV lists: define TVs, default"
$      I = 0
$      IF (ANSWER12.LE.0) THEN GOTO END5
$        WRITE ASSIGN "$ASS /GROUP ",NEWDIR,TVDIR," TVDIR"
$        WRITE ASSIGN "$ASS /GROUP ",TV0,"  TVDEV0"
$        LOOP5:
$          I = I + 1
$          WRITE ASSIGN "$ASS /GROUP ",TV'I',"  TVDEV",I
$          WRITE ASSIGN "$ASS /GROUP ",TVUSER'I',"  AITVTT",I
$          IF (I .LT. ANSWER12) THEN GOTO LOOP5
$      END5:
$!
$!   Tapes
$      WRITE ASSIGN "$!                            Magnetic tapes"
$      I = 0
$      LOOP6:
$        I = I + 1
$        J = I - 1
$        WRITE ASSIGN "$ASS /GROUP ",TAPE'I',"  MT0",J
$        IF (I .LT. ANSWER2) THEN GOTO LOOP6
$!
$!  Remote terminals
$     WRITE ASSIGN -
        "$!                            Remote terminals: no TV"
$     WRITE ASSIGN -
 "$!                            TEK sentback direct if not in AITKTTn"
$     I = 0
$     LOOP7:
$       I = I + 1
$       IF (I .GT. ANSWER21) THEN GOTO END7
$         WRITE ASSIGN "$ASS /GROUP ",REMOTE'I',"  REMOTT",I
$         GOTO LOOP7
$       END7:
$!
$!  RUN files area.
$     WRITE ASSIGN -
        "$!                            Run area"
$     WRITE ASSIGN "$ASS /GROUP ''TOPDIR'.RUN]  RUNFIL"
$     WRITE ASSIGN -
        "$!                            Local developement area"
$     WRITE ASSIGN "$ASS /GROUP ''TOPDIR'.LOCAL]  LOCAL"
$!
$!  Plotter queue logical name.
$     IF (PLOTTER .EQS. "") THEN GOTO CLOSE_DOWN
$       WRITE ASSIGN -
          "$!                            Plotter device queue"
$       WRITE ASSIGN "$ ASS /GROUP ''PLOTTER'   PLOTTER"
$!
$     CLOSE_DOWN:
$     CLOSE ASSIGN
$     GOTO FINI
$!
$!  Error handler for verifying disks:
$     ERROR:
$       WRITE SYS$OUTPUT " "
$       WRITE SYS$OUTPUT "There seems to be a problem", -
          " finding ",DIRECT,"]"
$       INQUIRE RESPONSE "enter <CR> to re-enter or enter EXIT to exit"
$       IF RESPONSE .NES. "EXIT" THEN GOTO DATA_LOOP
$       ERROR :== "EXIT"
$!
$!      Starting over instructions.
$         WRITE SYS$OUTPUT " "
$         WRITE SYS$OUTPUT -
            "AFTER CREATING THE PROPER DIRECTORIES, ", -
            "START OVER WITH @ILOAD"
$!
$ FINI:
$ EXIT
@@
 
 
 
             ICREATE.COM
 
$!ICREATE.COM
$!---------------------------------------------------------------------
$!  This routine creates all the subdirectories needed for this
$!  version of AIPS.
$!  INPUTS:
$!    TOPDIR  STR  The directory name corresponding to [AIPS
$!    NEWDIR  STR  The directory name corresponding to [AIPS.new
$!    ANSWER1 INT  The number of disk drives.
$!    DATA'I' STR  The data subdirectories on the available disks.
$!---------------------------------------------------------------------
$!
$  WRITE SYS$OUTPUT " "
$  WRITE SYS$OUTPUT "Creating subdirectory structure for AIPS."
$  WRITE SYS$OUTPUT -
     "If you are already running a recent enough version of AIPS some"
$  WRITE SYS$OUTPUT -
     "of these might already exist."
$  SET NOON
$!
$! Create permanent directories.  Will already exist for some.
$    I = 0
$    DISKLOOP:
$      I = I + 1
$      DATA = DATA'I'
$      CREATE /DIRECTORY 'DATA'
$      IF (I .LT. ANSWER1) THEN GOTO DISKLOOP
$!
$    CREATE /DIRECTORY 'TOPDIR'.RUN]
$    CREATE /DIRECTORY 'TOPDIR'.LOCAL]
$    CREATE /DIRECTORY 'TOPDIR'.LOCAL.SUB]
$    CREATE /DIRECTORY 'TOPDIR'.LOCAL.PGM]
$    CREATE /DIRECTORY 'TOPDIR'.LOCAL.APGM]
$    CREATE /DIRECTORY 'TOPDIR'.LOCAL.HELP]
$    CREATE /DIRECTORY 'TOPDIR'.LOCAL.LOAD]
$
$!
$! Version dependent subdirectories needed under [AIPS]
$     CREATE /DIRECTORY 'NEWDIR'.INC]
$     CREATE /DIRECTORY 'NEWDIR'.HELP]
$     CREATE /DIRECTORY 'NEWDIR'.LOAD]
$     CREATE /DIRECTORY 'NEWDIR'.AIPS]
$     CREATE /DIRECTORY 'NEWDIR'.AIPS.SUB]
$     CREATE /DIRECTORY 'NEWDIR'.AIPS.PGM]
$     CREATE /DIRECTORY 'NEWDIR'.AIPS.ZPGM]
$     CREATE /DIRECTORY 'NEWDIR'.AIPS.ZPGM.VMS]
$     CREATE /DIRECTORY 'NEWDIR'.AIPS.ZSUB.VMS]
$     CREATE /DIRECTORY 'NEWDIR'.APL]
$     CREATE /DIRECTORY 'NEWDIR'.APL.SUB]
$     CREATE /DIRECTORY 'NEWDIR'.APL.PGM]
$     CREATE /DIRECTORY 'NEWDIR'.APL.APGM]
$     CREATE /DIRECTORY 'NEWDIR'.APL.ZSUB.VMS]
$     CREATE /DIRECTORY 'NEWDIR'.APL.YSUB.IIS]
$     CREATE /DIRECTORY 'NEWDIR'.APL.YSUB.DEA]
$     CREATE /DIRECTORY 'NEWDIR'.APL.YSUB.M75]
$     CREATE /DIRECTORY 'NEWDIR'.NOTST]
$     CREATE /DIRECTORY 'NEWDIR'.NOTST.SUB]
$     CREATE /DIRECTORY 'NEWDIR'.NOTST.PGM]
$     CREATE /DIRECTORY 'NEWDIR'.NOTST.APGM]
$     CREATE /DIRECTORY 'NEWDIR'.NOTST.ZSUB.VMS]
$     CREATE /DIRECTORY 'NEWDIR'.FPS]
$     CREATE /DIRECTORY 'NEWDIR'.FPS.SUB]
$     CREATE /DIRECTORY 'NEWDIR'.FPS.ZSUB.VMS]
$     CREATE /DIRECTORY 'NEWDIR'.PSAP]
$     CREATE /DIRECTORY 'NEWDIR'.PSAP.SUB]
$     CREATE /DIRECTORY 'NEWDIR'.PSAP.ZSUB.VMS]
$     CREATE /DIRECTORY 'NEWDIR'.PSAP.LOAD]
$     CREATE /DIRECTORY 'NEWDIR'.HIST]
$     CREATE /DIRECTORY 'NEWDIR'.DOC]
$     CREATE /DIRECTORY 'NEWDIR'.DOC.TEXT]
$     CREATE /DIRECTORY 'NEWDIR'.DOC.GRIP]
$!
$ EXIT
@@
 
 
 
             ISYSPARM.COM
 
$!ISYSPARM.COM
$!---------------------------------------------------------------------
$!  This routine writes AIPS parameters needed by FORTRAN program
$!  FILAI2 to a text file [AIPS.new.DOC.TEXT]SYSPARM.
$!  INPUTS:
$!    ANSWER'I'  INT   The system parameters.
$!    QUEST'I'   STR   A description of the system parameters.
$!    NO_QUEST   INT   The number of system parameters (start with 1).
$!    COMPUTER   STR   The local computer system.
$!    NEWDIR     STR   The subdirectory corresponding to [AIPS.new
$!  OUTPUTS:
$!    SYSPARM.   FILE  A text file containing the system parameters.
$!                     This file must be in one of the text areas to
$!                     work with the AIPS based FORTRAN program FILAI2.
$!                     The one chosen was [AIPS.new.DOC.TEXT].
$!---------------------------------------------------------------------
$!
$! Create and write system parameters into temporary file to be read
$! by program FILAI2
$    OPEN /WRITE PARMS 'NEWDIR'.DOC.TEXT]SYSPARM.
$!
$    I = 0
$    WRITE:
$      I = I + 1
$      IF (I.NE.14).AND.(I.NE.15) THEN GOTO INTEGER
$!
$!       Change ANSWER14 and ANSWER15 to floating point if necessary.
$          IF (I.EQ.14) THEN NUMBER := 'ANSWER14'
$          IF (I.EQ.15) THEN NUMBER := 'ANSWER15'
$          LENGTH = 'F$LENGTH(NUMBER)'
$          POSITION = 'F$LOCATE(".",NUMBER)
$          IF (POSITION .EQ. LENGTH) THEN NUMBER := 'NUMBER'.0
$        GOTO CONT
$!
$        INTEGER:
$        NUMBER = ANSWER'I'
$        NUMBER := 'NUMBER'.0
$!
$      CONT:
$      WRITE PARMS NUMBER, "       ! ", I, "   ", QUEST'I'
$      IF (I .LT. NO_QUEST) THEN GOTO WRITE
$!   Write the TV parameters.
$    K = 1
$    NOTVQ = 2 * ANSWER12
$    TVLOOP:
$      I = I + 1
$      IF (K .GT. NOTVQ) THEN GOTO ENDTV
$      NUMBER = TVANS'K'
$      NUMBER := 'NUMBER'.0
$      WRITE PARMS NUMBER, "       ! ", I, "   ", TVQUEST'K'
$      K = K + 1
$    GOTO TVLOOP
$    ENDTV:
$    WRITE PARMS COMPUTER
$    CLOSE PARMS
$!
$ EXIT
@@
 
 
 
             ICOMPAL.COM
 
$! ICOMPAL.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure creates a library (SUBLIB.OLB) in the application
$! directory ([AIPS.new.APL]) and then compiles and inserts (or
$! replaces) all application subroutines into the library.
$! INPUTS:
$!   NEWDIR  STR  The directory corresponding to [AIPS.new
$!---------------------------------------------------------------------
$!
$ WRITE SYS$OUTPUT "CREATING APPLICATION PROGRAM LIBRARY"
$ LIBRARY 'NEWDIR'.APL]SUBLIB /CREATE
$!
$ OPEN /READ PROGLIST 'NEWDIR']FORS.CT1
$ LOOP:
$    ON ERROR THEN GOTO LOOP
$    READ /END_OF_FILE=QUIT PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.APL.SUB]'PROG'
$    LIB 'NEWDIR'.APL]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP
$ QUIT:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']ZFOR.CT1
$ LOOP2:
$    ON ERROR THEN GOTO LOOP2
$    READ /END_OF_FILE=QUIT2 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.APL.ZSUB.VMS]'PROG'
$    LIB 'NEWDIR'.APL]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP2
$ QUIT2:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']YFOR.CT1
$ LOOP3:
$    ON ERROR THEN GOTO LOOP3
$    READ /END_OF_FILE=QUIT3 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE TVDIR:'PROG'
$    LIB 'NEWDIR'.APL]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP3
$ QUIT3:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']MARS.CT1
$ LOOP4:
$    ON ERROR THEN GOTO LOOP4
$    READ /END_OF_FILE=QUIT4 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    MACRO /ENABLE=DEBUG 'NEWDIR'.APL.ZSUB.VMS]'PROG'
$    LIB 'NEWDIR'.APL]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP4
$ QUIT4:
$ CLOSE PROGLIST
$ WRITE SYS$OUTPUT "APPLICATION SUBROUTINE PROCESSING COMPLETE"
$ EXIT
@@
 
 
 
             ICOMPAI.COM
 
$! ICOMPAI.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure creates a library (SUBLIB.OLB) in the [AIPS.new.AIPS]
$! subdirectory and then compiles and inserts (or replaces) all POPS
$! subroutines into the library.
$!---------------------------------------------------------------------
$!
$ WRITE SYS$OUTPUT "CREATING POPS LANGUAGE PROCESSOR LIBRARY"
$ LIBRARY 'NEWDIR'.AIPS]SUBLIB /CREATE
$!
$ OPEN /READ PROGLIST 'NEWDIR']FORS.CT2
$ LOOP:
$    ON ERROR THEN GOTO LOOP
$    READ /END_OF_FILE=QUIT PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.AIPS.SUB]'PROG'
$    LIB 'NEWDIR'.AIPS]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP
$ QUIT:
$ CLOSE PROGLIST
$!
$!
$ OPEN /READ PROGLIST 'NEWDIR']ZFOR.CT2
$ LOOP2:
$    ON ERROR THEN GOTO LOOP2
$    READ /END_OF_FILE=QUIT2 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.AIPS.ZSUB.VMS]'PROG'
$    LIB 'NEWDIR'.AIPS]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP2
$ QUIT2:
$ CLOSE PROGLIST
$!
$!
$ WRITE SYS$OUTPUT "POPS SUBROUTINE PROCESSING COMPLETE"
$ EXIT
@@
 
 
 
             ICOMPAP.COM
 
$! ICOMPAP.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure creates a library (SUBLIB.OLB) in the AP routine
$! directory (FPS) and then compiles and inserts (or replaces) all
$! AP subroutines into the library.
$! INPUTS:
$!   NEWDIR  STR  The subdirectory corresponding to [AIPS.new
$!---------------------------------------------------------------------
$!
$ WRITE SYS$OUTPUT "CREATING AP PROGRAM LIBRARY"
$ LIBRARY 'NEWDIR'.FPS]SUBLIB /CREATE
$!
$ OPEN /READ PROGLIST 'NEWDIR']FORS.CT3
$ LOOP:
$    ON ERROR THEN GOTO LOOP
$    READ /END_OF_FILE=QUIT PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.FPS.SUB]'PROG'
$    LIB 'NEWDIR'.FPS]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP
$ QUIT:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']ZFOR.CT3
$ LOOP2:
$    ON ERROR THEN GOTO LOOP2
$    READ /END_OF_FILE=QUIT2 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.FPS.ZSUB.VMS]'PROG'
$    LIB 'NEWDIR'.FPS]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP2
$ QUIT2:
$ CLOSE PROGLIST
$!
$ WRITE SYS$OUTPUT "AP SUBROUTINE PROCESSING COMPLETE"
$ EXIT
@@
 
 
 
             ICOMPNS.COM
 
$! ICOMPNS.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure creates a library (SUBLIB.OLB) in the 'not standard'
$! subdirectory ([AIPS.new.NOTST]) and then compiles and inserts (or
$! replaces) all non-standard subroutines into the library.
$! INPUTS:
$!   NEWDIR  STR  The subdirectory corresponding to [AIPS.new
$!---------------------------------------------------------------------
$!
$ WRITE SYS$OUTPUT "CREATING NOT STANDARD PROGRAM LIBRARY"
$ LIBRARY 'NEWDIR'.NOTST]SUBLIB /CREATE
$!
$ OPEN /READ PROGLIST 'NEWDIR']FORS.CT5
$ LOOP:
$    ON ERROR THEN GOTO LOOP
$    READ /END_OF_FILE=QUIT PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.NOTST.SUB]'PROG'
$    LIB 'NEWDIR'.NOTST]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP
$ QUIT:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']MARS.CT5
$ LOOP2:
$    ON ERROR THEN GOTO LOOP2
$    READ /END_OF_FILE=QUIT2 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    MACRO /ENABLE=DEBUG 'NEWDIR'.NOTST.ZSUB.VMS]'PROG'
$    LIB 'NEWDIR'.NOTST]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP2
$ QUIT2:
$ CLOSE PROGLIST
$!
$ WRITE SYS$OUTPUT "NOT STANDARD SUBROUTINE PROCESSING COMPLETE"
$ EXIT
@@
 
 
 
             ICOMPPS.COM
 
$! ICOMPPS.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure creates a library (SUBLIB.OLB) in the pseudo AP
$! subdirectory and then compiles and inserts (or replaces) all pseudo
$! AP subroutines into the library.
$!---------------------------------------------------------------------
$!
$ WRITE SYS$OUTPUT "CREATING PSEUDO AP LIBRARY"
$ LIBRARY 'NEWDIR'.PSAP]SUBLIB /CREATE
$!
$ OPEN /READ PROGLIST 'NEWDIR']FORS.CT4
$ LOOP:
$    ON ERROR THEN GOTO LOOP
$    READ /END_OF_FILE=QUIT PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.PSAP.SUB]'PROG'
$    LIB 'NEWDIR'.PSAP]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP
$ QUIT:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']MARS.CT4
$ LOOP2:
$    ON ERROR THEN GOTO LOOP2
$    READ /END_OF_FILE=QUIT2 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    MACRO /ENABLE=DEBUG 'NEWDIR'.PSAP.SUB]'PROG'
$    LIB 'NEWDIR'.PSAP]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP2
$ QUIT2:
$ CLOSE PROGLIST
$!
$ OPEN /READ PROGLIST 'NEWDIR']ZFOR.CT4
$ LOOP3:
$    ON ERROR THEN GOTO LOOP3
$    READ /END_OF_FILE=QUIT3 PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.PSAP.ZSUB.VMS]'PROG'
$    LIB 'NEWDIR'.PSAP]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP3
$ QUIT3:
$ CLOSE PROGLIST
$ WRITE SYS$OUTPUT "PSEUDO AP PROCESSING COMPLETE"
$ EXIT
@@
 
 
 
             ICOMPIC.COM
 
$! ICOMPIC.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure creates a library (SUBLIB.OLB) in the ICAP pseudo AP
$! subdirectory and then compiles and inserts (or replaces) all ICAP
$! pseudo AP subroutines into the library.
$!---------------------------------------------------------------------
$!
$ WRITE SYS$OUTPUT "CREATING ICAP PSEUDO AP LIBRARY"
$ LIBRARY 'NEWDIR'.ICAP]SUBLIB /CREATE
$!
$ OPEN /READ PROGLIST 'NEWDIR']FORS.CT6
$ LOOP:
$    ON ERROR THEN GOTO LOOP
$    READ /END_OF_FILE=QUIT PROGLIST LINE
$    DOTPOS = 'F$LOCATE(".",LINE)
$    PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$    WRITE SYS$OUTPUT PROG
$    FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.ICAP.SUB]'PROG'
$    LIB 'NEWDIR'.ICAP]SUBLIB /REPLACE 'PROG'
$    DEL 'PROG'.OBJ.*
$    GOTO LOOP
$ QUIT:
$ CLOSE PROGLIST
$!
$ CLOSE PROGLIST
$ WRITE SYS$OUTPUT "SINGLE TASK PSEUDO AP PROCESSING COMPLETE"
$ EXIT
@@
 
 
 
             ILINKA.COM
 
$! ILINKA.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure compiles and links all tasks in the
$! [AIPS.new.AIPS.PGM] directory.  This includes AIPS itself, the batch
$! programs plus a number of utility programs.
$! INPUTS:
$!   NEWDIR  STR  The subdirectory corresponding to [AIPS.new
$!---------------------------------------------------------------------
$!
$!                                      Link POPS programs.
$OPEN /READ PROGLIST 'NEWDIR']EXES.CT2
$WRITE SYS$OUTPUT "BEGIN POPS TASK PROCESSING"
$LOOP:
$     ON WARNING THEN GOTO HANDLER
$     READ /END_OF_FILE=QUIT PROGLIST LINE
$     DOTPOS = 'F$LOCATE(".",LINE)
$     PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$     WRITE SYS$OUTPUT PROG
$     FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.AIPS.PGM]'PROG'
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE    'PROG', -
         'NEWDIR'.AIPS]SUBLIB/LIB, -
         'NEWDIR'.APL]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$QUIT:
$     CLOSE PROGLIST
$WRITE SYS$OUTPUT "POPS TASK PROCESSING COMPLETE"
$EXIT
$HANDLER:
$   WRITE ERR_FILE "****************** ERROR ABOVE IN ",PROG
$   GOTO LOOP
@@
 
 
 
             ILINKT.COM
 
$! ILINKT.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure compiles and links all tasks in the applications
$! ([AIPS.new.APL.PGM]) directory that do not use the AP.
$! INPUTS:
$!   NEWDIR  STR  The directory corresponding to [AIPS.new
$!---------------------------------------------------------------------
$!
$WRITE SYS$OUTPUT "BEGIN APPLICATIONS TASK PROCESSING"
$!                                      Link non AP programs.
$OPEN /READ PROGLIST 'NEWDIR']EXES.CT1
$LOOP:
$     ON WARNING THEN GOTO HANDLER
$     READ /END_OF_FILE=QUIT PROGLIST LINE
$     DOTPOS = 'F$LOCATE(".",LINE)
$     PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$     WRITE SYS$OUTPUT PROG
$     FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.APL.PGM]'PROG'
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.APL]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$QUIT:
$     CLOSE PROGLIST
$WRITE SYS$OUTPUT "APPLICATION TASK PROCESSING COMPLETE"
$EXIT
$HANDLER:
$   WRITE ERR_FILE "****************** ERROR ABOVE IN ",PROG
$   GOTO LOOP
@@
 
 
 
             ILINKNS.COM
 
$! ILINKNS.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure compiles and links all tasks in the 'not standard'
$! ([AIPS.new.NOTST.PGM]) directory that do not use the AP.
$!---------------------------------------------------------------------
$!
$WRITE SYS$OUTPUT "BEGIN NOT STANDARD TASK PROCESSING"
$!                                      Link non AP programs.
$OPEN /READ PROGLIST 'NEWDIR']EXES.CT5
$LOOP:
$     ON WARNING THEN GOTO HANDLER
$     READ /END_OF_FILE=QUIT PROGLIST LINE
$     DOTPOS = 'F$LOCATE(".",LINE)
$     PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$     WRITE SYS$OUTPUT PROG
$     FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.NOTST.PGM]'PROG'
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.NOTST]SUBLIB/LIB, -
        'NEWDIR'.APL]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$QUIT:
$     CLOSE PROGLIST
$WRITE SYS$OUTPUT "NOT STANDARD TASK PROCESSING COMPLETE"
$EXIT
$HANDLER:
$   WRITE ERR_FILE "****************** ERROR ABOVE IN ",PROG
$   GOTO LOOP
@@
 
 
 
             ILINKAP.COM
 
$! ILINKAP.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure compiles and links all tasks in the applications
$! directory ([AIPS.new.APL.APGM]) that use the AP.
$! INPUTS:
$!   NEWDIR   STR    Directory corresponding to [AIPS.new
$!   GOTAP    INT    0 means AP not available use pseudo AP lib.
$!   FPSAREA  STR    device:[directory] of FPS libraries
$!---------------------------------------------------------------------
$!
$!                                      Link AP programs.
$WRITE SYS$OUTPUT "BEGIN AP NOT STANDARD TASK PROCESSING"
$OPEN /READ PROGLIST 'NEWDIR']APS.CT1
$LOOP:
$   ON WARNING THEN GOTO HANDLER
$   READ /END_OF_FILE=QUIT PROGLIST LINE
$   DOTPOS = 'F$LOCATE(".",LINE)
$   PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$   WRITE SYS$OUTPUT PROG
$   FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.APL.APGM]'PROG'
$   IF (GOTAP .EQ. 0) THEN GOTO NOAP
$!                                      AP available.
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'NEWDIR'.FPS]SUBLIB/LIB, -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'FPSAREA'HSRLIB/LIB, -
        'FPSAREA'FPSLIB/LIB
$     LINK /EXE='NEWDIR'.PSAP.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'NEWDIR'.PSAP]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$!                                      No AP.
$   NOAP:
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'NEWDIR'.PSAP]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$QUIT:
$CLOSE PROGLIST
$!
$WRITE SYS$OUTPUT "AP TASK PROCESSING COMPLETE"
$EXIT
$HANDLER:
$   WRITE ERR_FILE "****************** ERROR ABOVE IN ",PROG
$   GOTO LOOP
@@
 
 
 
             ILINKAN.COM
 
$! ILINKAN.COM
$!---------------------------------------------------------------------
$! This command procedure is a part of the AIPS installation system.
$! This procedure compiles and links all tasks in the 'not standard'
$! directory ([AIPS.new.NOTST.APGM]) that use the AP.
$! INPUTS:
$!   NEWDIR   STR    Directory corresponding to [AIPS.new
$!   GOTAP    INT    0 means AP not available use pseudo AP lib.
$!   FPSAREA  STR    device:[directory] of FPS libraries
$!---------------------------------------------------------------------
$!
$!                                      Link AP programs.
$WRITE SYS$OUTPUT "BEGIN AP NOT STANDARD TASK PROCESSING"
$OPEN /READ PROGLIST 'NEWDIR']APS.CT5
$LOOP:
$   ON WARNING THEN GOTO HANDLER
$   READ /END_OF_FILE=QUIT PROGLIST LINE
$   DOTPOS = 'F$LOCATE(".",LINE)
$   PROG := "''F$EXTRACT(0,DOTPOS,LINE)'"
$   WRITE SYS$OUTPUT PROG
$   FOR /NOI4/DEBUG/NOOPTIMIZE 'NEWDIR'.NOTST.APGM]'PROG'
$   IF (GOTAP .EQ. 0) THEN GOTO NOAP
$!                                      AP available.
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.NOTST]SUBLIB/LIB, -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'NEWDIR'.FPS]SUBLIB/LIB, -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'FPSAREA'HSRLIB/LIB, -
        'FPSAREA'FPSLIB/LIB
$     LINK /EXE='NEWDIR'.PSAP.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.NOTST]SUBLIB/LIB, -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'NEWDIR'.PSAP]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$!                                      No AP.
$   NOAP:
$     LINK /EXE='NEWDIR'.LOAD]'PROG'.EXE   'PROG' , -
        'NEWDIR'.NOTST]SUBLIB/LIB, -
        'NEWDIR'.APL]SUBLIB/LIB, -
        'NEWDIR'.PSAP]SUBLIB/LIB
$     DEL 'PROG'.OBJ.*
$     GOTO LOOP
$QUIT:
$CLOSE PROGLIST
$!
$WRITE SYS$OUTPUT "AP NOT STANDARD TASK PROCESSING COMPLETE"
$EXIT
$HANDLER:
$   WRITE ERR_FILE "****************** ERROR ABOVE IN ",PROG
$   GOTO LOOP
@@
