#! /bin/sh
#------------------------------------------------
# This is an AIPS self-unpacking shell archive   
# created on Wed Jul 17 13:59:54 EDT 1991.
#------------------------------------------------
#  XVSS distribution kit.
#-----------------------------------------------
cat > Makefile << --XYZZY--
# Makefile for the XView Screen Server (XVSS)
#----------------------------------------------------------------
#   Set the following parameters to reflect your system
#   configuration.
#
#   Destination for executable.  If you are building XVSS on a
#   system that has AIPS installed this should be the same as
#   the AIPS LOAD area.  Some implementations of make allow the
#   use of an environmental variable as showm here: check your
#   system documentation.
DESTDIR = $(LOAD)

#   Additional include files.  Some X Window System
#   implementations do not place their include in the standard
#   Unix directory /usr/include.  The include directories should
#   be listed here, each preceded by -I.  The following is
#   suitable for a Sun OpenWindows installation.
INCDIRS = -I$(OPENWINHOME)/include

#   Library search path.  Standard Unix libraries are usually
#   found in /usr/lib; some X Window System implementations
#   place their libraries in other locations.  These should
#   be listed here, each preceded by -L.
LIBDIRS = -L$(OPENWINHOME)/lib

#   Destination for helpfile.  The AIPS help directory is only a
#   suggestion.
HELPDIR = $(HLPFIL)

#   The X Shared Memory Extension can significantly improve the
#   performance of XVSS.  If you have the X Shared Memory
#   extension and your version of Unix supports shared memory
#   segments leave the following  definition as it is, otherwise
#   set the value to blank.
#SHMOPT = -DUSE_SHM
SHMOPT =

#    Add local compiler/linker options here.  For example Sun 3s
#    will require a -f option to specify the floating point
#    hardware option.
# LOCALOPTS = -g
LOCALOPTS = 

#    Do not alter anything below this line
#--------------------------------------------------------------------

.c.o :
	$(CC) $(CCOPTS) $<

CCOPTS = $(INCDIRS) $(SHMOPT) $(LOCALOPTS) -c

OBJECTS = colmap.o cursor.o imgio.o scrwrt.o socket.o sockxf.o window.o xvss.o

all : $(DESTDIR)/XVSS $(HELPDIR)/xvss.info

$(HELPDIR)/xvss.info : xvss.info
	cp xvss.info $(HELPDIR)

xvss.info : xvss.uu
	uudecode xvss.uu       # need to do this because the brain-
                               # damaged AIPS code management system
                               # objects to long lines.

$(DESTDIR)/XVSS : xvss
	mv xvss $(DESTDIR)/XVSS


xvss : $(OBJECTS)
	$(CC) $(LIBDIRS) $(LOCALOPTS) $(OBJECTS) \
           -lxview -lolgx -lX11 -lXext -lm  -o xvss

colmap.o : colmap.c header.h

cursor.o : cursor.c header.h

imgio.o : imgio.c header.h

scrwrt.o : scrwrt.c header.h

socket.o : socket.c header.h

sockxf.o : socket.c header.h

window.o : window.c header.h aips.icon

xvss.o : xvss.c header.h
--XYZZY--
cat > aips.icon << --XYZZY--
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
 */
	0x0000,0x0000,0x0000,0x0FFF,
	0x0000,0x0000,0x0000,0x1FFF,
	0x0000,0x0000,0x0000,0x7FFF,
	0x0000,0x0000,0x0000,0xFF3F,
	0x0000,0x0000,0x0001,0xFC7F,
	0x0000,0x0000,0x0003,0xF9FF,
	0x0000,0x0000,0x0007,0xF1FF,
	0x0000,0x0000,0x0007,0xC3FF,
	0x0000,0x0000,0x0007,0x83F7,
	0x0000,0x0000,0x0007,0x07E7,
	0x0000,0x1000,0x0006,0x07C3,
	0x0000,0x3F00,0x0006,0x0703,
	0x0000,0x7FC0,0x0006,0x0603,
	0x0000,0x4FE0,0x0000,0x0603,
	0x0001,0xCDF0,0x0000,0x0603,
	0x0003,0xFEF8,0x0000,0x0603,
	0x0007,0xFEF8,0x0000,0x0603,
	0x0007,0xFCFF,0x0000,0x0403,
	0x0007,0xBFFF,0xC000,0x0003,
	0x0000,0x7FFF,0xC000,0x0003,
	0x0003,0xFFFF,0xF000,0x0003,
	0x0001,0xFBFF,0xF800,0x0003,
	0x0000,0x77FF,0xF800,0x0003,
	0x0000,0x0FFF,0xFC00,0x0003,
	0x0000,0x07FF,0xFF00,0x0003,
	0x0000,0x07FF,0xFF80,0x0003,
	0x0000,0x07FF,0xFFFC,0x0003,
	0x0000,0x07FF,0xFFFF,0x0003,
	0x0000,0x0FFF,0xFFFF,0x0003,
	0x0000,0x0FFF,0xFFFF,0x8003,
	0x0000,0x1FFF,0xFFFF,0x8003,
	0x0000,0x1FFF,0xFFFF,0x8003,
	0x0000,0x3FFF,0xFFFF,0x0003,
	0x0000,0x3FFF,0xFFFF,0x0003,
	0x0000,0x7F9F,0xFFFF,0x0003,
	0x0000,0xFE6F,0xFFFF,0x0003,
	0x0000,0xFC73,0x7FFF,0x0003,
	0x0001,0xFCF0,0x05DF,0x8003,
	0x0003,0xF0F0,0x020F,0x8003,
	0x0007,0xC0E0,0x03F7,0xC003,
	0x000F,0xC1E0,0x03F7,0xE003,
	0x000F,0xC1F0,0x01FB,0xE003,
	0x000F,0xE1F0,0x00FB,0xE002,
	0x000F,0xE1F0,0x01F9,0xF000,
	0x000F,0xC1E0,0x07F9,0xF000,
	0x000F,0x8000,0x07F7,0xE000,
	0x0000,0x0000,0x0007,0x8000,
	0x0000,0x0000,0x0000,0x0000,
	0xFFFF,0xFFFF,0xFFFF,0xFFFF,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000
--XYZZY--
cat > header.h << --XYZZY--
/*--------------------------------------------------------------------*/
/*! (XView XVSS) include file to declare the TV luts, memory, etc.    */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/

/* Things needed for windows */

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <xview/xview.h>
#include <xview/canvas.h>
#include <xview/icon.h>
#include <xview/panel.h>
#include <xview/notify.h>
#include <xview/svrimage.h>
#include <xview/xv_xrect.h>
#include <xview/cursor.h>

/* Header for shared memory extension */

#ifdef USE_SHM
#include <sys/ipc.h>
#include <sys/shm.h>
#include <X11/extensions/XShm.h>
#endif

char *ProgName;
                                        /* size of I/O buffer (bytes)  */
#define BUFLEN 4096

                                        /* size of logical screen      */
                                        /* (best if somewhat smaller   */
                                        /* than the physical display - */
                                        /* use xdpyinfo to get display */
                                        /* size                        */
                                        /* must be EVEN numbers !      */
int Screen_Width, Screen_Height;
                                        /* margin to leave between     */
                                        /* image and frame when window */
                                        /* is expanded to full size:   */
                                        /* should *not* include size   */
                                        /* of control panel            */
int panel_ht;                           /* height of control panel     */
int Screen_Xmarg, Screen_Ymarg;
                                        /* I can find no way to ask the*/
                                        /* window manager the size of  */
                                        /* its top and left borders.   */
                                        /* They need to be visible to  */
                                        /* allow window resize, move...*/
                                        /* Numbers for SUN OpenLook    */
/* #define TEXT_SPACE      0 */         /* empty space @ bottom screen*/
#define TEXT_SPACE     70               /* preferred by NRAO ?        */
#define SCREEN_LEFT     5
#define SCREEN_RIGHT    5
#define SCREEN_TOP     26
#ifdef USE_SHM
#define SCREEN_BOTTOM  (26 + TEXT_SPACE)
#else
#define SCREEN_BOTTOM   (5 + TEXT_SPACE)
#endif
unsigned int twidth, theight;           /* screen total size           */

/* "#define NCOLOUR       112" */       /* number grey levels in: 0-111*/
/* "#define NVALUE        128" */       /* total levels: 112-126 for   */
int NColour, NValue;                    /* graphics, 127 cursor        */
                                        /* number of grey-scale        */
                                        /* intensities                 */
#define NINTENS       256
#define COLORSHIFT      8               /* 255 max from ofm then shift */
                                        /* 8 bits left for col table   */

#define NGREY           2               /* number of grey-scale planes */
#define NGRAPH          4               /* # graphics overlay planes   */
                                        /* cursor [0], graphics [1-4]  */
int rgrfx[5], ggrfx[5], bgrfx[5], rgcol[16], ggcol[16], bgcol[16];
                                        /* total number of planes      */
                                        /* (grey-scale + graphics)     */
#define NGRTOT    (NGREY+NGRAPH)

                                        /* maximum zoom factor         */
#define ZOOM_LIMIT    16

Frame frame;                            /* XView root window           */
Canvas canvas;                          /* XView drawing window        */
Display *display;                       /* pointer to X11 display      */
                                        /* structure                   */
Window window;                          /* X11 window ID for the       */
                                        /* canvas paint window (which  */
                                        /* is where we do the drawing) */
GC ImageGC, BasicGC;                    /* X11 graphics contexts for   */
                                        /* drawing images, graphics &  */
                                        /* the offset bit              */

int sc_centre_x;                        /* pixel at centre of screen   */
int sc_centre_y;
int sc_width, sc_height;                /* size of screen              */
int sc_width2, sc_height2;              /* half-size of screen         */
int cur_chan;                           /* channel curently displayed  */
int rwgraph;                            /* graphics planes displayed   */
unsigned char gph_mask;
int depth;                              /* depth of window in bits     */

int redo_hibit;                         /* True if offset bit needs to */
                                        /* be set or reset             */

void repaint_canvas();                  /* XVSS functions              */
void redraw_canvas();
void resize_canvas();
void handle_events();
void button_a_pressed();
void button_b_pressed();
void button_c_pressed();
void button_d_pressed();
void resize_pressed();
int  button_status();

/* Header info needed for socket routines (including i/o) */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netdb.h>
#include <netinet/in.h>

int connected;                          /* True if a client is         */
                                        /* connected to XVSS, False    */
                                        /* otherwise                   */

int g;                                  /* Socket file descriptor      */

/* opcode, status etc (server/client protocol) */

unsigned char buf[BUFLEN];              /* I/O buffer                  */
short int *buf_out;                     /* short int alias for buf     */
short int dat[4];                       /* "fixed" data                */
short int ndata;                        /* length of "variable" data   */
int XvssDebug, XDebug;

                                        /* Look-up tables              */
typedef struct xv_singlecolor {
   unsigned char red, green, blue;
} Xv_singlecolor;
/* Xv_singlecolor cursfg, cursbg, cfg0, cbg0; */
Cursor cursor;
int cursor_shape;                      /* standard cursor shape number*/

Colormap TV_colour;                    /* private colour map for TV   */
XColor *colour_table;                  /* colour map data buffer      */
XColor fg_curs, bg_curs;
                                       /* Use 256, need only NColour  */
                                       /* but that's found later      */
int rlut[NGREY][256],                  /* red, green and blue LUT     */
    glut[NGREY][256],                  /* registers for each grey-    */
    blut[NGREY][256];                  /* scale plane                 */
int rofm[NINTENS], gofm[NINTENS],      /* red, green and blue OFM     */
    bofm[NINTENS];                     /* registers                   */
int offset;                            /* starting value of TV colour */
                                       /* table                       */

int upleft_x[NGRTOT], upleft_y[NGRTOT]; /* pixel at upper-left of     */
                                       /* window                      */
int upleft_mag;                        /* zoom factor                 */

/* The following describe the window state. The user may toggle       */
/* between a large window showing the whole screen with and a small   */
/* window with dimensions set by the window manager (and which may    */
/* be modified using the mouse if the window manager supports this).  */

int big_screen;                         /* True if screen is at max.  */
                                        /* size, False otherwise      */

int cur_xcorn, cur_ycorn;               /* current location of top-left*/
                                        /* corner of smaller window   */

int cur_xsize, cur_ysize;               /* current size of smaller    */
                                        /* window                     */

                                        /* Image data structures      */

XImage *plane[NGREY];                   /* grey-scale planes          */
XImage *line;                           /* for zoomed image line      */
XImage *graph;                          /* graphics overlay           */
unsigned char *plane_data[NGREY];       /* data storage               */
unsigned char *line_data;
unsigned char *graph_data;

                                        /* Shared memory              */
int using_shm;                          /* set True if using SHM      */
#ifdef USE_SHM
XShmSegmentInfo plane_info[NGREY];      /* shm info for image planes  */
XShmSegmentInfo graph_info;             /* shm info for graphics plane*/
XShmSegmentInfo line_info;              /* shm info for zoom buffers  */
#endif

/* Timers */

#include <sys/time.h>
#define ITIMER_NULL ((struct itimerval *)NULL)

/* Useful macros */

#define Memory_x(aips_x)  ((aips_x) - 1)
#define Memory_y(aips_y)  (Screen_Height - (aips_y))
#define Aips_x(memory_x)  ((memory_x) + 1)
#define Aips_y(memory_y)  (Screen_Height - (memory_y))
#define chg_s(var,val,msk) ((var) = ((var)&(~(msk)))|((val) ? (msk) : 0))
#define chg_g(var,msk)    (((var)&(msk)) ? 1 : 0)

#ifndef min
#define min(a,b) ((a)<(b)?(a):(b))
#endif

#ifndef max
#define max(a,b) ((a)>(b)?(a):(b))
#endif

#define intswap(a,b) { int tmp; tmp=a; a=b; b=tmp; }


/* Defined opcodes */
#define NUMOP 83                        /* Largest opcode             */

int bufferop[NUMOP+1];                  /* bufferop[OP] is True if    */
                                        /* there is no status return  */
                                        /* in buffered mode           */
#define OPEN    11     /* Opens the SSS - a NOP                       */
#define CLOSE   12     /* Close the SSS, allows new connections       */
#define INTGT   13     /* Interrogate; determine SSS basic parameters */
#define WINDO   14     /* Read, write SSS window size                 */
#define CLEAR   15     /* Clear some or all channels                  */
#define VIEW    16     /* Do/hold screen updates                      */
#define IMWRT   21     /* Write an image line to some channel         */
#define IMRD    22     /* Read an image line from some channel        */
#define WLUT    41     /* Write LUT to a channel.                     */
#define RLUT    42     /* Read LUT to a channel.                      */
#define WOFM    43     /* Write OFM             .                     */
#define ROFM    44     /* Read OFM.                                   */
#define GRAPH   45     /* On/off graphics channel(s)                  */
#define SPLIT   46     /* On/off image channels(s)                    */
#define WGRFX   51     /* Write graphics/cursor colours               */
#define RGRFX   52     /* Read  graphics/cursor colours               */
#define RCURS   61     /* Read the cursor position.                   */
#define RBUTT   62     /* Read the status of the buttons              */
#define WCURS   63     /* Write the cursor position.                  */
#define RCURB   64     /* Read the cursor position and buttons        */
#define WZOOM   81     /* Write zoom info to the SSS                  */
#define WSCROL  82     /* Write scroll registers                      */
#define WZSCR   83     /* Write zoom/scroll to SSS using ULC          */
--XYZZY--
cat > colmap.c << --XYZZY--
#include "header.h"

int cmap_wlut()
/*--------------------------------------------------------------------*/
/*! Set look up tables ("color maps") (XView version)                 */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/*   Write the ncolour LookUpTable into memory and to colormap        */
/*--------------------------------------------------------------------*/
{
   int i, j;
/*--------------------------------------------------------------------*/
   j = dat[3] - 1;
   if ((dat[3] < 1) || (dat[3] > NGREY)) {
      fprintf (stderr, "Illegal grey channel %d\n", dat[3]);
      return (-1);
      }
   else {
      if (dat[0] != 0)
         for (i = 0; i < NColour; ++i)
            rlut[j][i] = buf[i];
      if (dat[1] != 0)
         for (i = 0; i < NColour; ++i)
            glut[j][i] = buf[i];
      if (dat[2] != 0)
         for (i = 0; i < NColour; ++i)
            blut[j][i] = buf[i];
      return (dat[3] == cur_chan ? cmap_change() : 0);
      }
}

int cmap_rlut()
/*--------------------------------------------------------------------*/
/*   Read the ncolour LookUpTable from  memory                        */
/*--------------------------------------------------------------------*/
{
   int i, j;
/*--------------------------------------------------------------------*/
   j = dat[3] - 1;
   if ((dat[3] < 1) || (dat[3] > NGREY)) {
      fprintf (stderr, "Illegal grey channel %d\n", dat[3]);
      return (-1);
      }
   else {
      if (dat[0] != 0)
         for (i = 0; i < NColour; ++i)
            buf_out[i] = rlut[j][i];
      if (dat[1] != 0)
         for (i = 0; i < NColour; ++i)
            buf_out[i] = glut[j][i];
      if (dat[2] != 0)
         for (i = 0; i < NColour; ++i)
            buf_out[i] = blut[j][i];
      return (0);
      }
}

int cmap_wofm()
/*--------------------------------------------------------------------*/
/*   Write the NINTENS OutputFunction into memory and to colormap     */
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   if (dat[0] != 0)
      for (i = 0; i < NINTENS; ++i)
         rofm[i] = buf[i];
   if (dat[1] != 0)
      for (i = 0; i < NINTENS; ++i)
         gofm[i] = buf[i];
   if (dat[2] != 0)
      for (i = 0; i < NINTENS; ++i)
         bofm[i] = buf[i];
   return (cmap_change());
}

int cmap_rofm()
/*--------------------------------------------------------------------*/
/*   Read the NINTENS OutputFunction from memory                      */
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   if (dat[0] != 0)
      for (i = 0; i < NINTENS; ++i)
         buf_out[i] = rofm[i];
   if (dat[1] != 0)
      for (i = 0; i < NINTENS; ++i)
         buf_out[i] = gofm[i];
   if (dat[2] != 0)
      for (i = 0; i < NINTENS; ++i)
         buf_out[i] = bofm[i];
   return (0);
}

int cmap_graph()
/*--------------------------------------------------------------------*/
/*   Switch graphics plane(s) on or off.                              */
/*--------------------------------------------------------------------*/
{
   int prevgraph;
/*--------------------------------------------------------------------*/
   if ((dat[0] < 1) || (dat[0] > NGRAPH)) {
      fprintf (stderr, "Illegal graphics channel %d\n", dat[0]);
      return (-1);
      }
   else {
      prevgraph = rwgraph;
      gph_mask = 1;
      if (dat[0] == 2) gph_mask = 2;
      if (dat[0] == 3) gph_mask = 4;
      if (dat[0] == 4) gph_mask = 8;
      if (dat[1] > 0)
         rwgraph = rwgraph | gph_mask;
      else
         rwgraph = rwgraph & (~ gph_mask);
      if (prevgraph != rwgraph) {
         redo_hibit = False;
         redraw_canvas(canvas, canvas_paint_window(canvas),
                        display, window, (Xv_xrectlist*) NULL);
         return (cmap_change());
         }
      else
         return (0);
      }
}

int cmap_split()
/*--------------------------------------------------------------------*/
/*   Switch grey-scale channel.                                       */
/*--------------------------------------------------------------------*/
{
   int prevchan;
/*--------------------------------------------------------------------*/
   if ((dat[0] < 0) || (dat[0] > NGREY)) {
      fprintf (stderr, "Illegal grey channel %d\n", dat[0]);
      return (-1);
      }
   else if ((dat[1] != dat[0]) || (dat[2] != dat[0]) ||
      (dat[3] != dat[0])) {
      fprintf (stderr, "Split not implemented %d %d %d %d\n", dat[0],
         dat[1], dat[2], dat[3]);
      return (-1);
      }
   else {
      prevchan = cur_chan;
      cur_chan = dat[0];
      if (prevchan != cur_chan) {
         redo_hibit = False;
         redraw_canvas (canvas, canvas_paint_window(canvas),
                        display, window, (Xv_xrectlist*) NULL);
         return (cmap_change());
         }
      else
         return (0);
      }
}
cmap_wgrfx()
/*--------------------------------------------------------------------*/
/* Writes the cursor and graphics colour assignment.                  */
/*                                                                    */
/* MRC 90/Feb/15:                                                     */
/*--------------------------------------------------------------------*/
{
   void crscol();
   int i;

   if ((dat[0] < 0) || (dat[0] > NGRAPH)) {
      fprintf (stderr, "Illegal grafix channel %d\n", dat[0]);
      return (-1);
      }

   rgrfx[dat[0]] = dat[1];
   ggrfx[dat[0]] = dat[2];
   bgrfx[dat[0]] = dat[3];

/*                                      make cross colors             */
   crscol (rgrfx, rgcol);
   crscol (ggrfx, ggcol);
   crscol (bgrfx, bgcol);

                                        /* make cursor colors         */
   if (dat[0] == 0) {
      if (fg_curs.pixel >= 0) {
         bg_curs.red = 0;
         bg_curs.green = 0;
         bg_curs.blue = 0;
         fg_curs.red = rgcol[15] << COLORSHIFT;
         fg_curs.green = ggcol[15] << COLORSHIFT;
         fg_curs.blue = bgcol[15] << COLORSHIFT;
         XRecolorCursor (display, cursor, &fg_curs, &bg_curs);
         }
      return (0);
      }
                                        /* change the screen colors   */
   else
      return (cmap_change());

}

void crscol (grfx, gcol)
/*--------------------------------------------------------------------*/
/* converts grfx[5] to full set of colors gcol[16] where              */
/* Input:  grfx i[5]   cursor, 4 graphics values for a color          */
/* Output: gcol i[16]  graphics values 1-15, cursor for the color     */
/*--------------------------------------------------------------------*/
   int *grfx, *gcol;
/*--------------------------------------------------------------------*/
{
   *(gcol+0) = *(grfx+1);
   *(gcol+1) = *(grfx+2);
   *(gcol+2) = *(grfx+1) ^ *(grfx+2);
   *(gcol+3) = *(grfx+3);
   *(gcol+4) = *(grfx+1) ^ *(grfx+3);
   *(gcol+5) = *(grfx+2) ^ *(grfx+3);
   *(gcol+6) = *(grfx+1) ^ *(gcol+5);
   *(gcol+7) = *(grfx+4);
   *(gcol+8) = *(grfx+4) ^ *(gcol+0);
   *(gcol+9) = *(grfx+4) ^ *(gcol+1);
   *(gcol+10) = *(grfx+4) ^ *(gcol+2);
   *(gcol+11) = *(grfx+4) ^ *(gcol+3);
   *(gcol+12) = *(grfx+4) ^ *(gcol+4);
   *(gcol+13) = *(grfx+4) ^ *(gcol+5);
   *(gcol+14) = *(grfx+4) ^ *(gcol+6);

   *(gcol+15) = *(grfx+0);
}

cmap_rgrfx()
/*--------------------------------------------------------------------*/
/* Reads the cursor and graphics colour assignment.                   */
/*                                                                    */
/* MRC 90/Feb/15:                                                     */
/*--------------------------------------------------------------------*/
{
   if ((dat[0] < 0) || (dat[0] > NGRAPH)) {
      fprintf (stderr, "Illegal grafix channel %d\n", dat[0]);
      return (-1);
   }

   buf_out[0] = rgrfx[dat[0]];
   buf_out[1] = ggrfx[dat[0]];
   buf_out[2] = bgrfx[dat[0]];

   return (0);
}

cmap_change()
/*--------------------------------------------------------------------*/
/* Changes the colormap based on the stored LUTs and OFMs in core.    */
/*--------------------------------------------------------------------*/
{
   register int i, ns, j;
/*--------------------------------------------------------------------*/
   j = cur_chan - 1;
                                       /* do the NColour of image      */
                                       /* first                        */
   if (cur_chan > 0) {
      for (i = 0; i < NColour; ++i) {
         colour_table[i].red = rofm[rlut[j][i]] << COLORSHIFT;
         colour_table[i].green = gofm[glut[j][i]] << COLORSHIFT;
         colour_table[i].blue = bofm[blut[j][i]] << COLORSHIFT;
         }
      colour_table[0].red = colour_table[0].blue
        = colour_table[0].green = 0;
      }
                                       /* image is off                */
   else {
      for (i = 0; i < NColour; ++i) {
         colour_table[i].red = colour_table[i].blue
           = colour_table[i].green = 0;
         }
      }
/*                                      add in graphics               */
   ns = NColour;
   for (i = NColour; i < NValue; ++i) {
       colour_table[i].red = rgcol[i-ns] << COLORSHIFT;
       colour_table[i].green = ggcol[i-ns] << COLORSHIFT;
       colour_table[i].blue = bgcol[i-ns] << COLORSHIFT ;
       }
   XStoreColors (display, TV_colour, colour_table, NValue);

   return (0);
}
--XYZZY--
cat > cursor.c << --XYZZY--
#include "header.h"

static int button_a = 0, button_b = 0;  /* number of times each       */
static int button_c = 0, button_d = 0;  /* button was pressed since   */
                                        /* last RBUTT operation       */

static int cursor_x, cursor_y;          /* location of cursor         */

void handle_events (window, event, arg)
/*--------------------------------------------------------------------*/
/*! (XView XVSS) maintains cursor position, scaling, buttons          */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/*  This keeps track of the cursor in the canvas - however it only    */
/*  keeps track of the dragged cursor so that when you leave the      */
/*  canvas to do other things your (e.g.) transfer fn won't get all   */
/*  fouled up. This assumes the LOC_DRAG* event processing is enabled.*/
/*  It also keeps track of function key events - which it maps into   */
/*  "button" presses.                                                 */
/*--------------------------------------------------------------------*/
    Xv_Window window;
    Event *event;
    caddr_t arg;
/*--------------------------------------------------------------------*/
{
   if ((event_id(event) == LOC_DRAG) ||
      (event_action(event) == ACTION_SELECT)) {
      cursor_x = event_x(event) + sc_centre_x - sc_width2 + 1;
      cursor_y = event_y(event) + sc_centre_y - sc_height2 + 1;
      if (XDebug) fprintf (stderr,
         "event x,y cursor x,y %d,%d %d,%d\n", event_x(event),
         event_y(event), cursor_x, cursor_y);
      }
   else if (event_is_down(event)) {
      if (event_id(event) == KEY_TOP(2))
         resize_pressed();
      if (event_id(event) == KEY_TOP(3))
         button_a_pressed();
      if (event_id(event) == KEY_TOP(4))
         button_b_pressed();
      if (event_id(event) == KEY_TOP(5))
         button_c_pressed();
      if (event_id(event) == KEY_TOP(6))
         button_d_pressed();
      if (event_id(event) == KEY_TOP(7))
         resize_pressed();
      if (event_id(event) == KEY_TOP(8))
         XvssDebug = !XvssDebug;
      if (event_id(event) == KEY_TOP(9))
         XDebug = !XDebug;
      }
   else if (event_action(event) == ACTION_HELP) {
      xv_help_show (window, "xvss:canvas", event);
      }
}

int cursor_position()
/*--------------------------------------------------------------------*/
/*   Get current cursor position.                                     */
/*--------------------------------------------------------------------*/
{
   buf_out[0] = Aips_x (cursor_x);
   buf_out[1] = Aips_y (cursor_y);

   return (0);
}

int cursor_move()
/*--------------------------------------------------------------------*/
/*  Sets the cursor position */
/*--------------------------------------------------------------------*/
{
   int xc, yc;
   Rect *current;
   Rect *window_size;
/*--------------------------------------------------------------------*/
   cursor_x = Memory_x (dat[0]);
   cursor_y = Memory_y (dat[1]);
                                        /* should be -1 but cursor    */
                                        /* moves!                     */
   xc = cursor_x - sc_centre_x + sc_width2;
   yc = cursor_y - sc_centre_y + sc_height2;

                                       /* Warp cursor to AIPS cursor  */
                                       /* position, but only if       */
                                       /* already in the window to    */
                                       /* comply with ICCCM guide-    */
                                       /* lines.                      */
   current = (Rect *) xv_get (canvas, WIN_MOUSE_XY);
   window_size = (Rect *) xv_get (canvas, WIN_RECT);
   if (XDebug) fprintf (stderr,
      "WIN_MOUSE x,y Order x,y Cursor x,y %d,%d %d,%d %d,%d\n",
       current->r_left, current->r_top, xc, yc, cursor_x, cursor_y);
   if (current->r_left >= 0 &&
       current->r_left < window_size->r_width &&
       current->r_top >= 0 && current->r_top < window_size->r_height)
                                       /* check that destination is   */
                                       /* in window                   */
   if (xc < sc_width && yc < sc_height && xc >= 0 && yc >= 0)
      xv_set (canvas, WIN_MOUSE_XY, xc, yc, NULL);

   return (0);
}

void resize_canvas (cnvs, width, height)
/*--------------------------------------------------------------------*/
/*  Called when the screen gets resized. Simply sets some scales and  */
/*  offsets, which are now set in redraw_canvas                       */ 
/*--------------------------------------------------------------------*/
   Canvas cnvs;
   int width;
   int height;
/*--------------------------------------------------------------------*/
{
   redo_hibit = True;
   if (XvssDebug) fprintf (stderr, "resize_canvas\n");
}

void repaint_canvas (canvas, pw, disp, xid, xrects)
/*--------------------------------------------------------------------*/
/* Repaints the entire canvas.                                        */
/*--------------------------------------------------------------------*/
    Canvas canvas;
    Xv_Window pw;
    Display *disp;
    Window xid;
    Xv_xrectlist *xrects;
/*--------------------------------------------------------------------*/
{
   redo_hibit = True;
   if (XvssDebug) fprintf (stderr, "repaint_canvas\n");
   redraw_canvas (canvas, canvas_paint_window(canvas),
      display, window, (Xv_xrectlist*) NULL);
}

void button_a_pressed()
/*--------------------------------------------------------------------*/
/*   Increment number of button A presses.                            */
/*--------------------------------------------------------------------*/
{
   button_a + = 1;
}

void button_b_pressed()
/*--------------------------------------------------------------------*/
/*   Increment number of button B presses.                            */
/*--------------------------------------------------------------------*/
{
   button_b + = 1;
}

void button_c_pressed()
/*--------------------------------------------------------------------*/
/*   Increment number of button C presses.                            */
/*--------------------------------------------------------------------*/
{
   button_c + = 1;
}

void button_d_pressed()
/*--------------------------------------------------------------------*/
/*   Increment number of button D presses.                            */
/*--------------------------------------------------------------------*/
{
   button_d + = 1;
}

void resize_pressed()
/*--------------------------------------------------------------------*/
/* Toggle between full screen and smaller window set by the window    */
/* manager.                                                           */
/*--------------------------------------------------------------------*/
{
   int itx, ity, icx, icy;
/*--------------------------------------------------------------------*/
   Rect *window_size;

   big_screen = !big_screen;
   if (big_screen) {
      window_size = (Rect *) xv_get (frame, WIN_RECT);
      cur_xcorn = window_size->r_left;
      cur_ycorn = window_size->r_top;
      cur_xsize = window_size->r_width;
      cur_ysize = window_size->r_height;
      itx = Screen_Width + Screen_Xmarg;
      ity = Screen_Height + Screen_Ymarg + panel_ht;
      redo_hibit = True;
      icx = 0;
      icy = 0;
      }
   else {
      itx = cur_xsize;
      ity = cur_ysize;
      icx = cur_xcorn;
      icy = cur_ycorn;
      }
   icx = max (icx, SCREEN_LEFT);
   icy = max (icy, SCREEN_TOP);
   icx = min (icx, twidth - SCREEN_RIGHT - itx);
   icy = min (icy, theight - SCREEN_BOTTOM - ity);

   xv_set (frame, XV_WIDTH, itx, XV_HEIGHT, ity, WIN_X, icx,
      WIN_Y, icy, NULL);
}

button_status()
/*--------------------------------------------------------------------*/
/*  Returns how many times each of the buttons has been pressed and   */
/*  returns those numbers in buf, and then resets the counts.         */
/*--------------------------------------------------------------------*/
{
   buf_out[0] = button_a;
   buf_out[1] = button_b;
   buf_out[2] = button_c;
   buf_out[3] = button_d;
   button_a = button_b = button_c = button_d = 0;

   return (0);
}

int cursor_button()
{
    buf_out[0] = Aips_x (cursor_x);
    buf_out[1] = Aips_y (cursor_y);

    buf_out[2] =  button_a;
    buf_out[3] =  button_b;
    buf_out[4] =  button_c;
    buf_out[5] =  button_d;

    button_a = button_b = button_c = button_d = 0;
    return (0);
}

int windo_status()
/*--------------------------------------------------------------------*/
/*  Returns current window corners                                    */
/*--------------------------------------------------------------------*/
{
   int itx, ity, icx, icy;
/*--------------------------------------------------------------------*/
                                        /* force screen size          */
   if (dat[0] > 0 && dat[1] > 0 && dat[2] > 0 && dat[3] > 0) {
      if (dat[2] > Screen_Width) dat[2] = Screen_Width;
      if (dat[3] > Screen_Height) dat[3] = Screen_Height;
      itx = Memory_x (dat[0]);
      icx = Memory_x (dat[2]);
      ity = Memory_y (dat[3]);
      icy = Memory_y (dat[1]);
      sc_width = icx - itx + 1;
      sc_height = icy - ity + 1;
      sc_centre_x = (icx + itx - 1) / 2;
      sc_centre_y = (icy + ity - 1) / 2;
      sc_width2 = sc_width / 2;
      sc_height2 = sc_height / 2;
      itx = sc_width + Screen_Xmarg;
      ity = sc_height + Screen_Ymarg + panel_ht;
      icx = (int) xv_get (frame, WIN_X);
      icy = (int) xv_get (frame, WIN_Y);
      icx = min (icx, Screen_Width - sc_width);
      icy = min (icy, Screen_Height - sc_height);
      icx = max (icx, SCREEN_LEFT);
      icy = max (icx, SCREEN_TOP);
      icx = min (icx, twidth - SCREEN_RIGHT - itx);
      icy = min (icy, theight - SCREEN_BOTTOM - ity);
      xv_set (frame, XV_WIDTH, itx, XV_HEIGHT, ity, WIN_X, icx,
         WIN_Y, icy,  NULL);
      }
   buf_out[0] = Aips_x (sc_centre_x - sc_width2 + 1);
   buf_out[3] = Aips_y (sc_centre_y - sc_height2 + 1);
   buf_out[2] = Aips_x (sc_centre_x + sc_width2);
   buf_out[1] = Aips_y (sc_centre_y + sc_height2);

   return (0);
}
--XYZZY--
cat > imgio.c << --XYZZY--
#include "header.h"

int imwrt()
/*--------------------------------------------------------------------*/
/*! (XView XVSS) write to / read from the TV memory and display       */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This routine responds to opcode 21 and writes an image row to the  */
/* screen                                                             */
/*--------------------------------------------------------------------*/
{
   int xs, ys, iangl, channel, j, k, vv;
   register int i, npix;
/*--------------------------------------------------------------------*/
   redo_hibit = False;
   xs = Memory_x(dat[0]);
   ys = Memory_y(dat[1]);
   channel = dat[2];
   iangl = dat[3];
   npix = ndata;
 
   if ((channel < 1) || (channel > NGRTOT)) {
      fprintf (stderr, "Bad imwrt channel = %d\n", channel);
      return (-1);
      }

   gph_mask = 0;
   if (channel == NGREY+1) gph_mask = 1;
   if (channel == NGREY+2) gph_mask = 2;
   if (channel == NGREY+3) gph_mask = 4;
   if (channel == NGREY+4) gph_mask = 8;
   j = channel - 1;

   if (iangl == 0) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            XPutPixel (plane[j], xs+i, ys, buf[i]);
            }
      else {
         for (i = 0; i < npix; i++) {
            vv = XGetPixel (graph, xs+i, ys);
            chg_s (vv, buf[i], gph_mask);
            XPutPixel (graph, xs+i, ys, vv);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
         scrwrt (xs, ys, xs + npix, ys);
      }
   else if (iangl == 1) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            XPutPixel (plane[j], xs, ys-i, buf[i]);
            }
      else {
         for (i = 0; i < npix; i++) {
            vv = XGetPixel (graph, xs, ys-i);
            chg_s (vv, buf[i], gph_mask);
            XPutPixel (graph, xs, ys-i, vv);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
         scrwrt (xs, ys - npix, xs, ys);
      }
   else if (iangl == 2) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            XPutPixel (plane[j], xs-i, ys, buf[i]);
            }
      else {
         for (i = 0; i < npix; i++) {
            vv = XGetPixel (graph, xs-i, ys);
            chg_s (vv, buf[i], gph_mask);
            XPutPixel (graph, xs-i, ys, vv);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
        scrwrt (xs - npix, ys, xs, ys);
      }
   else if (iangl == 3) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            XPutPixel (plane[j], xs, ys+i, buf[i]);
            }
      else {
         for (i = 0; i < npix; i++) {
            vv = XGetPixel (graph, xs, ys+i);
            chg_s (vv, buf[i], gph_mask);
            XPutPixel (graph, xs, ys+i, vv);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
         scrwrt (xs, ys, xs, ys + npix);
      }
   return (0);
}

int imrd (nwpix)
/*--------------------------------------------------------------------*/
/* This subroutine returns an image line to the client. It's not very */
/* general for number of channels, but is easy to change so that's    */
/* likely good enough (just add new macros etc.)                      */
/*--------------------------------------------------------------------*/
short int *nwpix;
/*--------------------------------------------------------------------*/
{
   int xs, ys, iangl, channel, j, vv;
   short int jj;
   register int i, npix;
/*--------------------------------------------------------------------*/
   xs = Memory_x(dat[0]);
   ys = Memory_y(dat[1]);
   channel = dat[2];
   iangl = dat[3];
                                        /* special I*2 word in buffer */
   jj = *((short int *)buf);
   npix =  ntohs (jj);
   *nwpix = npix;

   if ((channel < 1) || (channel > NGRTOT)) {
      fprintf (stderr, "Bad imrd channel = %d\n", channel);
      return (-1);
      }

   gph_mask = 0;
   if (channel == NGREY+1) gph_mask = 1;
   if (channel == NGREY+2) gph_mask = 2;
   if (channel == NGREY+3) gph_mask = 4;
   if (channel == NGREY+4) gph_mask = 8;
   j = channel - 1;

   if (iangl == 0) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = XGetPixel (plane[j], xs+i, ys);
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (XGetPixel (graph, xs+i, ys), gph_mask);
            }
      }
   else if (iangl == 1) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = XGetPixel (plane[j], xs, ys-i);
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (XGetPixel (graph, xs, ys-i), gph_mask);
            }
      }
   if (iangl == 2) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = XGetPixel (plane[j], xs-i, ys);
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (XGetPixel (graph, xs-i, ys), gph_mask);
            }
      }
   else if (iangl == 3) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = XGetPixel (plane[j], xs, ys+i);
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (XGetPixel (graph, xs, ys+i), gph_mask);
            }
      }

   return (0);

}
Interogate (nparms)
/*--------------------------------------------------------------------*/
/* This subroutine returns the critical parameters of the TV to the   */
/* client in the order of DTVC.INC                                    */
/*--------------------------------------------------------------------*/
short int *nparms;
/*--------------------------------------------------------------------*/
{

   *nparms = 29;
   buf_out[0] = NGREY;
   buf_out[1] = NGRAPH;
   buf_out[2] = -1;
   buf_out[3] = Screen_Width;
   buf_out[4] = Screen_Height;
   buf_out[5] = NColour - 1;
   buf_out[6] = (NINTENS) - 1;
   buf_out[7] = (NINTENS) - 1;
   buf_out[8] = (NINTENS) - 1;
   buf_out[9] = 1;
   buf_out[10] = 1;
   buf_out[11] = 1 - (ZOOM_LIMIT);
   buf_out[12] = -1;
   buf_out[13] = -1;
   buf_out[14] = 0;
   buf_out[15] = 0;
   buf_out[16] = 3;
   buf_out[17] = 3;
   buf_out[18] = -1;
   buf_out[19] = -1;
   buf_out[20] = -1;
   buf_out[21] = -1;
   buf_out[22] = -1;
   buf_out[23] = -1;
   buf_out[24] = -1;
   buf_out[25] = -1;
   buf_out[26] = -1;
   buf_out[27] = -1;
   buf_out[28] = -1;

   return (0);
}

--XYZZY--
 cat > scrwrt.c << --XYZZY--
#include "header.h"

void scrwrt (xs, ys, xe, ye)
/*--------------------------------------------------------------------*/
/*! (XView XVSS) update TV display from memory with zoom, scroll      */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Draws from memory image to the screen taking account of zoom,      */
/* scroll and window offsets etc. Updates that rectangle enclosed by  */
/* xs, ys, xe, ye.  Dimensions are screen units.                      */
/*--------------------------------------------------------------------*/
   int xs, ys, xe, ye;
/*--------------------------------------------------------------------*/
{
   int xmin, xmax, ymin, ymax, xext, yext, amin, amax, xoff, yoff;
   int choff;
   void scrdoit();
/*--------------------------------------------------------------------*/
                                        /* Just return if no canvas   */
                                        /* has been established yet:  */
   if (canvas == NULL) return;

                                        /* Make sure xs, ys, xe, ye   */
                                        /* in window since no clip in */
                                        /* zoom!                      */
   choff = cur_chan - 1;
   if (choff < 0) choff = 0;
                                        /* Upper left quadrant        */
   xmin = upleft_x[choff] * upleft_mag + sc_centre_x - sc_width2 + 1;
   xmax = upleft_x[choff] * upleft_mag + sc_centre_x + sc_width2;
   if (xmin >= Screen_Width * upleft_mag) {
      xmin -= Screen_Width * upleft_mag;
      xmax -= Screen_Width * upleft_mag;
      }
   xext = xmax - (Screen_Width - 1) * upleft_mag;
   if (xext > 0)
      xmax = (Screen_Width - 1) * upleft_mag;
   ymin = upleft_y[choff] * upleft_mag + sc_centre_y - sc_height2 + 1;
   ymax = upleft_y[choff] * upleft_mag + sc_centre_y + sc_height2;
   if (ymin >= Screen_Height * upleft_mag) {
      ymin -= Screen_Height * upleft_mag;
      ymax -= Screen_Height * upleft_mag;
      }
   yext = ymax - (Screen_Height - 1) * upleft_mag;
   if (yext > 0)
      ymax = (Screen_Height - 1) * upleft_mag;
   xoff = yoff = 0;
   scrdoit (xs, ys, xe, ye, xmin, ymin, xmax, ymax, xoff, yoff);
                                       /* Upper right quadrant        */
   if (xext > 0) {
      amin = 0;
      amax = xext - upleft_mag;
      xoff = xmax + upleft_mag - xmin;
      yoff = 0;
      scrdoit (xs, ys, xe, ye, amin, ymin, amax, ymax, xoff, yoff);
      }
                                      /* Lower left quadrant          */
   if (yext > 0) {
      amin = 0;
      amax = yext - upleft_mag;
      xoff = 0;
      yoff = ymax + upleft_mag - ymin;
      scrdoit (xs, ys, xe, ye, xmin, amin, xmax, amax, xoff, yoff);
      }
                                      /* Lower right quadrant         */
   if ((xext > 0) && (yext > 0)) {
      xoff = xmax + upleft_mag - xmin;
      yoff = ymax + upleft_mag - ymin;
      amin = 0;
      amax = yext - 1;
      xmin = 0;
      xmax = xext - 1;
      scrdoit (xs, ys, xe, ye, xmin, amin, xmax, amax, xoff, yoff);
      }

}

void scrdoit (xs, ys, xe, ye, xmin, ymin, xmax, ymax, xoff, yoff)
/*--------------------------------------------------------------------*/
/* Draws from memory image to the screen taking account of zoom,      */
/* scroll and window offsets etc.  Updates that rectangle enclosed by */
/* xs, ys, xe, ye.  Dimensions are screen units before zoom for xs,   */
/* ys, xe, ye and AFTER zoom for the others.  This means that the left*/
/* column and upper row and right column and lower row may not be     */
/* replicated upleft_mag times in zoom.                               */
/*--------------------------------------------------------------------*/
   int xs, ys, xe, ye, xmin, ymin, xmax, ymax, xoff, yoff;
/*--------------------------------------------------------------------*/
{
   int i, x, y, offset, k, choff;
   register unsigned char *pi, *pl, *gi, *gl, *mp;
   int gphv, imv, mem_full[4096], xx, yy, nx, ny;
   register int j, jj;
   unsigned long pv;
   Rect *limits;
#ifdef USE_SHM
   XEvent event;
   Bool is_complete();
#endif
/*--------------------------------------------------------------------*/
   xs = max (xs, xmin / upleft_mag);
   ys = max (ys, ymin / upleft_mag);
   xe = min (xe, xmax / upleft_mag);
   ye = min (ye, ymax / upleft_mag);
   choff = max (0, cur_chan - 1);
   upleft_mag = max (1, upleft_mag);

   if ((xe >= xs) && (ye >= ys)) {
      if (redo_hibit) {
         limits = (Rect *) xv_get (canvas, WIN_RECT);
         XFillRectangle (display, window, BasicGC, 0, 0,
            limits->r_width, limits->r_height);
         }
                                       /* find number x points        */
      nx = upleft_mag * (xe - xs + 1);
      offset = upleft_mag * xs - xmin + xoff;
      if (offset < 0) {
         nx += offset;
         offset = 0;
         }
      nx = min (nx, xmax - xmin + xoff - offset + 1);
                                       /* no graphics is faster       */
      if (rwgraph <= 0) {
                                       /* no zoom is easy             */
         if (upleft_mag <= 1) {
#ifdef USE_SHM
	    if (using_shm) {
               (void) XShmPutImage (display, window, ImageGC,
                  plane[choff], xs, ys, xs - xmin + xoff,
		  ys - ymin + yoff, nx, ye - ys + 1, True);
               XIfEvent (display, &event, is_complete, NULL);
               }
            else
#endif /* USE_SHM */
               XPutImage(display, window, ImageGC, plane[choff], xs, ys,
                  xs - xmin + xoff, ys - ymin + yoff, nx, ye - ys + 1);
            }
         else {                         /* zoom no graphics           */
            for (i = ys; i <= ye; i++) {
                                        /* Optimized route for 8-bit  */
                                        /* displays.                  */
               if (depth == 8) {
                  for (x=0; x < upleft_mag; x++) {
                     offset = upleft_mag * xs - xmin + x + xoff;
                     pl = line_data + offset;
                     pi = plane_data[choff] + Screen_Width * i + xs;
                     j = (xe - xs) + 1;
                     if (offset < 0) {
                        pl += upleft_mag;
                        pi += 1;
                        j--;
                        }
                     while (j--) {
                        *pl = *pi++;
                        pl += upleft_mag;
                        }
                     }
                                        /* replicate the row          */
                  offset = max (upleft_mag * xs - xmin + xoff, 0);
                  yy = upleft_mag * i - ymin + yoff;
                  ny = upleft_mag;
                  if (yy < 0) {
                     ny += yy;
                     yy = 0;
                     }
                  ny = min (ymax - ymin + yoff + 1 - yy, ny);
                  for (y = 1; y < ny; y++)
                     bcopy (line_data + (offset),
                        line_data + (Screen_Width * y + offset), nx);
                                        /* move to the display        */
#ifdef USE_SHM
                  if (using_shm) {
                     (void) XShmPutImage (display, window, ImageGC,
                        line, offset, 0, offset, yy, nx, ny, True);
                     XIfEvent (display, &event, is_complete, NULL);
	             }
                  else
#endif
                     XPutImage (display, window, ImageGC, line, offset,
                        0, offset, yy, nx, ny);
                  } /* depth = 8 */
                                        /* Displays that are not     */
                                        /* 8-bit deep are handled    */
                                        /* with generic Xlib calls.  */
               else {
                                        /* zoom a row                 */
                  offset = upleft_mag * xs - xmin + xoff;
                  for (j = xs; j <= xe; j++) {
                     pv = XGetPixel (plane[choff], j, i);
                     for (jj = 0; jj < upleft_mag; jj++) {
                        if (offset > 0) XPutPixel (line, offset, 0, pv);
                        offset++;
                        } /* jj */
                     } /* j = xs-xe */
                                        /* replicate the row          */
                  offset = upleft_mag * xs - xmin + xoff;
                  yy = upleft_mag * i - ymin + yoff;
                  ny = upleft_mag;
                  if (yy < 0) {
                     ny += yy;
                     yy = 0;
                     }
                  ny = min (ymax - ymin + yoff + 1 - yy, ny);
#ifdef USE_SHM
                  if (using_shm) {
                     for (y = 1; y < ny; y++) {
                        (void) XShmPutImage (display, window, ImageGC,
                           line, offset, 0, offset, yy + y, nx, 1,
                           True);
                        XIfEvent (display, &event, is_complete, NULL);
	                }
                     }
                  else
#endif
                     for (y = 1; y < ny; y++)
                        XPutImage (display, window, ImageGC, line,
                           offset, 0, offset, yy + y, nx, 1);
                  }  /* depth != 8 */
               }     /* for i = ys:ye       */
            }        /* else upleft_mag > 1 */
         }           /* rwgraph <= 0        */
                                        /* graphics are on            */
      else {
         for (i = ys; i <= ye; i++) {
                                        /* fast when 8-bit chars      */
            if (depth == 8) {
                                        /* get graphics + image line  */
               pi = plane_data[choff] + Screen_Width * i + xs;
               gi = graph_data + Screen_Width * i + xs;
               jj = NColour - 1;
               for (j = xs; j <= xe; j++) {
                  gphv = rwgraph & *gi++;
                  imv = *pi++;
                  if (gphv > 0)
                     mem_full[j] = jj + gphv;
                  else
                     mem_full[j] = imv;
                  }
                                        /* zoom a row                 */
               for (x = 0; x < upleft_mag; x++) {
                  offset = upleft_mag * xs - xmin + x + xoff;
                  pl = line_data + offset;
                  yy = xs;
                  if (offset < 0) {
                     pl += upleft_mag;
                     yy++;
                     }
                  for (j = yy; j <= xe; j++) {
                     *pl = mem_full[j];
                     pl += upleft_mag;
                     }
                  }
                                        /* replicate the row         */
               offset = max (upleft_mag * xs - xmin + xoff, 0);
               yy = upleft_mag * i - ymin + yoff;
               ny = upleft_mag;
               if (yy < 0) {
                  ny += yy;
                  yy = 0;
                  }
               ny = min (ymax - ymin + yoff + 1 - yy, ny);
               for (y = 1; y < ny; y++)
                  bcopy (line_data + (offset),
                     line_data + (Screen_Width * y + offset), nx);
                                        /* move to the display        */
#ifdef USE_SHM
               if (using_shm) {
                  (void) XShmPutImage (display, window, ImageGC, line,
                     offset, 0, offset, yy, nx, ny, True);
                  XIfEvent (display, &event, is_complete, NULL);
                  }
               else {
#endif
                  XPutImage (display, window, ImageGC, line, offset, 0,
                     offset, yy, nx, ny);
#ifdef USE_SHM
                  }  /* using_shm */
#endif
               } /* depth = 8 */
                                        /* Displays that are not      */
                                        /* 8-bit deep are handled     */
                                        /* with generic Xlib calls.   */
            else {
                                        /* get graphics + image line  */
               offset = upleft_mag * xs - xmin + xoff;
               for (j = xs; j <= xe; j++) {
                  gphv = rwgraph & XGetPixel (graph, j, i);
                  if (gphv > 0)
                     pv = jj + gphv;
                  else
                     pv = XGetPixel (plane[choff], j, i);
                                        /* zoom the pixel             */
                  for (jj = 0; jj < upleft_mag; jj++) {
                     if (offset > 0) XPutPixel (line, offset, 0, pv);
                     offset++;
                     } /* jj */
                  } /* j = xs-xe */
                                        /* replicate the row          */
               offset = upleft_mag * xs - xmin + xoff;
               yy = upleft_mag * i - ymin + yoff;
               ny = upleft_mag;
               if (yy < 0) {
                  ny += yy;
                  yy = 0;
                  }
               ny = min (ymax - ymin + yoff + 1 - yy, ny);
#ifdef USE_SHM
               if (using_shm) {
                  for (y = 1; y < ny; y++) {
                     (void) XShmPutImage (display, window, ImageGC,
                        line, offset, 0, offset, yy + y, nx, ny,
                        True);
                     XIfEvent (display, &event, is_complete, NULL);
                     }
                  }
               else {
#endif
                  for (y = 1; y < ny; y++)
                     XPutImage (display, window, ImageGC, line,
                        offset, 0, offset, yy + y, nx, 1);
#ifdef USE_SHM
                  }  /* using_shm */
#endif
               }  /* depth != 8 */
            }     /* for i = ys:ye       */
         }        /* rwgraph > 0         */
      }           /* xe>=xs, ye>=ys      */

   redo_hibit = False;
}

void redraw_canvas (canvas, pw, disp, xid, xrects)
/*--------------------------------------------------------------------*/
/* Repaints the entire canvas.                                        */
/*--------------------------------------------------------------------*/
    Canvas canvas;
    Xv_Window pw;
    Display *disp;
    Window xid;
    Xv_xrectlist *xrects;
/*--------------------------------------------------------------------*/
{
   int icx, icy, itx, ity, jcx, jcy, jtx, jty;
   Rect *window_size;
                                        /* get frame coordinates      */
   window_size = (Rect *) xv_get (frame, WIN_RECT);
   jcx = icx = window_size->r_left;
   jcy = icy = window_size->r_top;
   jtx = itx = window_size->r_width;
   jty = ity = window_size->r_height;
                                        /* set widths                 */
   sc_width = itx -  Screen_Xmarg;
   sc_height = ity -  Screen_Ymarg - panel_ht;
   sc_width = min (sc_width, Screen_Width);
   sc_height = min (sc_height, Screen_Height);
   sc_width2 = sc_width / 2;
   sc_height2 = sc_height / 2;
                                        /* set center coords          */
   sc_centre_x = max (sc_centre_x, sc_width2 - 1);
   sc_centre_y = max (sc_centre_y, sc_height2 - 1);
   sc_centre_x = min (sc_centre_x, Screen_Width - sc_width2 - 1);
   sc_centre_y = min (sc_centre_y, Screen_Height - sc_height2 - 1);
                                        /* check frame coords         */
   itx = sc_width + Screen_Xmarg;
   ity = sc_height + Screen_Ymarg  + panel_ht;
   icx = max (icx, SCREEN_LEFT);
   icy = max (icy, SCREEN_TOP);
   icx = min (icx, twidth - SCREEN_RIGHT - itx);
   icy = min (icy, theight - SCREEN_BOTTOM - ity);
                                        /* resize, bring into view    */
   if ((jtx != itx) || (jty != ity)) {
      xv_set (frame, XV_WIDTH, itx, XV_HEIGHT, ity, NULL); 
      redo_hibit = True;
      if (XvssDebug) fprintf (stderr, 
         "redraw_canvas: new W H %d %d\n", itx, ity);
      }
   else {
      if (XvssDebug) fprintf (stderr, 
         "redraw_canvas: sizes stay %d %d\n", itx, ity);
      }
                                        /* repaint the picture       */
    scrwrt (0, 0, Screen_Width - 1, Screen_Height - 1);
}

int screen_clear()
/*--------------------------------------------------------------------*/
/* This opcode clears all image and graphics channels, but is meant   */
/* to leave scroll and zoom "registers" alone.                        */
/*--------------------------------------------------------------------*/
{
   int channel, imax, j;
   register int i;
   unsigned char *t1, *t2;
/*--------------------------------------------------------------------*/
   channel = dat[0];
   if ((channel < 0) || (channel > NGRTOT))
      return (-1);
   imax = Screen_Width * Screen_Height * ((depth+1)/8);

   for (j = 0; j < NGREY; j++) {
      if ((channel == 0) || (channel == j+1)) {
         t1 = plane_data[j];
         for (i = 0; i < imax; i++)
             *t1++ = 0;
         }
      }
   if (channel == 0) {
      t2 = graph_data;
      for (i = 0; i < imax; i++)
         *t2++ = 0;
      }

   if (channel > NGREY) {
      gph_mask = 15;
      if (channel == NGREY + 1) gph_mask = 14;
      if (channel == NGREY + 2) gph_mask = 13;
      if (channel == NGREY + 3) gph_mask = 11;
      if (channel == NGREY + 4) gph_mask = 7;
      t2 = graph_data;
      for (i = 0; i < imax; i++)
         *t2++ = *t2 & gph_mask;
      }

   redo_hibit = False;
   redraw_canvas (canvas, canvas_paint_window(canvas), display,
      window, (Xv_xrectlist *) NULL);
   return (0);
}

int zoom()
/*--------------------------------------------------------------------*/
/* Sets the zoom registers                                            */
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   redo_hibit = False;
   if ((dat[0] < 0) || (dat[0] > NGRTOT)) {
      fprintf (stderr, "Illegal zoom channel %d\n", dat[0]);
      return (-1);
      }
   else if (dat[0] > NGREY) {
      }
   else if ((dat[1] < 1) || (dat[1] > ZOOM_LIMIT)) {
      fprintf (stderr, "Illegal magnification %d\n", dat[1]);
      return (-1);
      }
   else if (dat[0] == 0) {
      upleft_mag = dat[1];
      for (i = 0; i < NGREY; i++) {
         upleft_x[i] = dat[2];
         upleft_y[i] = dat[3];
         }
      redraw_canvas (canvas, canvas_paint_window(canvas), display,
         window, (Xv_xrectlist *) NULL);
      }
   else {
      upleft_mag = dat[1];
      upleft_x[dat[0]-1] = dat[2];
      upleft_y[dat[0]-1] = dat[3];
      if ((dat[0] == cur_chan) || (cur_chan == 0))
         redraw_canvas (canvas, canvas_paint_window(canvas), display,
            window, (Xv_xrectlist *) NULL);
      }

   return (0);
}

#ifdef USE_SHM
/* Predicate procedure for XIfEvent: */
Bool
is_complete (display, event, arg)
Display *display;
XEvent  *event;
char    *arg;
{
   if (event->type == (XShmGetEventBase (display) + ShmCompletion))
      return True;
   else
      return False;
}
#endif
--XYZZY--
cat > socket.c << --XYZZY--
#include "header.h"
#include <strings.h>

/* Domain types */

#define UNIX_DOMAIN 0
#define INET_DOMAIN 1

static int AipsSocket;                   /* socket for communcations   */
                                        /* to and from XVSS           */
static struct sockaddr_un server_un;    /* Unix domain socket address */

static int domain_type;                 /* UNIX_DOMAIN or             */
                                        /* INET_DOMAIN, depending on  */
                                        /* domain of socket           */

static int buffered;                    /* True if socket is          */
                                        /* buffered                   */

Notify_value get_client(me, which)
/*--------------------------------------------------------------------*/
/*! (XView XVSS) locates a client request, gets and closes sockets    */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Get a client from the specified socket.  Note that this blocks.    */
/*--------------------------------------------------------------------*/
   Notify_client me;
   int which;
/*--------------------------------------------------------------------*/
{
   int read_mask;
   struct sockaddr_un from_un;
   struct sockaddr_in from_in;
   int len;

   static struct timeval time_0;

   static int my_client_object;         /* These two lines make a     */
   static int *me2 = &my_client_object; /* unique handle              */

   Notify_value sock_io();
/*--------------------------------------------------------------------*/
   time_0.tv_sec = 0;
   time_0.tv_usec = 0;
                                       /* We're only interested in    */
                                       /* one socket. Be careful if   */
                                       /* you have > 1                */
   read_mask = 1 << AipsSocket;
   if ((connected == False) && (select(32, &read_mask, (int *) NULL,
      (int *) NULL, &time_0) > 0)) {
      if (domain_type == INET_DOMAIN) {
         len = sizeof(from_in);
         if ((g = accept(AipsSocket, &from_in, &len)) < 0) {
            perror ("Accept (INET)");
            connected = False;
            }
         else {
            (void) notify_set_input_func(me2, sock_io, g);
            connected = True;
            }
         }
                                       /* Unix domain                  */
      else {
         len = sizeof(from_un);
         if ((g = accept(AipsSocket, &from_un, &len)) < 0) {
            perror ("Accept");
            connected = False;
            }
         else {
            (void) notify_set_input_func(me2, sock_io, g);
            connected = True;
            }
         }
      }

   return (NOTIFY_DONE);
}

int get_socket()
/*--------------------------------------------------------------------*/
/* Get a socket and bind it appropriately, if possible.  The          */
/* environmental variable TVDEV is expanded to find the AIPS TV       */
/* assignment which is in turn expanded to a device name. If the      */
/* device name contains a colon then the portion of the name before   */
/* the colon is taken to be a service name and an INET socket is      */
/* created. If the character before the colon is a 'B' then it is     */
/* omitted from the service name and certain opcodes may be buffered. */
/* If no colon is present the device name is taken to be the name of  */
/* a Unix domain socket.                                              */
/*--------------------------------------------------------------------*/
{
   struct sockaddr_in server_in;
   struct servent     *sp_in;
   char *colon_ptr;

   char device[80];                     /* socket device name         */
   char service[16];                    /* INET service name          */
   char *tptr1, *tptr2;
/*--------------------------------------------------------------------*/
   server_un.sun_family = AF_UNIX;
                                        /* Check that TVDEV is        */
                                        /* defined and that it        */
                                        /* contains the name of an    */
                                        /* environmental variable.    */
   if (getenv("TVDEV") == NULL) {
      perror ("get_socket getenv(\"TVDEV\")");
      return (-1);
      }
   sprintf (device, "%s", getenv(getenv("TVDEV")));
                                               /* TVDEVn is undefined */
   if (strcmp(device, "(NULL)") == 0) {
      perror ("get_socket getenv");
      return (-1);
      }
                                        /* INET domain                */
   if ((colon_ptr = index(device, ':')) != NULL) {
      domain_type = INET_DOMAIN;
      tptr1 = device;
      tptr2 = service;
      while (*tptr1 != ':')
         *(tptr2++) = *(tptr1++);
      *tptr2 = '\0';
      if (*(--tptr2) == 'B') {
         buffered = True;
         *tptr2 = '\0';
         }
      else
         buffered = False;
      if ((sp_in = getservbyname (service, "tcp")) == NULL) {
         perror ("SOCKET.C: %s not a service\n", service);
         return (-1);
         }
      server_in.sin_port = sp_in->s_port;
      if ((AipsSocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
         perror ("get_socket socket (INET)");
         return (-1);
         }
      if (bind(AipsSocket, (caddr_t)&server_in, sizeof(server_in)) < 0){
         perror ("get_socket bind error (INET)");
         return (-1);
         }
      }
                                        /* UNIX domain                */
   else {
      domain_type = UNIX_DOMAIN;
      buffered = False;
      if ((AipsSocket = socket (AF_UNIX, SOCK_STREAM, 0)) < 0) {
         perror ("get_socket socket (UNIX)");
         return (-1);
         }
                                        /* Otherwise, open socket     */
      unlink (device);                  /* first unlink if it exists  */
      strcpy (server_un.sun_path, device);
      if (bind (AipsSocket, &server_un, strlen(server_un.sun_path) + 2)
         < 0) {
         perror ("get_socket bind error (UNIX)");
         return (-1);
         }
      }
                                        /* Queue up to 5 requests.    */
   listen (AipsSocket, 5);

                                        /* Set up the opcodes we want */
                                        /* to buffer. Basically all   */
                                        /* the writes.                */
   if (buffered) {
      bufferop[CLEAR]=True;
      bufferop[VIEW]=True;
      bufferop[IMWRT]=True;
      bufferop[WLUT]=True;
      bufferop[WOFM]=True;
      bufferop[WCURS]=True;
      bufferop[GRAPH]=True;
      bufferop[SPLIT]=True;
      bufferop[WGRFX]=True;
      bufferop[WZOOM]=True;
      bufferop[WSCROL]=True;
      bufferop[WZSCR]=True;
      }

   return (0);
}

int close_socket()
/*--------------------------------------------------------------------*/
/* Close and unlink the socket.                                       */
/*--------------------------------------------------------------------*/
{
   if (shutdown (AipsSocket, 0) < 0) {
      perror ("close_socket shutdown");
      return (-1);
      }
   if (close (AipsSocket) < 0) {
      perror ("close_socket close");
      return (-1);
      }
   if (domain_type == UNIX_DOMAIN)
      if (unlink (server_un.sun_path) < 0) {
         perror ("close_socket unlink");
         return (-1);
         }

   return (0);
}
--XYZZY--
cat > sockxf.c << --XYZZY--
#include "header.h"

Notify_value sock_io(me, fd)
/*--------------------------------------------------------------------*/
/*! (XView XVSS) does IO on socket, reading from client, sending back */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* In a sense this is the programs "main loop". When there is input   */
/* from the client control passes here, the opcode is read, it is     */
/* acted upon, status is passed back to the client and control returns*/
/* to the windows.  We also take care of broken connections in here   */
/* (for now).                                                         */
/*--------------------------------------------------------------------*/
   int *me;
   int fd;
/*--------------------------------------------------------------------*/
{
   short int op;                        /* opcode                     */

   short int status;                    /* status return from         */
                                        /* requested operation        */
   short int nwsd;                      /* number of words of status  */
                                        /* data                       */
/*--------------------------------------------------------------------*/
                                        /* Flaky connection, get      */
                                        /* another.                   */
   if (sock_rcv (&op, dat, &ndata, buf) < 0) {
      shutdown (g, 0);
      close (g);
      connected = False;
      (void) notify_set_input_func (me, NOTIFY_FUNC_NULL, g);
      }
                                        /* Good conn, dispatch        */
                                        /* opcodes.                   */
   else {
      if (op == CLEAR) {
         if (XvssDebug) fprintf (stderr, "CLEAR %d", dat[0]);
         status = screen_clear();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == VIEW) {            /* No-op */
         status = 0;
         nwsd = 0;
         }
      else if (op == IMWRT) {
         status = imwrt();
         nwsd = 0;
         }
      else if (op == IMRD) {
         status = imrd(&nwsd);
         }
      else if (op == WLUT) {
         if (XvssDebug) fprintf (stderr, "WLUT %d", dat[0]);
         status = cmap_wlut();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == RLUT) {
         if (XvssDebug) fprintf (stderr, "RLUT %d", dat[0]);
         status = cmap_rlut();
         nwsd = NColour;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == WOFM) {
         if (XvssDebug) fprintf (stderr, "WOFM %d", dat[0]);
         status = cmap_wofm();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == ROFM) {
         if (XvssDebug) fprintf (stderr, "ROFM %d", dat[0]);
         status = cmap_rofm();
         nwsd = NINTENS;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == GRAPH) {
         if (XvssDebug) fprintf (stderr, "GRAPH %d %d", dat[0], dat[1]);
         status = cmap_graph();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == SPLIT) {
         if (XvssDebug) fprintf (stderr, "SPLIT %d", dat[0]);
         status = cmap_split();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == WGRFX) {
         if (XvssDebug) fprintf (stderr, "WGRFX %d", dat[0]);
         status = cmap_wgrfx();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == RGRFX) {
         if (XvssDebug) fprintf (stderr, "RGRFX %d", dat[0]);
         status = cmap_rgrfx();
         nwsd = 3;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == RCURS) {
         status = cursor_position();
         nwsd = 2;
         }
      else if (op == RBUTT) {
         status = button_status();
         nwsd = 4;
         }
      else if (op == WCURS) {
         if (XvssDebug) fprintf (stderr, "WCURS %d %d",
            dat[0], dat[1]);
         status = cursor_move();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == RCURB) {
         status = cursor_button();
         nwsd = 6;
         }
      else if (op == WZSCR) {
         if (XvssDebug) fprintf (stderr, "ZOOM %d %d %d %d",
            dat[0], dat[1], dat[2], dat[3]);
         status = zoom();
         nwsd = 0;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == WINDO) {
         if (XvssDebug) fprintf (stderr, "WINDO %d %d %d %d",
            dat[0], dat[1], dat[2], dat[3]);
         status = windo_status();
         nwsd = 4;
         if (XvssDebug) fprintf (stderr, " done\n");
         }
      else if (op == INTGT) {
         if (XvssDebug) fprintf (stderr, "Interogate parameters \n");
         status = Interogate (&nwsd);
         }
      else if (op == OPEN) {
         if (XvssDebug) fprintf (stderr, "OPEN \n");
         status = 0;
         nwsd = 0;
         }
      else if (op == CLOSE) {
         if (XvssDebug) fprintf (stderr, "CLOSE now \n");
         shutdown (g, 0);
         close (g);
         connected = False;
         (void) notify_set_input_func (me, NOTIFY_FUNC_NULL, g);
         }
      else {
         if (XvssDebug) fprintf (stderr, "Unknown op %d\n", op);
         status = -1;
         nwsd = 0;
         }

      if (connected) sock_snd (&status, &nwsd, buf_out, &op);
      }

   return (NOTIFY_DONE);
}

int sock_rcv (op, dat, ndata, buffer)
/*--------------------------------------------------------------------*/
/* gets opcode, number of words of data, and the data from the client */
/* (AIPS). The send/receive procedures are so simple that the client  */
/* and server shouldn't (?) be able to get out of sync, although at   */
/* some point I should add an out of band signal or at least a panel  */
/* item to reset the connection.                                      */
/* Outputs:                                                           */
/*    op      I*2      opcode from client                             */
/*    dat     I*2(4)   "always present" data                          */
/*    ndata   I*2      number of words of data                        */
/*    buffer  I(*)     buffer containing variable data, discard excess*/
/*--------------------------------------------------------------------*/
   short int *op, *dat, *ndata;
   unsigned char *buffer;
/*--------------------------------------------------------------------*/
{
   static int size_i2 = sizeof(short int);
   int bytes_togo, bytes_trans, ldata;
   register int i;
   short int lbuf[6], *abuf;
   abuf = lbuf;
/*--------------------------------------------------------------------*/
                                        /* Read op, ndata, buffer in  */
                                        /* that order (hopefully      */
                                        /* buffer is long enough).    */
   if (read (g, abuf, 6*size_i2) < 6*size_i2) {
      return (-1);
      }
   *op = ntohs (lbuf[0]);
   *dat = ntohs (lbuf[1]);
   *(dat+1) = ntohs (lbuf[2]);
   *(dat+2) = ntohs (lbuf[3]);
   *(dat+3) = ntohs (lbuf[4]);
   *ndata = ntohs (lbuf[5]);
                                        /* "Variable length" data is  */
                                        /* in bytes, not words.       */
                                        /* Always read an even number */
                                        /* of bytes.                  */
   bytes_togo = *ndata + (*ndata)%2;
   ldata = bytes_togo;
   while (bytes_togo) {
      bytes_trans = read (g, (buffer+(ldata - bytes_togo)), bytes_togo);
      if (bytes_trans <= 0) {
         perror ("sock_recv 4 read");
         return (-1);
         }
      bytes_togo -= bytes_trans;
      }

/*   for (i = 0; i < ldata / 2; i++)                 WRONG it is char */
/*      buffer[i] = ntohs (buffer[i]);                                */

   return (0);
}

int sock_snd (istat, ndata, buffer, op)
/*--------------------------------------------------------------------*/
/* the obverse of sock_rcv.  It sends the status and ndata words of   */
/* status data in buffer to the client.                               */
/* Input:                                                             */
/*    istat  I*2      status, to be returned to client (or print if    */
/*                    buffered op)                                    */
/*    ndata  I*2      number of words of data                         */
/*    buffer I*2(*)   buffer containing data.                         */
/*    op     I*2      the opcode that generated this send, needed to  */
/*                    see if this is a buffered opcode or not.        */
/*--------------------------------------------------------------------*/
   short int *istat, *ndata, *buffer, *op;
/*--------------------------------------------------------------------*/
{
   register int i, j;
   static int size_i2 = sizeof(short int);
   static short int packet[4096+2];
/*--------------------------------------------------------------------*/
                                        /* Send return, unbuffered op */
   if (!bufferop[*op]) {
      packet[0] = htons (*istat);
      packet[1] = htons (*ndata);
      i = 2; j = 0;
      while (j < *ndata)
      packet[i++] = htons (buffer[j++]);
      if (write(g, packet, ((*ndata+2)*size_i2))
         < ((*ndata+2)*size_i2)) {
         perror ("sock_snd: write");
         return (-1);
         }
      }
   else {
      if (*istat != 0){
         fprintf (stderr, "Buffered op %d, istat=%d\n", *op, *istat);
         }
      }

   return (0);
}
--XYZZY--
cat > window.c << --XYZZY--
#include "header.h"
#include <math.h>

void window_start (argc, argv)
/*--------------------------------------------------------------------*/
/*! (XView XVSS) establishes AIPS TV window, watch points, starts it  */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This subroutine starts up the XVSS window, and sets up the         */
/* notifier so that it handles I/O properly.                          */
/*--------------------------------------------------------------------*/
   int argc;
   char *argv[];
/*--------------------------------------------------------------------*/
{
   static int my_client_object;         /* these 2 lines make a       */
   static int *me = &my_client_object;  /* unique handle              */

   struct itimerval accept_timer;       /* interval at which to look  */
                                        /* for clients                */

   Panel panel;                         /* XView control panel        */

   XVisualInfo template;                /* type of visual XVSS uses   */
   XVisualInfo *vislist;                /* list of visuals matching   */
                                        /* the template               */
   int nvis;                            /* number of visuals in list  */

   XGCValues gc_values;                 /* X11 graphics context       */
                                        /* template                   */

   Window colourmap_list[3];            /* list of sub-windows that   */
                                        /* need colormaps installed   */
                                        /* by the window manager      */

   unsigned long base_pixel;            /* base colour ('or'd with    */
                                        /* image)                     */
   unsigned long plane_masks[15];       /* plane masks from XAlloc-   */
                                        /* Colorcells.                */

   char *graph_colour_str;              /* Colour of graphics (as a   */
                                        /* string) */
   Xv_singlecolor fore, back;           /* Frame fore & back colours  */
   void crscol();

   int mjr, mnr, pixmaps;               /* Dummy variables for SHM    */


   Icon icon;                           /* AIPS TV icon               */
   Server_image icon_server_image;
   static short icon_image[] =          /* icon data                  */
   {
#include "aips.icon"
   };

   register int i, j;
   int temp, itx, ity, icx, icy;
   double xx, yy, zz;

   int tscreen_num, tx, ty;             /* parameters to get root win */
   unsigned int tborder_width, tdepth;
   Window troot;

   Notify_value get_client();
/*--------------------------------------------------------------------*/
                                       /* Initialise XView:           */
   (void) xv_init(XV_INIT_ARGC_PTR_ARGV, &argc, argv, 0);

   using_shm = False;

                                       /* Create the icon:            */
   icon_server_image =
     (Server_image)xv_create (NULL, SERVER_IMAGE,
                              XV_HEIGHT, ICON_DEFAULT_HEIGHT,
                              XV_WIDTH, ICON_DEFAULT_WIDTH,
                              SERVER_IMAGE_BITS, icon_image,
                              NULL);

   icon = (Icon)xv_create (NULL, ICON,
                           ICON_IMAGE, icon_server_image,
                           XV_LABEL, "AIPS TV",
                           NULL);

                                        /* Create the base window:    */
                                        /* Redefine the frame fore-   */
                                        /* and background colours.    */
   back.red   = 175;
   back.green = 127;
   back.blue  = 175;
   fore.red   = 0;
   fore.green = 0;
   fore.blue  = 0;
   frame = (Frame) xv_create (NULL, FRAME,
                              FRAME_ICON, icon,
                              XV_LABEL, "AIPS TV",
                              XV_HEIGHT, 512,
                              XV_WIDTH, 512,
                              XV_VISUAL_CLASS, PseudoColor,
                              FRAME_BACKGROUND_COLOR, &back,
                              FRAME_FOREGROUND_COLOR, &fore,
                              FRAME_INHERIT_COLORS, True,
                              XV_HELP_DATA, "xvss.frame",
                              WIN_ERROR_MSG,
                              "window_start: can't create frame",
                              NULL);

                                        /* Create the control panel:   */
   panel = (Panel)xv_create (frame, PANEL,
                             XV_HELP_DATA, "xvss:panel",
                             NULL);

   (void) xv_create (panel, PANEL_BUTTON,
                     PANEL_NOTIFY_PROC, resize_pressed,
                     PANEL_LABEL_STRING, "Resize",
                     XV_HELP_DATA, "xvss:resize",
                     NULL);

   (void) xv_create (panel, PANEL_BUTTON,
                     PANEL_NOTIFY_PROC, button_a_pressed,
                     PANEL_LABEL_STRING, "A",
                     XV_HELP_DATA, "xvss:buttonA",
                     NULL);

   (void) xv_create (panel, PANEL_BUTTON,
                     PANEL_NOTIFY_PROC, button_b_pressed,
                     PANEL_LABEL_STRING, "B",
                     XV_HELP_DATA, "xvss:buttonB",
                     NULL);

   (void) xv_create (panel, PANEL_BUTTON,
                     PANEL_NOTIFY_PROC, button_c_pressed,
                     PANEL_LABEL_STRING, "C",
                     XV_HELP_DATA, "xvss:buttonC",
                     NULL);

   (void) xv_create (panel, PANEL_BUTTON,
                     PANEL_NOTIFY_PROC, button_d_pressed,
                     PANEL_LABEL_STRING, "D",
                     XV_HELP_DATA, "xvss:buttonD",
                     NULL);

   xv_set (panel, WIN_FIT_HEIGHT, 1, NULL);
   panel_ht = (int) xv_get (panel, XV_HEIGHT);


                                        /* channel 1 on, graphics off */
   cur_chan = 1;
   rwgraph = 0;

   Screen_Height = 770;                 /* temporary value used on    */
   Screen_Width = 1024;                 /* repaint caused by create   */
   Screen_Xmarg = 2;                    /* canvas below               */
   Screen_Ymarg = 2;
                                        /* Create the canvas:         */
   canvas =
     (Canvas)xv_create (frame, CANVAS,
                        CANVAS_RETAINED, False,
                        CANVAS_REPAINT_PROC, repaint_canvas,
                        CANVAS_RESIZE_PROC, resize_canvas,
                        CANVAS_FIXED_IMAGE, False,
                        CANVAS_X_PAINT_WINDOW, True,
                        WIN_DYNAMIC_VISUAL, True,
                        WIN_ERROR_MSG, "window_start: can't create canvas",
                        NULL);

                                        /* Get the display structure   */
                                        /* and the X window ID of the  */
                                        /* canvas (needed for Xlib):   */
   display = (Display *) xv_get (canvas, XV_DISPLAY);
   window = (Window) xv_get (canvas_paint_window(canvas), XV_XID);

                                       /* get sizes                    */
   tscreen_num=0;
   if (XGetGeometry (display, RootWindow(display, tscreen_num), &troot,
      &tx, &ty, &twidth, &theight, &tborder_width, &tdepth) == False) {
      fprintf (stderr,"can't get root window geometry\n");
      twidth = Screen_Width + SCREEN_LEFT + SCREEN_RIGHT + Screen_Xmarg; 
      theight = Screen_Height + SCREEN_TOP + SCREEN_BOTTOM
         + Screen_Ymarg + panel_ht;
      }

#ifdef USE_SHM
                                       /* Find out whether the shared  */
                                       /* memory extension is          */
                                       /* available:                   */
   using_shm = XShmQueryVersion (display, &mjr, &mnr, &pixmaps);

                                       /* Find out whether the user    */
                                       /* Wants to use shared memory:  */

   using_shm = defaults_get_boolean ("XVSS.useSharedMemory",
                                     "XVSS.UseSharedMemory", False);

                                       /* Let the user know if shared   */
                                       /* memory is in use:             */
   if (using_shm) {
      xv_set (frame,
              FRAME_SHOW_FOOTER, True,
              FRAME_RIGHT_FOOTER, "Shared memory in use",
              NULL);
   } else {
      xv_set (frame,
              FRAME_SHOW_FOOTER, True,
              FRAME_RIGHT_FOOTER, "No shared memory in use",
              NULL);
   }
#endif


                                       /* Set up event handling for    */
                                       /* the canvas paint window:      */
   xv_set (canvas_paint_window(canvas),
           WIN_EVENT_PROC, handle_events,
           NULL);

                                       /* Add events for "dragging" to */
                                       /* follow the cursor:           */
   xv_set (canvas_paint_window(canvas),
           WIN_CONSUME_EVENTS, LOC_DRAG, ACTION_SELECT, 0,
           NULL);

                                       /* Add events for function key  */
                                       /* buttons as well (F3,4,5,6):  */
   xv_set (canvas_paint_window(canvas),
           WIN_CONSUME_EVENTS, KEY_TOP(2), KEY_TOP(3), KEY_TOP(4),
           KEY_TOP(5), KEY_TOP(6), KEY_TOP(7), KEY_TOP(8), 0,
           NULL);

                                       /* Respond to requests for help: */
   xv_set (canvas_paint_window(canvas),
           WIN_CONSUME_EVENTS, ACTION_HELP, 0, NULL);

                                        /* Find the visual we are      */
                                        /* going to use (assume it is  */
                                        /* the first PseudoColor       */
                                        /* visual which matches the    */
                                        /* window depth):              */
   depth = (int) xv_get (canvas, WIN_DEPTH);
   template.screen = DefaultScreen(display);
   template.depth = depth;
   template.class = PseudoColor;
   NValue = 1 << depth-1;
   NColour = NValue - (1 << NGRAPH);
   vislist = XGetVisualInfo (display, VisualScreenMask|VisualDepthMask|
                             VisualClassMask, &template, &nvis);
 
   if (nvis == 0) {
      perror ("No suitable visual");
      exit (1);
      }
                                        /* Define default cursor and  */
                                        /* graphics colours.          */
   user_options (argc, argv);
 
                                        /* get margins, full size     */
   itx = (int) xv_get(canvas, CANVAS_WIDTH);
   ity = (int) xv_get(canvas, CANVAS_HEIGHT);
   icx = (int) xv_get(frame, XV_WIDTH);
   icy = (int) xv_get(frame, XV_HEIGHT);
   Screen_Xmarg = icx - itx;
   Screen_Ymarg = icy - ity - panel_ht;
   Screen_Width = twidth - SCREEN_LEFT - SCREEN_RIGHT - Screen_Xmarg;
   Screen_Height = theight - SCREEN_TOP - SCREEN_BOTTOM - Screen_Ymarg
      - panel_ht;
   Screen_Width = (Screen_Width / 2) * 2;
   Screen_Height = (Screen_Height / 2) * 2;
   itx = NColour - 1;
   fprintf (stderr,"Using screen width height %d %d,",
      Screen_Width, Screen_Height);
   fprintf (stderr,"  max grey level %d,\n", itx);

                                       /* Create image planes:        */
#ifdef USE_SHM
   if (using_shm) {
      for (i = 0; i < NGREY; i++) {
         plane[i] = XShmCreateImage (display, vislist->visual, depth,
                                     ZPixmap, NULL, &plane_info[i],
                                     Screen_Width, Screen_Height);
         if ( (plane_info[i].shmid = shmget (IPC_PRIVATE,
                                            (plane[i]->bytes_per_line *
                                              plane[i]->height),
                                             IPC_CREAT|0777)) == -1 ) {
             perror ("Shared memory id failure");
             exit (1);
         }
         plane_info[i].shmaddr = plane[i]->data = plane_data[i] =
            shmat (plane_info[i].shmid, NULL, 0);
         plane_info[i].readOnly = False;
         if ( XShmAttach (display, &plane_info[i]) == False ) {
            perror ("Shared memory attach failed");
            exit (1);
         }
      }
      graph = XShmCreateImage (display, vislist->visual, depth,
                               ZPixmap, NULL, &graph_info,
                               Screen_Width, Screen_Height);
      if ( (graph_info.shmid = shmget (IPC_PRIVATE,
                                       (graph->bytes_per_line *
                                        graph->height),
                                       IPC_CREAT|0777)) == -1 ) {
          perror ("Shared memory id failure");
          exit (1);
      }
      graph_info.shmaddr = graph->data = graph_data =
         shmat (graph_info.shmid, NULL, 0);
      graph_info.readOnly = False;
      if ( XShmAttach (display, &graph_info) == False ) {
         perror ("Shared memory attach failed");
         exit (1);
      }
      line = XShmCreateImage (display, vislist->visual, depth,
                              ZPixmap, NULL, &line_info,
                              Screen_Width, ZOOM_LIMIT);
      if ( (line_info.shmid = shmget (IPC_PRIVATE,
                                      (line->bytes_per_line *
                                       line->height),
                                      IPC_CREAT|0777)) == -1 ) {
          perror ("Shared memory id failure");
          exit (1);
         }
      line_info.shmaddr = line->data = line_data =
         shmat (line_info.shmid, NULL, 0);
      line_info.readOnly = False;
      if ( XShmAttach (display, &line_info) == False ) {
         perror ("Shared memory attach failed");
         exit (1);
         }
      line_info.readOnly = False;
      }
   else {
#endif  /* USE_SHM */
      for (i = 0; i < NGREY; i++) {
         plane_data[i] = (unsigned char*) malloc
            ((Screen_Width * Screen_Height * depth +7) / 8);
         plane[i] = XCreateImage (display, vislist->visual, depth,
            ZPixmap, 0, plane_data[i], Screen_Width, Screen_Height,
            8, 0);
         }
      graph_data = (unsigned char*) malloc(Screen_Width * Screen_Height *
                                           ((depth+1)/8));
      graph = XCreateImage (display, vislist->visual, depth,
                            ZPixmap, 0, graph_data,
                            Screen_Width, Screen_Height, 8, 0);
      line_data = (unsigned char*) malloc(Screen_Width * ZOOM_LIMIT *
                                          ((depth+1)/8));
      line = XCreateImage (display, vislist->visual, depth,
                           ZPixmap, 0, line_data,
                           Screen_Width, ZOOM_LIMIT, 8, 0);
#ifdef USE_SHM
    }
#endif

                                       /* Allocate space for the       */
                                       /* colour table:                */
   if ((colour_table =
      (XColor *)malloc(vislist->colormap_size * sizeof(XColor))) == NULL)
      perror ("Can not allocate space for colour table");

   for (i = 0; i < vislist->colormap_size; i++) {
      colour_table[i].pixel = i;
      colour_table[i].flags = DoRed | DoGreen | DoBlue;
      }
                                       /* Attempt to allocate colours  */
                                       /* from default colourmap (note */
                                       /* that we require contiguous   */
                                       /* planes beginning at plane 1):*/
   TV_colour = DefaultColormap (display, DefaultScreen(display));
   if (XAllocColorCells (display, TV_colour, True, plane_masks,
                         depth-1, &base_pixel, 1L) == 0 ||
       plane_masks[0] != 1) {
                                       /* Attempt failed --- create a  */
                                       /* new (virtual) colour map and */
                                       /* install it as the colour map */
                                       /* for the AIPS TV:             */
      fprintf (stderr, "XVSS: WARNING -- creating virtual colormap\n");
      TV_colour = XCreateColormap (display, xv_get(canvas, XV_XID),
                                 vislist->visual, AllocAll);

                                       /* Copy colours from default   */
                                       /* colourmap to virtual        */
                                       /* colourmap (retains as much  */
                                       /* of the rest of the screen   */
                                       /* as possible):               */
      XQueryColors (display,
                    DefaultColormap(display, DefaultScreen(display)),
                    colour_table, vislist->colormap_size);
      XStoreColors (display, TV_colour, colour_table,
                    vislist->colormap_size);

                                       /* If there may be colours of */
                                       /* interest at the bottom of  */
                                       /* the colormap, use higher   */
                                       /* entries:                   */
      if (WhitePixel(display, DefaultScreen(display)) < NValue)
         base_pixel = NValue;
      else
         base_pixel = 0;

                                       /* Install the colourmap and  */
                                       /* let the window manager     */
                                       /* know that we want our own  */
                                       /* colour map on the canvas   */
                                       /* and the default colour map */
                                       /* on the button panel:       */
      XSetWindowColormap (display, xv_get(canvas, XV_XID), TV_colour);
      colourmap_list[0] = (Window) xv_get(canvas, XV_XID);
      colourmap_list[1] = (Window) xv_get(panel, XV_XID);
      colourmap_list[2] = (Window) xv_get(frame, XV_XID);
      XSetWMColormapWindows (display, xv_get(frame, XV_XID),
                             colourmap_list, 3);
      }
   if (XDebug) {
      itx = WhitePixel(display, DefaultScreen(display));
      ity = BlackPixel(display, DefaultScreen(display));
      fprintf (stderr, "base_pixel = %d %d %d\n", base_pixel, itx, ity);
      }
                                       /* Set graphics contexts: pix   */
   gc_values.function = GXcopy;
   gc_values.plane_mask = NValue-1;
   ImageGC = XCreateGC (display, window, GCFunction | GCPlaneMask,
      &gc_values);
                                       /* Set graphics contexts: base  */
   gc_values.plane_mask = AllPlanes;
   gc_values.foreground = base_pixel;
   BasicGC = XCreateGC (display, window,
      GCFunction | GCPlaneMask | GCForeground, &gc_values);

                                        /* Start up the window with a */
                                        /* linear transfer function:  */

                                        /* set OFM, Gamma = 2.2       */
   yy = NINTENS - 1;
   zz = 1.0 / 2.2;
   for (i = 0; i < NINTENS; i++) {
      xx = i / yy;
      rofm[i] = gofm[i] = bofm[i] = yy * pow (xx, zz);
      }

                                        /* lut is linear              */
   if (XDebug) fprintf (stderr, "base_pixel = %d\n", base_pixel);
   zz = NColour - 1;
   zz = yy / zz;
   for (i = 0; i < NValue; i++) {
      colour_table[i].pixel = base_pixel + i;
      colour_table[i].flags = DoRed | DoGreen | DoBlue;
      if (i < NColour) {
         rlut[0][i] = glut[0][i] = blut[0][i] =  i * zz;
         if (NGREY > 1) {
            for (j = 1; j < NGREY; j++) 
               rlut[j][i] = glut[j][i] = blut[j][i] = rlut[0][i];
            }
         colour_table[i].red = colour_table[i].green =
           colour_table[i].blue = rofm[rlut[0][i]] << COLORSHIFT;
         }
      else {
         colour_table[i].red = rgcol[i-NColour] << COLORSHIFT;
         colour_table[i].blue = bgcol[i-NColour] << COLORSHIFT;
         colour_table[i].green = ggcol[i-NColour] << COLORSHIFT;
         }
      }
   XStoreColors (display, TV_colour, colour_table, NValue);

/*   cursfg.red = rgcol[15];
   cursfg.green = ggcol[15];
   cursfg.blue = bgcol[15];
   cursbg.red = 0;
   cursbg.green = 0;
   cursbg.blue = 0;
   cursor = xv_create (NULL, CURSOR, CURSOR_SRC_CHAR, OLC_BASIC_PTR,
      CURSOR_MASK_CHAR, OLC_BASIC_MASK_PTR, 
      CURSOR_BACKGROUND_COLOR, &cursbg,
      CURSOR_FOREGROUND_COLOR, &cursfg, NULL);
   xv_set (xv_get(canvas, CANVAS_NTH_PAINT_WINDOW, 0),
      WIN_CURSOR, cursor, NULL);
   cfg0 = cursfg;
   cbg0 = cursbg; */
                                        /* create cursor for window   */
   cursor = XCreateFontCursor (display, cursor_shape);
   XDefineCursor (display, window, cursor);
                                        /* color the cursor           */
   fg_curs.red = rgcol[15] << COLORSHIFT;
   fg_curs.green = ggcol[15] << COLORSHIFT;
   fg_curs.blue = bgcol[15] << COLORSHIFT;
   bg_curs.red = 0;
   bg_curs.green = 0;
   bg_curs.blue = 0;
   fg_curs.flags = DoRed | DoGreen | DoBlue;
   bg_curs.flags = DoRed | DoGreen | DoBlue;
   fg_curs.pixel = NColour + 15 + base_pixel;
   bg_curs.pixel = base_pixel;
   XRecolorCursor (display, cursor, &fg_curs, &bg_curs);

                                        /* Set up the timer for       */
                                        /* accept connections:        */
   accept_timer.it_interval.tv_usec = 500000;
   accept_timer.it_interval.tv_sec = 0;
   accept_timer.it_value.tv_sec = 0;
   accept_timer.it_value.tv_usec = 500000;

   (void) notify_set_itimer_func (me, get_client, ITIMER_REAL,
      &accept_timer, ITIMER_NULL);

   redo_hibit = True;

                                         /* set window size, location  */
   big_screen = False;
   itx = cur_xsize = 518 + Screen_Xmarg;
   ity = cur_ysize = 518 + Screen_Ymarg + panel_ht;
   icx = cur_xcorn = 0;
   icy = cur_ycorn = 0;
   if (icx < SCREEN_LEFT) icx = SCREEN_LEFT;
   if (icy < SCREEN_TOP) icy = SCREEN_TOP;
   if (icx + itx >= twidth - SCREEN_RIGHT)
      icx = twidth - SCREEN_RIGHT - itx;
   if (icy + ity >= theight - SCREEN_BOTTOM)
      icy = theight - SCREEN_BOTTOM - ity;
   xv_set (frame, XV_WIDTH, itx, XV_HEIGHT, ity, WIN_X, icx,
      WIN_Y, icy, NULL);

   sc_centre_x = Screen_Width / 2 - 1;       /* initial settings            */
   sc_centre_y = Screen_Height / 2 - 1;
   for (i = 0; i < NGREY; i++) {
      upleft_x[i] = 0;
      upleft_y[i] = 0;
      }
   upleft_mag = 1;
                                        /* set widths                 */
   sc_width = itx -  Screen_Xmarg;
   sc_height = ity -  Screen_Ymarg - panel_ht;
   if (sc_width > Screen_Width) sc_width = Screen_Width;
   if (sc_height > Screen_Height) sc_height = Screen_Height;
   sc_width2 = sc_width / 2;
   sc_height2 = sc_height / 2;

   xv_main_loop (frame);

                                         /* Program has been terminated */
                                         /* for some reason -- clean up */
                                         /* shared memory (if any) and  */
                                         /* close socket cleanly.       */
   if (XDebug) fprintf (stderr, "XVSS terminates - Good-bye\n");
#ifdef USE_SHM
   if (using_shm) {
       for ( i = 0; i < NGREY; i++ ) {
           XShmDetach (display, plane_info[i]);
           XDestroyImage (plane[i]);
           shmdt (plane_info[i].shmaddr);
           shmctl (plane_info[i].shmid, IPC_RMID, 0);
       }
       XShmDetach (display, graph_info);
       XDestroyImage (graph);
       shmdt (graph_info.shmaddr);
       shmctl (graph_info.shmid, IPC_RMID, 0);
       XShmDetach (display, line_info);
       XDestroyImage (line);
       shmdt (line_info.shmaddr);
       shmctl (line_info.shmid, IPC_RMID, 0);
       }
#endif
   close_socket();
}
user_options (argc, argv)
int argc;
char *argv[];
/*--------------------------------------------------------------------*/
/*   Set cursor, graphics colors reading user's .Xdefaults file       */
/*   Also get the icon and window geometries from the command line or */
/*   from the .Xdefaults file.
/*--------------------------------------------------------------------*/
{
   char *option;
   char *BasicTV = "AIPStv";
   int i;
/*--------------------------------------------------------------------*/
   ProgName = argv[0];
                                        /* ONLY from .Xdefaults       */
                                        /* cursor shape               */
                                        /* 34 => XC_crosshair         */
   option = XGetDefault (display, BasicTV, "cursorShape");
   i = option ? atoi (option) : -1;
   cursor_shape = ((i >= 0) && (i <= 154)) ? i : 34;
   cursor_shape = (cursor_shape / 2) * 2;
                                        /* cursor colours             */
   option = XGetDefault (display, BasicTV, "cursorR");
   i = option ? atoi (option) : -1;
   rgrfx[0] = ((i >= 0) && (i <= 255)) ? i : 255;
   option = XGetDefault (display, BasicTV, "cursorG");
   i = option ? atoi (option) : -1;
   ggrfx[0] = ((i >= 0) && (i <= 255)) ? i : 0;
   option = XGetDefault (display, BasicTV, "cursorB");
   i = option ? atoi (option) : -1;
   bgrfx[0] = ((i >= 0) && (i <= 255)) ? i : 255;
                                        /* graphics colours           */
   option = XGetDefault (display, BasicTV, "graphics1R");
   i = option ? atoi (option) : -1;
   rgrfx[1] = ((i >= 0) && (i <= 255)) ? i : 255;
   option = XGetDefault (display, BasicTV, "graphics1G");
   i = option ? atoi (option) : -1;
   ggrfx[1] = ((i >= 0) && (i <= 255)) ? i : 255;
   option = XGetDefault (display, BasicTV, "graphics1B");
   i = option ? atoi (option) : -1;
   bgrfx[1] = ((i >= 0) && (i <= 255)) ? i : 0;
   option = XGetDefault (display, BasicTV, "graphics2R");
   i = option ? atoi (option) : -1;
   rgrfx[2] = ((i >= 0) && (i <= 255)) ? i : 16;
   option = XGetDefault (display, BasicTV, "graphics2G");
   i = option ? atoi (option) : -1;
   ggrfx[2] = ((i >= 0) && (i <= 255)) ? i : 255;
   option = XGetDefault (display, BasicTV, "graphics2B");
   i = option ? atoi (option) : -1;
   bgrfx[2] = ((i >= 0) && (i <= 255)) ? i : 0;
   option = XGetDefault (display, BasicTV, "graphics3R");
   i = option ? atoi (option) : -1;
   rgrfx[3] = ((i >= 0) && (i <= 255)) ? i : 255;
   option = XGetDefault (display, BasicTV, "graphics3G");
   i = option ? atoi (option) : -1;
   ggrfx[3] = ((i >= 0) && (i <= 255)) ? i : 171;
   option = XGetDefault (display, BasicTV, "graphics3B");
   i = option ? atoi (option) : -1;
   bgrfx[3] = ((i >= 0) && (i <= 255)) ? i : 255;
   option = XGetDefault (display, BasicTV, "graphics4R");
   i = option ? atoi (option) : -1;
   rgrfx[4] = ((i >= 0) && (i <= 63)) ? i : 0;
   option = XGetDefault (display, BasicTV, "graphics4G");
   i = option ? atoi (option) : -1;
   ggrfx[4] = ((i >= 0) && (i <= 63)) ? i : 0;
   option = XGetDefault (display, BasicTV, "graphics4B");
   i = option ? atoi (option) : -1;
   bgrfx[4] = ((i >= 0) && (i <= 63)) ? i : 0;
                                        /* make cross colors          */
   crscol (rgrfx, rgcol);
   crscol (ggrfx, ggcol);
   crscol (bgrfx, bgcol);

} /* end user_options */
--XYZZY--
cat > xvss.c << --XYZZY--
#include <stdio.h>
#include "header.h"

main (argc, argv)
/*--------------------------------------------------------------------*/
/*! XView Screen Server main program: get socket, call window_start   */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995                                               */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/*   Main program, gets the socket and calls the window               */
/*   initialization routine.  Also sets initial values of some        */
/*   global variables.                                                */
/*--------------------------------------------------------------------*/
int argc;
char **argv;
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   buf_out = (short int *) buf;
                                              /* Default, buffer none */
   for (i = 0; i < (NUMOP+1); i++)
      bufferop[i] = False;
                                               /* get a socket to use */
   if (get_socket() != 0) {
      close_socket();
      exit (-1);
      }
   connected = False;
   XvssDebug = False;
   XDebug = False;

   window_start (argc, argv);
}
--XYZZY--
