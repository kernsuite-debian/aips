#! /bin/sh
#------------------------------------------------
# This is an AIPS self-unpacking shell archive
# created on Thu Aug 16 16:59:50 MDT 1990.
#------------------------------------------------
#  SunView Screen Server.
#-----------------------------------------------
cat > Makefile << --XYZZY--
# MAKEFILE
#-----------------------------------------------------------------------
#! Make AIPS SunView Screen Server (SSS)
## Makefile
#-----------------------------------------------------------------------
#;  Copyright (C) 1995
#;  Associated Universities, Inc. Washington DC, USA.
#;
#;  This program is free software; you can redistribute it and/or
#;  modify it under the terms of the GNU General Public License as
#;  published by the Free Software Foundation; either version 2 of
#;  the License, or (at your option) any later version.
#;
#;  This program is distributed in the hope that it will be useful,
#;  but WITHOUT ANY WARRANTY; without even the implied warranty of
#;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#;  GNU General Public License for more details.
#;
#;  You should have received a copy of the GNU General Public
#;  License along with this program; if not, write to the Free
#;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
#;  MA 02139, USA.
#;
#;  Correspondence concerning AIPS should be addressed as follows:
#;         Internet email: aipsmail@nrao.edu.
#;         Postal address: AIPS Project Office
#;                         National Radio Astronomy Observatory
#;                         520 Edgemont Road
#;                         Charlottesville, VA 22903-2475 USA
#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
#   The following variables should be set appropriately for your system.
#   See the AIPS Memo 'An Overview of the AIPS TV Servers' for examples.

#   DESTDIR is the directory in which XVSS will be installed (this
#   should be the same as $LOAD on machines which are running AIPS)
DESTDIR = $(LOAD)

#    Add local compiler/linker options here.  For example Sun 3s
#    will require a -f option to specify the floating point
#    hardware option.
# LOCALOPTS = -g
LOCALOPTS =

# Do not edit anything below this line
#######################################################

.c.o :
	$(CC) $(CCOPTS) $<

CCOPTS = $(LOCALOPTS) -c

OBJECTS = colmap.o cursor.o imgio.o scrwrt.o socket.o sockxf.o \
          window.o sss.o

all : $(DESTDIR)/SSS

$(DESTDIR)/SSS : sss
	mv sss $(DESTDIR)/SSS

sss : $(OBJECTS)
	$(CC) $(LOCALOPTS) $(OBJECTS) -lsuntool -lsunwindow -lpixrect \
        -lm  -o sss

sss.o : sss.c header.h

window.o : window.c header.h aips.icon

socket.o : socket.c header.h

sockxf.o : sockxf.c header.h

colmap.o : colmap.c header.h

imgio.o : imgio.c header.h

cursor.o : cursor.c header.h

scrwrt.o : scrwrt.c header.h
--XYZZY--
cat > aips.icon << --XYZZY--
/*--------------------------------------------------------------------*/
/*! Icon of AIPS Sun Screen Server (SUNView version)                  */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
 *              This icon courtesy Edwin Zukowski
 */
	0x0000,0x0102,0x0800,0x0000,0x0000,0x2182,0x0800,0x0000,
	0x0000,0x3165,0x1810,0x0000,0x0008,0x2915,0x1470,0x0000,
	0x0004,0x2498,0xA590,0x4000,0x0007,0x2688,0xC723,0x8000,
	0x0005,0x1180,0x042C,0x8000,0x0104,0xD01F,0xF071,0x0200,
	0x00C2,0x31E0,0x0F01,0x1C00,0x0072,0x0600,0x00C6,0x6400,
	0x004A,0x1800,0x0033,0x8800,0x0044,0x2000,0x0008,0x1000,
	0x0F20,0x4000,0x0004,0x1010,0x0491,0x8000,0x0003,0x27E0,
	0x0272,0x0000,0x0003,0x3C40,0x0102,0x0000,0x000C,0x0080,
	0x0104,0x0000,0x0073,0xE100,0x3C88,0x0000,0x0387,0xF23C,
	0x13D0,0x0000,0x0C0F,0xF3C8,0x0810,0x0000,0x701E,0x0010,
	0x0420,0x0001,0x801C,0x0060,0x0320,0x000E,0x3E1C,0x00C0,
	0x0F40,0x0071,0xFF9C,0x0038,0x7040,0x0183,0xF78F,0xF006,
	0x1840,0x0E03,0xC3CF,0xF818,0x0440,0x30E1,0xC1C7,0xFCE0,
	0x0E81,0xC0E1,0xC1C0,0x1C40,0x308E,0x00F1,0xC1C0,0x1C30,
	0xC0B0,0xE070,0xE384,0x3C08,0x30C0,0xF070,0xFF8F,0xF806,
	0x0E01,0xF078,0xFF07,0xF0F8,0x3001,0xF838,0x7C03,0xC640,
	0xC001,0x9C3C,0x7000,0x1A30,0x3003,0x9E1C,0x7000,0xE208,
	0x0E03,0x8E1C,0x3807,0x02F8,0x1803,0x0F1E,0x3818,0x0484,
	0x6007,0x1F8E,0x38E0,0x0460,0xC007,0x7F8E,0x0300,0x0410,
	0x3E07,0xF3CE,0x1C00,0x0410,0x0407,0xC1C0,0xE000,0x0008,
	0x080F,0x01C3,0x0000,0x09FC,0x300E,0x001C,0x0000,0x1100,
	0x600C,0x0060,0x0000,0x1080,0x1F9C,0x0380,0x0000,0x2040,
	0x011C,0x1C00,0x0000,0x4020,0x0200,0x6000,0x0000,0x9E20,
	0x0401,0x8000,0x0000,0x89F0,0x0830,0x8000,0x0003,0x0400,
	0x09E0,0x4000,0x0004,0x0200,0x1E20,0x2000,0x0008,0x7200,
	0x0022,0x1800,0x0030,0x4900,0x004E,0x0600,0x00C0,0x4780,
	0x005A,0x21E0,0x0F0E,0x2000,0x00E4,0x601F,0xF009,0x2000,
	0x00C4,0xA100,0x00C4,0x9000,0x0089,0x2318,0x8CA4,0x4800,
	0x000A,0x2518,0xCC92,0x3800,0x000C,0x4528,0xAA8A,0x0000,
	0x0008,0x4925,0x2986,0x0000,0x0000,0x50A5,0x2881,0x0000,
	0x0000,0x60A2,0x1080,0x0000,0x0000,0x40C2,0x1000,0x0000,
	0x0000,0x0082,0x1000,0x0000,0x0000,0x0000,0x0000,0x0000
--XYZZY--
cat > colmap.c << --XYZZY--
#include "header.h"

cmap_wlut()
/*--------------------------------------------------------------------*/
/*! Set look up tables ("color maps") (SUNView version)               */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/*   Write the NCOLOUR LookUpTable into memory and to colormap        */
/*--------------------------------------------------------------------*/
{
   int i, j;
/*--------------------------------------------------------------------*/
   j = dat[3] - 1;
   if ((dat[3] < 1) || (dat[3] > NGREY)) {
      fprintf (stderr, "Illegal grey channel %d\n", dat[3]);
      return (-1);
      }
   else {
      if (dat[0] != 0)
         for (i = 0; i < NCOLOUR; ++i)
            rlut[j][i] = buf[i];
      if (dat[1] != 0)
         for (i = 0; i < NCOLOUR; ++i)
            glut[j][i] = buf[i];
      if (dat[2] != 0)
         for (i = 0; i < NCOLOUR; ++i)
            blut[j][i] = buf[i];
      return (dat[3] == cur_chan ? cmap_change() : 0);
      }
}

cmap_rlut()
/*--------------------------------------------------------------------*/
/*   Read the NCOLOUR LookUpTable from  memory                        */
/*--------------------------------------------------------------------*/
{
   int i, j;
/*--------------------------------------------------------------------*/
   j = dat[3] - 1;
   if ((dat[3] < 1) || (dat[3] > NGREY)) {
      fprintf (stderr, "Illegal grey channel %d\n", dat[3]);
      return (-1);
      }
   else {
      if (dat[0] != 0)
         for (i = 0; i < NCOLOUR; ++i)
            buf_out[i] = rlut[j][i];
      if (dat[1] != 0)
         for (i = 0; i < NCOLOUR; ++i)
            buf_out[i] = glut[j][i];
      if (dat[2] != 0)
         for (i = 0; i < NCOLOUR; ++i)
            buf_out[i] = blut[j][i];
      return (0);
      }
}

cmap_wofm()
/*--------------------------------------------------------------------*/
/*   Write the NINTENS OutputFunction into memory and to colormap     */
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   if (dat[0] != 0)
      for (i = 0; i < NINTENS; ++i)
         rofm[i] = buf[i];
   if (dat[1] != 0)
      for (i = 0; i < NINTENS; ++i)
         gofm[i] = buf[i];
   if (dat[2] != 0)
      for (i = 0; i < NINTENS; ++i)
         bofm[i] = buf[i];

   return (cmap_change());
}

cmap_rofm()
/*--------------------------------------------------------------------*/
/*   Read the NINTENS OutputFunction from memory                      */
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   if (dat[0] != 0)
      for (i = 0; i < NINTENS; ++i)
         buf_out[i] = rofm[i];
   if (dat[1] != 0)
      for (i = 0; i < NINTENS; ++i)
         buf_out[i] = gofm[i];
   if (dat[2] != 0)
      for (i = 0; i < NINTENS; ++i)
         buf_out[i] = bofm[i];

   return (0);
}

cmap_graph()
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
{
   int prevgraph;
/*--------------------------------------------------------------------*/
   if ((dat[0] < 1) || (dat[0] > NGRAPH)) {
      fprintf (stderr, "Illegal graphics channel %d\n", dat[0]);
      return (-1);
      }
   else {
      prevgraph = rwgraph;
      gph_mask = 1;
      if (dat[0] == 2) gph_mask = 2;
      if (dat[0] == 3) gph_mask = 4;
      if (dat[0] == 4) gph_mask = 8;
      if (dat[1] > 0)
         rwgraph = rwgraph | gph_mask;
      else
         rwgraph = rwgraph & (~ gph_mask);
      if (prevgraph != rwgraph) {
         repaint_canvas (canvas, pw, (Rectlist *) NULL);
         return (cmap_change());
         }
      else
         return (0);
      }
}

cmap_split()
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
{
   int prevchan;
/*--------------------------------------------------------------------*/
   if ((dat[0] < 0) || (dat[0] > NGREY)) {
      fprintf (stderr, "Illegal grey channel %d\n", dat[0]);
      return (-1);
      }
   else if ((dat[1] != dat[0]) || (dat[2] != dat[0]) ||
      (dat[3] != dat[0])) {
      fprintf (stderr, "Split not implemented %d %d %d %d\n",
         dat[0], dat[1], dat[2], dat[3]);
      return (-1);
      }
   else {
      prevchan = cur_chan;
      cur_chan = dat[0];
      if (prevchan != cur_chan) {
         repaint_canvas (canvas, pw, (Rectlist *) NULL);
         return (cmap_change());
         }
      else
         return (0);
      }
}

cmap_wgrfx()
/*--------------------------------------------------------------------*/
/* Writes the cursor and graphics colour assignment.                  */
/*                                                                    */
/* MRC 90/Feb/15:                                                     */
/*--------------------------------------------------------------------*/
{
   void crscol();
   int i;

   if ((dat[0] < 0) || (dat[0] > NGRAPH)) {
      fprintf (stderr, "Illegal grafix channel %d\n", dat[0]);
      return (-1);
      }

   rgrfx[dat[0]] = dat[1];
   ggrfx[dat[0]] = dat[2];
   bgrfx[dat[0]] = dat[3];

/*                                      make cross colors             */
   crscol (rgrfx, rgcol);
   crscol (ggrfx, ggcol);
   crscol (bgrfx, bgcol);

   return (cmap_change());
}

void crscol (grfx, gcol)
/*--------------------------------------------------------------------*/
/* converts grfx[5] to full set of colors gcol[16] where              */
/* Input:  grfx i[5]   cursor, 4 graphics values for a color          */
/* Output: gcol i[16]  graphics values 1-15, cursor for the color     */
/*--------------------------------------------------------------------*/
   int *grfx, *gcol;
/*--------------------------------------------------------------------*/
{
   *(gcol+0) = *(grfx+1);
   *(gcol+1) = *(grfx+2);
   *(gcol+2) = *(grfx+1) ^ *(grfx+2);
   *(gcol+3) = *(grfx+3);
   *(gcol+4) = *(grfx+1) ^ *(grfx+3);
   *(gcol+5) = *(grfx+2) ^ *(grfx+3);
   *(gcol+6) = *(grfx+1) ^ *(gcol+5);
   *(gcol+7) = *(grfx+4);
   *(gcol+8) = *(grfx+4) ^ *(gcol+0);
   *(gcol+9) = *(grfx+4) ^ *(gcol+1);
   *(gcol+10) = *(grfx+4) ^ *(gcol+2);
   *(gcol+11) = *(grfx+4) ^ *(gcol+3);
   *(gcol+12) = *(grfx+4) ^ *(gcol+4);
   *(gcol+13) = *(grfx+4) ^ *(gcol+5);
   *(gcol+14) = *(grfx+4) ^ *(gcol+6);

   *(gcol+15) = *(grfx+0);
}

cmap_rgrfx()
/*--------------------------------------------------------------------*/
/* Reads the cursor and graphics colour assignment.                   */
/*                                                                    */
/* MRC 90/Feb/15:                                                     */
/*--------------------------------------------------------------------*/
{
   if ((dat[0] < 0) || (dat[0] > NGRAPH)) {
      fprintf (stderr, "Illegal grafix channel %d\n", dat[0]);
      return (-1);
   }

   buf_out[0] = rgrfx[dat[0]];
   buf_out[1] = ggrfx[dat[0]];
   buf_out[2] = bgrfx[dat[0]];

   return (0);
}

cmap_change()
/*--------------------------------------------------------------------*/
/* Changes the colormap based on the stored LUTs and OFMs in core.    */
/*--------------------------------------------------------------------*/
{
   register int i, ns, j;
   Pixwin *pw;
/*--------------------------------------------------------------------*/
   j = cur_chan - 1;
/*                                      do the NCOLOUR of image first */
   if (cur_chan > 0) {
      for (i = 0; i < NCOLOUR; ++i) {
         red[i] = rofm[rlut[j][i]];
         green[i] = gofm[glut[j][i]];
         blue[i] = bofm[blut[j][i]];
         }
      red[0] = blue[0] = green[0] = 0;
      }
/*                                      image is off                  */
   else {
      for (i = 0; i < NCOLOUR; ++i) {
         red[i] = blue[i] = green[i] = 0;
         }
      }
/*                                      add in graphics               */
   ns = NCOLOUR;
   for (i = NCOLOUR; i < NVALUE; ++i) {
       red[i] = rgcol[i-ns];
       green[i] = ggcol[i-ns];
       blue[i] = bgcol[i-ns];
      }
   pw = (Pixwin *) canvas_pixwin (canvas);
   pw_setcmsname (pw, "SSS_CM");
   pw_putcolormap (pw, 0, NVALUE, red, green, blue);

   return (0);
}
--XYZZY--
cat > cursor.c << --XYZZY--
#include "header.h"

void handle_events(window, event, arg)
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) maintains cursor position, scaling, buttons         */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/*  This keeps track of the cursor in the canvas - however it only    */
/*  keeps track of the dragged cursor so that when you leave the      */
/*  canvas to do other things your (e.g.) transfer fn won't get all   */
/*  fouled up. This assumes the LOC_DRAG* event processing is enabled.*/
/*  It also keeps track of function key events - which it maps into   */
/*  "button" presses.                                                 */
/*                                                                    */
/*  EWG 90/Feb/20: Add RESIZE function key event.                     */
/*  MRC 90/Feb/22: Fixed function key "bounce" problem.               */
/*--------------------------------------------------------------------*/
    Window window;
    Event *event;
    caddr_t arg;
/*--------------------------------------------------------------------*/
{
   if ((event_id(event) == LOC_DRAG)
    || (event_id(event) == MS_LEFT)) {
                    /* Apparently AIPS corrects for zoom and scroll ! */
      cursor_x = event_x(event) + sc_centre_x - sc_width2 + 1;
      cursor_y = event_y(event) + sc_centre_y - sc_height2 + 1;
                                        /* ends up 1 low ???  Makes   */
                                        /* tip of arrow the hot spot  */
      cursor_x++;
      cursor_y++;
      }
   else if (event_is_down(event)) {
      if (event_id(event) == KEY_TOP(2))
         resize_pressed();
      if (event_id(event) == KEY_TOP(3))
         button_a_pressed();
      if (event_id(event) == KEY_TOP(4))
         button_b_pressed();
      if (event_id(event) == KEY_TOP(5))
         button_c_pressed();
      if (event_id(event) == KEY_TOP(6))
         button_d_pressed();
      if (event_id(event) == KEY_TOP(7))
         resize_pressed();
      if (event_id(event) == KEY_TOP(8))
         SssDebug = !SssDebug;
      }
}

cursor_position()
/*--------------------------------------------------------------------*/
{
   buf_out[0] = Aips_x (cursor_x);
   buf_out[1] = Aips_y (cursor_y);

   return (0);
}

cursor_move()
/*--------------------------------------------------------------------*/
/*  Sets the cursor position */
/*--------------------------------------------------------------------*/
{
   int xc, yc;
/*--------------------------------------------------------------------*/
   cursor_x = Memory_x (dat[0]);
   cursor_y = Memory_y (dat[1]);
   xc = cursor_x - sc_centre_x + sc_width2 - 1;
   yc = cursor_y - sc_centre_y + sc_height2 - 1;
                                        /* ends up 1 low ???  Makes   */
                                        /* tip of arrow the hot spot  */
   xc--;
   yc--;

/* Only physically move if Cursor would be in window! */
   if (xc < sc_width && yc < sc_height && xc > 0 && yc > 0)
      window_set (canvas, WIN_MOUSE_XY, xc, yc, 0);

   return (0);
}

void resize_canvas(canvas, width, height)
/*--------------------------------------------------------------------*/
/*  Called when the screen gets resized. Simply sets some scales and  */
/*  offsets                                                           */
/*--------------------------------------------------------------------*/
   Canvas canvas;
   int width;
   int height;
/*--------------------------------------------------------------------*/
{
   int itx, ity, icx, icy;

   icx = (int) window_get (frame, WIN_WIDTH);
   icy = (int) window_get (frame, WIN_HEIGHT);
   sc_width = icx -  SCREEN_XMARG;
   sc_height = icy -  SCREEN_YMARG;
   if (sc_width > SCREEN_WIDTH || sc_height > SCREEN_HEIGHT) {
      sc_width = min (sc_width, SCREEN_WIDTH);
      sc_height = min (sc_height, SCREEN_HEIGHT);
      sc_width2 = sc_width / 2;
      sc_height2 = sc_height / 2;
      sc_centre_x = max (sc_centre_x, sc_width2 - 1);
      sc_centre_y = max (sc_centre_y, sc_height2 - 1);
      sc_centre_x = min (sc_centre_x, SCREEN_WIDTH - sc_width2 - 1);
      sc_centre_y = min (sc_centre_y, SCREEN_HEIGHT - sc_height2 - 1);
      itx = sc_width + SCREEN_XMARG;
      ity = sc_height + SCREEN_YMARG;
      window_set (frame, WIN_WIDTH, itx, WIN_HEIGHT, ity, 0);
      }
   else {
      sc_width2 = sc_width / 2;
      sc_height2 = sc_height / 2;
      sc_centre_x = max (sc_centre_x, sc_width2 - 1);
      sc_centre_y = max (sc_centre_y, sc_height2 - 1);
      sc_centre_x = min (sc_centre_x, SCREEN_WIDTH - sc_width2 - 1);
      sc_centre_y = min (sc_centre_y, SCREEN_HEIGHT - sc_height2 - 1);
      }
   if (SssDebug)
      fprintf (stderr, "resize_canvas W H, center %d %d, %d %d\n",
         sc_width, sc_height, sc_centre_x, sc_centre_y);
}

void button_a_pressed()
/*--------------------------------------------------------------------*/
{
   button_a + = 1;
}

void button_b_pressed()
/*--------------------------------------------------------------------*/
{
   button_b + = 1;
}

void button_c_pressed()
/*--------------------------------------------------------------------*/
{
   button_c + = 1;
}

void button_d_pressed()
/*--------------------------------------------------------------------*/
{
   button_d + = 1;
}

void resize_pressed()
/*--------------------------------------------------------------------*/
{
   int itx, ity, icx, icy;

   cur_size = cur_size + 1;
   if (cur_size > 1) cur_size = 0;
   if (cur_size > 0) {
      cur_xcorn = (int) window_get (frame, WIN_X);
      cur_ycorn = (int) window_get (frame, WIN_Y);
      cur_xsize = (int) window_get (frame, WIN_WIDTH);
      cur_ysize = (int) window_get (frame, WIN_HEIGHT);
      itx = SCREEN_WIDTH + SCREEN_XMARG;
      ity = SCREEN_HEIGHT + SCREEN_YMARG;
      icx = 0;
      icy = 0;
      }
   else {
      itx = cur_xsize;
      ity = cur_ysize;
      icx = cur_xcorn;
      icy = cur_ycorn;
      }
   window_set (frame, WIN_WIDTH, itx, WIN_HEIGHT, ity, WIN_X, icx,
      WIN_Y, icy, 0);
   repaint_canvas (canvas, pw, (Rectlist *) NULL);
   if (SssDebug)
      fprintf (stderr, "resize_pressed W H, X Y %d %d, %d %d\n",
         sc_width, sc_height, icx, icy);
}

button_status()
/*--------------------------------------------------------------------*/
/*  Returns how many times each of the buttons has been pressed and   */
/*  returns those numbers in buf, and then resets the counts.         */
/*--------------------------------------------------------------------*/
{
   buf_out[0] = button_a;
   buf_out[1] = button_b;
   buf_out[2] = button_c;
   buf_out[3] = button_d;
   button_a = button_b = button_c = button_d = 0;

   return (0);
}

int cursor_button()
{
    buf_out[0] = Aips_x (cursor_x);
    buf_out[1] = Aips_y (cursor_y);

    buf_out[2] =  button_a;
    buf_out[3] =  button_b;
    buf_out[4] =  button_c;
    buf_out[5] =  button_d;

    button_a = button_b = button_c = button_d = 0;
    return (0);
}

windo_status()
/*--------------------------------------------------------------------*/
/*  Returns current window corners                                    */
/*--------------------------------------------------------------------*/
{
   int itx, ity, icx, icy;
                                        /* force screen size          */
   if (dat[0] > 0 && dat[1] > 0 && dat[2] > 0 && dat[3] > 0) {
      if (dat[2] > SCREEN_WIDTH) dat[2] = SCREEN_WIDTH;
      if (dat[3] > SCREEN_HEIGHT) dat[3] = SCREEN_HEIGHT;
      itx = Memory_x (dat[0]);
      icx = Memory_x (dat[2]);
      ity = Memory_y (dat[3]);
      icy = Memory_y (dat[1]);
      sc_width = icx - itx + 1;
      sc_height = icy - ity + 1;
      sc_centre_x = (icx + itx - 1) / 2;
      sc_centre_y = (icy + ity - 1) / 2;
      sc_width2 = sc_width / 2;
      sc_height2 = sc_height / 2;
      itx = sc_width + SCREEN_XMARG;
      ity = sc_height + SCREEN_YMARG;
      icx = (int) window_get (frame, WIN_X);
      icy = (int) window_get (frame, WIN_Y);
      icx = min (icx, SCREEN_WIDTH - sc_width);
      icy = min (icy, SCREEN_HEIGHT - sc_height);
      window_set (frame, WIN_WIDTH, itx, WIN_HEIGHT, ity,
         WIN_X, icx, WIN_Y, icy, 0);
      scrwrt (0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1);
      if (SssDebug)
         fprintf (stderr, "window_status W H, X Y %d %d, %d %d\n",
            sc_width, sc_height, icx, icy);
      }
   buf_out[0] = Aips_x (sc_centre_x - sc_width2 + 1);
   buf_out[3] = Aips_y (sc_centre_y - sc_height2 + 1);
   buf_out[2] = Aips_x (sc_centre_x + sc_width2);
   buf_out[1] = Aips_y (sc_centre_y + sc_height2);

   return (0);
}
--XYZZY--
cat > header.h << --XYZZY--
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) include file to declare the TV luts, memory, etc.   */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/

/* Things needed for windows */

#include <stdio.h>
#include <suntool/sunview.h>
#include <suntool/canvas.h>
#include <suntool/panel.h>
#include <sunwindow/notify.h>

Frame frame;
Canvas canvas;
Pixwin *pw;
Panel panel;

/* advise dropping DEFINE_ICON_FROM_IMAGE so */
Icon SSS_icon;
/* Pixrect icon_pr;
   struct mpr_data icon_pr_data;    */

int button_a, button_b, button_c, button_d;
int cursor_x, cursor_y;
int sc_centre_x, sc_centre_y, sc_zoom_mag;
int sc_width, sc_height, sc_width2, sc_height2;
int cur_chan, cur_size, cur_xcorn, cur_ycorn,
    cur_xsize, cur_ysize;
int scrhold, numhold, Maxhold, uxs, uxe, uys, uye;
int Z_maxseg;                           /* I/O segment length          */

void repaint_canvas();
void resize_canvas();
void handle_events();
void button_a_pressed();
void button_b_pressed();
void button_c_pressed();
void button_d_pressed();
void resize_pressed();
button_status();

/* Header info needed for socket routines (including i/o) */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

int connected, read_mask;
struct sockaddr_un from, server;
struct sockaddr_in from_in, server_in;
struct servent *sp_in;

int s, g, domain_type, buffered;
#define UNIX_DOMAIN 0
#define INET_DOMAIN 1

/* opcode, status etc (server/client protocol) */

#define BUFLEN 4096
unsigned char buf[BUFLEN];
short int *buf_out; /* will point at buf_out for short_int returns */
short int op, ndata, status, nwsd;
short int dat[4];


/* Screen parameters */

/* If you have a different size screen or chars WIDTH/HEIGHT will     */
/* need to be changed. Easiest way to get values is to uncomment      */
/*  printf in ressize canvas routine.                                 */

#define SCREEN_WIDTH 1142                /* MUST be an even number    */
#define SCREEN_XMARG 10                  /* full X = 1152             */
#define SCREEN_YMARG 23                  /* full Y = 900  was 58 here */

                                        /* MUST be an even number !   */
/* #define TEXT_SPACE      0 */         /* preferred at the AT        */
#define TEXT_SPACE     74               /* preferred at the NRAO      */
#define SCREEN_HEIGHT (876 - TEXT_SPACE)

#define NCOLOUR 112
#define NINTENS 256
#define NVALUE 128
#define NBITS 8
#define NGREY 2
#define NGRAPH 4
#define NGRTOT (NGREY+NGRAPH)          /* = NGREY + NGRAPH           */

struct pixrect *mem1_pr, *mem2_pr, *mem3_pr, *mem4_pr, *mem_line_pr;
struct pixrect *memg_pr, *mem_full_pr;
u_char red[NVALUE], green[NVALUE], blue[NVALUE];
int rlut[NGREY][NCOLOUR], glut[NGREY][NCOLOUR], blut[NGREY][NCOLOUR];
int rofm[NINTENS], gofm[NINTENS], bofm[NINTENS];
int rwgraph;
int upleft_x[NGRTOT], upleft_y[NGRTOT], upleft_mag;

int rgrfx[5], ggrfx[5], bgrfx[5], rgcol[16], ggcol[16], bgcol[16];

/*                                      for the memory_pixrect        */
unsigned char mem_image[NGREY][SCREEN_HEIGHT][SCREEN_WIDTH];
unsigned char gph_image[SCREEN_HEIGHT][SCREEN_WIDTH];
unsigned char gph_mask;
/*                                      Approximately where the       */
/*                                      break is for efficient zoom   */
#define ZOOM_HARD 16
unsigned char mem_line[ZOOM_HARD][SCREEN_WIDTH];
unsigned char mem_full[SCREEN_WIDTH];

#define True 1
#define False 0
int SssDebug;

#include <sys/time.h>
struct itimerval accept_timer, ovalue;
#define ITIMER_NULL ((struct itimerval *)0)

/* Useful macros */

#define Memory_x(aips_x) ((aips_x) - 1)
#define Memory_y(aips_y) (SCREEN_HEIGHT - (aips_y))
#define Aips_x(memory_x) ((memory_x) + 1)
#define Aips_y(memory_y) (SCREEN_HEIGHT - (memory_y))

#define chn_set(var,value) ((var) = ((var)&NCOLOUR)|((value)&(NCOLOUR-1)))
#define chg_set(var,val) ((var) = ((var)&(NCOLOUR-1))|((val) ? NCOLOUR : 0))
#define chg_s(var,val,msk) ((var) = ((var)&(~(msk)))|((val) ? (msk) : 0))

#define chn_get(var) ((var)&(NCOLOUR-1))
#define chg_get(var) (((var)&(NCOLOUR)) ? 1 : 0)
#define chg_g(var,msk) (((var)&(msk)) ? 1 : 0)

#ifndef min
#define min(a,b) ((a)<(b)?(a):(b))
#endif

#ifndef max
#define max(a,b) ((a)>(b)?(a):(b))
#endif

#define intswap(a,b) { int tmp; tmp=a; a=b; b=tmp; }


/* Defined SSS opcodes */
     /* bufferop[OPCODE] >0 --> no status return if in buffered mode. */

#define NUMOP 83       /* Largest opcode */
int bufferop[NUMOP+1];

/*--------------------------------------------------------------------*/
#define OPEN    11     /* Opens the SSS - a NOP                       */
#define CLOSE   12     /* Close the SSS, allows new connections       */
#define INTGT   13     /* Interrogate; determine SSS basic parameters */
#define WINDO   14     /* Read (write not impl.) SSS window size      */
#define CLEAR   15     /* Clear some or all channels                  */
#define VIEW    16     /* Do/hold screen updates                      */
#define IMWRT   21     /* Write an image line to some channel         */
#define IMRD    22     /* Read an image line from some channel        */
#define WLUT    41     /* Write LUT to a channel.                     */
#define RLUT    42     /* Read LUT to a channel.                      */
#define WOFM    43     /* Write OFM             .                     */
#define ROFM    44     /* Read OFM.                                   */
#define GRAPH   45     /* On/off graphics channel(s)                  */
#define SPLIT   46     /* On/off image channels(s)                    */
#define WGRFX   51     /* Write graphics/cursor colours               */
#define RGRFX   52     /* Read  graphics/cursor colours               */
#define RCURS   61     /* Read the cursor position.                   */
#define RBUTT   62     /* Read the status of the buttons              */
#define WCURS   63     /* Write the cursor position.                  */
#define RCURB   64     /* Read the cursor position and buttons        */
#define WZOOM   81     /* Write zoom info to the SSS                  */
#define WSCROL  82     /* Write scroll registers                      */
#define WZSCR   83     /* Write zoom/scroll to SSS using ULC          */
--XYZZY--
cat > imgio.c << --XYZZY--
#include "header.h"

imwrt()
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) write to / read from the TV memory and display      */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This routine responds to opcode 21 and writes an image row to the  */
/* screen                                                             */
/*--------------------------------------------------------------------*/
{
   int xs, ys, iangl, channel, j, k;
   register int i, npix;
/*--------------------------------------------------------------------*/
   xs = Memory_x(dat[0]);
   ys = Memory_y(dat[1]);
   channel = dat[2];
   iangl = dat[3];
   npix = ndata;

   if ((channel < 1) || (channel > NGRTOT)) {
      fprintf (stderr, "channel = %d\n", channel);
      return (-1);
      }

   j = channel - 1;
   gph_mask = 0;
   if (channel == NGREY+1) gph_mask = 1;
   if (channel == NGREY+2) gph_mask = 2;
   if (channel == NGREY+3) gph_mask = 4;
   if (channel == NGREY+4) gph_mask = 8;
   if (iangl == 0) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            mem_image[j][ys][xs + i] = buf[i];
            }
      else {
         for (i = 0; i < npix; i++) {
            chg_s (gph_image[ys][xs + i], buf[i], gph_mask);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
         scrwrt (xs, ys, xs + npix, ys);
      }
   else if (iangl == 1) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            mem_image[j][ys - i][xs] = buf[i];
            }
      else {
         for (i = 0; i < npix; i++) {
            chg_s (gph_image[ys - i][xs], buf[i], gph_mask);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
         scrwrt (xs, ys - npix, xs, ys);
      }
   else if (iangl == 2) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            mem_image[j][ys][xs - i] = buf[i];
            }
      else {
         for (i = 0; i < npix; i++) {
            chg_s (gph_image[ys][xs - i], buf[i], gph_mask);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
        scrwrt (xs - npix, ys, xs, ys);
      }
   else if (iangl == 3) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            mem_image[j][ys + i][xs] = buf[i];
            }
      else {
         for (i = 0; i < npix; i++) {
            chg_s (gph_image[ys + i][xs], buf[i], gph_mask);
            }
         }
      if ((channel == cur_chan) || (rwgraph & gph_mask))
         scrwrt (xs, ys, xs, ys + npix);
      }

   return (0);
}

imrd(nwpix)
/*--------------------------------------------------------------------*/
/* This subroutine returns an image line to the client. It's not very */
/* general for number of channels, but is easy to change so that's    */
/* likely good enough (just add new macros etc.)                      */
/*--------------------------------------------------------------------*/
short int *nwpix;
/*--------------------------------------------------------------------*/
{
   int xs, ys, iangl, channel, j;
   short int jj;
   register int i, npix;
/*--------------------------------------------------------------------*/
   xs = Memory_x (dat[0]);
   ys = Memory_y (dat[1]);
   channel = dat[2];
   iangl = dat[3];
                                        /* special I*2 word in buffer */
   jj = *(short int *)buf;
   npix = ntohs (jj);
   *nwpix = npix;

   if ((channel < 1) || (channel > NGRTOT)) {
      fprintf (stderr, "channel = %d\n", channel);
      return (-1);
      }

   j = channel - 1;
   gph_mask = 0;
   if (channel == NGREY+1) gph_mask = 1;
   if (channel == NGREY+2) gph_mask = 2;
   if (channel == NGREY+3) gph_mask = 4;
   if (channel == NGREY+4) gph_mask = 8;
   if (iangl == 0) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = mem_image[j][ys][xs + i];
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (gph_image[ys][xs + i],gph_mask);
            }
      }
   else if (iangl == 1) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = mem_image[j][ys - i][xs];
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (gph_image[ys - i][xs],gph_mask);
            }
      }
   if (iangl == 2) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = mem_image[j][ys][xs - i];
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (gph_image[ys][xs - i],gph_mask);
            }
      }
   else if (iangl == 3) {
      if (channel <= NGREY)
         for (i = 0; i < npix; i++) {
            buf_out[i] = mem_image[j][ys + i][xs];
            }
      else
         for (i = 0; i < npix; i++) {
            buf_out[i] = chg_g (gph_image[ys + i][xs],gph_mask);
            }
      }

   return (0);
}

Interogate (nparms)
/*--------------------------------------------------------------------*/
/* This subroutine returns the critical parameters of the TV to the   */
/* client in the order of DTVC.INC                                    */
/*--------------------------------------------------------------------*/
short int *nparms;
/*--------------------------------------------------------------------*/
{

   *nparms = 29;
   buf_out[0] = NGREY;
   buf_out[1] = NGRAPH;
   buf_out[2] = -1;
   buf_out[3] = SCREEN_WIDTH;
   buf_out[4] = SCREEN_HEIGHT;
   buf_out[5] = NCOLOUR - 1;
   buf_out[6] = (NINTENS) - 1;
   buf_out[7] = (NINTENS) - 1;
   buf_out[8] = (NINTENS) - 1;
   buf_out[9] = 1;
   buf_out[10] = 1;
   buf_out[11] = 1 - (ZOOM_HARD);
   buf_out[12] = -1;
   buf_out[13] = -1;
   buf_out[14] = 0;
   buf_out[15] = 0;
   buf_out[16] = 3;
   buf_out[17] = 3;
   buf_out[18] = -1;
   buf_out[19] = -1;
   buf_out[20] = -1;
   buf_out[21] = -1;
   buf_out[22] = -1;
   buf_out[23] = -1;
   buf_out[24] = -1;
   buf_out[25] = -1;
   buf_out[26] = -1;
   buf_out[27] = -1;
   buf_out[28] = -1;

   return (0);
}
--XYZZY--
cat > scrwrt.c << --XYZZY--
#include "header.h"

void scrwrt (xs, ys, xe, ye)
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) update TV display from memory with zoom, scroll     */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Draws from memory image to the screen taking account of zoom,      */
/* scroll and window offsets etc. Updates that rectangle enclosed by  */
/* xs, ys, xe, ye.  Dimensions are screen units.                      */
/*--------------------------------------------------------------------*/
   int xs, ys, xe, ye;
/*--------------------------------------------------------------------*/
{
   int xmin, xmax, ymin, ymax, xext, yext, amin, amax, xoff, yoff;
   int choff;
   void scrdoit();
/*--------------------------------------------------------------------*/
   if (scrhold) {
      uxs = min (xs, uxs);
      uys = min (ys, uys);
      uxe = max (xe, uxe);
      uye = max (ye, uye);
      numhold = numhold + 1;
      if (numhold <= Maxhold) return;
      xs = uxs;
      ys = uys;
      xe = uxe;
      ye = uye;
      uxs = SCREEN_WIDTH;
      uxe = 0;
      uys = SCREEN_HEIGHT;
      uye = 0;
      }
   numhold = 0;
/*                                      Make sure xs, ys, xe, ye in   */
/*                                      window since no clip in zoom! */

   choff = max (0, cur_chan - 1);
/*                                      Upper left quadrant           */
   xmin = upleft_x[choff] * upleft_mag + sc_centre_x - sc_width2 + 1;
   xmax = upleft_x[choff] * upleft_mag + sc_centre_x + sc_width2;
   if (xmin >= SCREEN_WIDTH * upleft_mag) {
      xmin -= SCREEN_WIDTH * upleft_mag;
      xmax -= SCREEN_WIDTH * upleft_mag;
      }
   xext = xmax - (SCREEN_WIDTH - 1) * upleft_mag;
   if (xext > 0) xmax = (SCREEN_WIDTH - 1) * upleft_mag;
   ymin = upleft_y[choff] * upleft_mag + sc_centre_y - sc_height2 + 1;
   ymax = upleft_y[choff] * upleft_mag + sc_centre_y + sc_height2;
   if (ymin >= SCREEN_HEIGHT * upleft_mag) {
      ymin -= SCREEN_HEIGHT * upleft_mag;
      ymax -= SCREEN_HEIGHT * upleft_mag;
      }
   yext = ymax - (SCREEN_HEIGHT - 1) * upleft_mag;
   if (yext > 0) ymax = (SCREEN_HEIGHT - 1) * upleft_mag;
   xoff = yoff = 0;
   scrdoit (xs, ys, xe, ye, xmin, ymin, xmax, ymax, xoff, yoff);
/*                                      Upper right quadrant          */
   if (xext > 0) {
      amin = 0;
      amax = xext - upleft_mag;
      xoff = xmax + upleft_mag - xmin;
      yoff = 0;
      scrdoit (xs, ys, xe, ye, amin, ymin, amax, ymax, xoff, yoff);
      }
/*                                      Lower left quadrant           */
   if (yext > 0) {
      amin = 0;
      amax = yext - upleft_mag;
      xoff = 0;
      yoff = ymax + upleft_mag - ymin;
      scrdoit (xs, ys, xe, ye, xmin, amin, xmax, amax, xoff, yoff);
      }
/*                                      Lower right quadrant           */
   if ((xext > 0) && (yext > 0)) {
      xoff = xmax + upleft_mag - xmin;
      yoff = ymax + upleft_mag - ymin;
      amin = 0;
      amax = yext - upleft_mag;
      xmin = 0;
      xmax = xext - upleft_mag;
      scrdoit (xs, ys, xe, ye, xmin, amin, xmax, amax, xoff, yoff);
      }

}

void scrdoit (xs, ys, xe, ye, xmin, ymin, xmax, ymax, xoff, yoff)
/*--------------------------------------------------------------------*/
/* Draws from memory image to the screen taking account of zoom,      */
/* scroll and window offsets etc.  Updates that rectangle enclosed by */
/* xs, ys, xe, ye.  Dimensions are screen units before zoom for xs,   */
/* ys, xe, ye and AFTER zoom for the others.  This means that the left*/
/* column and upper row and right column and lower row may not be     */
/* replicated upleft_mag times in zoom.                               */
/*--------------------------------------------------------------------*/
   int xs, ys, xe, ye, xmin, ymin, xmax, ymax, xoff, yoff;
/*--------------------------------------------------------------------*/
{
   int i, x, y, offset, k, choff, xx, yy, nx, ny;
   register unsigned char *ti, *tl;
   register int j, jj;
/*--------------------------------------------------------------------*/
   if (SssDebug) {
      fprintf (stderr, "xs,ys,xe,ye,mag %d %d %d %d %d\n", xs, ys, xe,
         ye, upleft_mag);
      fprintf (stderr, "xmin,xmax,ymin,ymax %d %d %d %d\n", xmin, xmax,
         ymin, ymax);
      fprintf (stderr, "xoff, yoff %d %d\n", xoff, yoff);
      }
   xs = max (xs, xmin / upleft_mag);
   ys = max (ys, ymin / upleft_mag);
   xe = min (xe, xmax / upleft_mag);
   ye = min (ye, ymax / upleft_mag);
   choff = max (0, cur_chan - 1);
   upleft_mag = max (1, upleft_mag);

                                       /* find number x points        */
   nx = upleft_mag * (xe - xs + 1);
   offset = upleft_mag * xs - xmin + xoff;
   if (offset < 0) {
      nx += offset;
      offset = 0;
      }
   nx = min (nx, xmax - xmin + xoff - offset + 1);
/*                                      no graphics is faster         */
   if ((xe >= xs) && (ye >= ys) && (rwgraph <= 0)) {
/*                                      no zoom is easy               */
      if (upleft_mag <= 1) {
         if (cur_chan < 2)
            pw_rop (pw, xs - xmin + xoff, ys - ymin + yoff, nx,
               ye - ys + 1, PIX_SRC, mem1_pr, xs, ys);
         if (cur_chan == 2)
            pw_rop (pw, xs - xmin + xoff, ys - ymin + yoff, nx,
               ye - ys + 1, PIX_SRC, mem2_pr, xs, ys);
         if (cur_chan == 3)
            pw_rop (pw, xs - xmin + xoff, ys - ymin + yoff, nx,
               ye - ys + 1, PIX_SRC, mem3_pr, xs, ys);
         if (cur_chan == 4)
            pw_rop (pw, xs - xmin + xoff, ys - ymin + yoff, nx,
               ye - ys + 1, PIX_SRC, mem4_pr, xs, ys);
         }
      else {
         if (upleft_mag <= ZOOM_HARD) {
            pw_lock (pw, (Rect *) window_get (canvas, WIN_RECT, 0));
            for (i = ys; i <= ye; i++) {
               for (x=0; x < upleft_mag; x++) {
                  offset = upleft_mag * xs - xmin + x + xoff;
                  tl = &mem_line[0][offset];
                  ti = &mem_image[choff][i][xs];
                  j = (xe - xs) + 1;
                  if (offset < 0) {
                     tl += upleft_mag;
                     ti += 1;
                     j--;
                     }
                  while (j--) {
                     *tl = *ti++;
                     tl += upleft_mag;
                     }
                  }
               offset = max (upleft_mag * xs - xmin + xoff, 0);
               yy = upleft_mag * i - ymin + yoff;
               ny = upleft_mag;
               if (yy < 0) {
                  ny += yy;
                  yy = 0;
                  }
               ny = min (ymax - ymin + yoff + 1 - yy, ny);
               for (y = 1; y < ny; y++)
                  bcopy (&mem_line[0][offset], &mem_line[y][offset],
                     nx);
               pw_rop (pw, offset, yy, nx, ny, PIX_SRC, mem_line_pr,
                   offset, 0);
               }
            pw_unlock (pw);
            }
         else {
            for (i = ys; i <= ye; i++) {
               pw_lock (pw, (Rect *) window_get (canvas, WIN_RECT, 0));
               yy = upleft_mag * i - ymin + yoff;
               ny = upleft_mag;
               if (yy < 0) {
                  ny += yy;
                  yy = 0;
                  }
               ny = min (ymax - ymin + yoff + 1 - yy, ny);
               for (j = xs; j <= xe; j++) {
                  xx = upleft_mag * j - xmin + xoff;
                  nx = upleft_mag;
                  if (xx < 0) {
                     nx += xx;
                     xx = 0;
                     }
                  nx = min (xmax - xmin + xoff + 1 - xx, nx);
                  pw_rop (pw, xx, yy, nx, ny,
                     PIX_SRC | PIX_COLOR(mem_image[choff][i][j]),
                     (Pixrect *) NULL, 0, 0);
                  }
               pw_unlock (pw);
               }
            }
         }
      }
   if ((xe >= xs) && (ye >= ys) && (rwgraph > 0)) {
      jj = NCOLOUR - 1;
      if (upleft_mag <= ZOOM_HARD) {
         pw_lock (pw, (Rect *) window_get (canvas, WIN_RECT, 0));
         for (i = ys; i <= ye; i++) {
            for (j = xs; j <= xe; j++) {
                gph_mask = rwgraph & gph_image[i][j];
                if (gph_mask > 0)
                   mem_full[j] = jj + gph_mask;
                else
                   mem_full[j] = mem_image[choff][i][j];
                }
            for (x=0; x < upleft_mag; x++) {
               offset = upleft_mag * xs - xmin + x + xoff;
               tl = &mem_line[0][offset];
               ti = &mem_full[xs];
               j = xe - xs + 1;
               if (offset < 0) {
                  tl += upleft_mag;
                  ti++;
                  j--;
                  }
               while (j--) {
                  *tl = *ti++;
                  tl += upleft_mag;
                  }
               }
            offset = max (upleft_mag * xs - xmin + xoff, 0);
            yy = upleft_mag * i - ymin + yoff;
            ny = upleft_mag;
            if (yy < 0) {
               ny += yy;
               yy = 0;
               }
            ny = min (ymax - ymin + yoff + 1 - yy, ny);
            if (ny > 1) {
               for (y = 1; y < ny; y++)
                  bcopy (&mem_line[0][offset], &mem_line[y][offset],
                     nx);
               }
            pw_rop (pw, offset, yy, nx, ny, PIX_SRC, mem_line_pr,
               offset, 0);
            }
         pw_unlock (pw);
         }
      else {
         for (i = ys; i <= ye; i++) {
            pw_lock (pw, (Rect *) window_get (canvas, WIN_RECT, 0));
            yy = upleft_mag * i - ymin + yoff;
            ny = upleft_mag;
            if (yy < 0) {
               ny += yy;
               yy = 0;
               }
            ny = min (ymax - ymin + yoff + 1 - yy, ny);
            for (j = xs; j <= xe; j++) {
               xx = upleft_mag * j - xmin + xoff;
               nx = upleft_mag;
               if (xx < 0) {
                  nx += xx;
                  xx = 0;
                  }
               nx = min (xmax - xmin + xoff + 1 - xx, nx);
               gph_mask = rwgraph & gph_image[i][j];
               if (gph_mask > 0)
                  mem_full[j] = jj + gph_mask;
               else
                  mem_full[j] = mem_image[choff][i][j];
               pw_rop (pw, xx, yy, nx, ny,
                  PIX_SRC | PIX_COLOR(mem_full[j]),
                  (Pixrect *) NULL, 0, 0);
                }
            pw_unlock (pw);
            }
         }
      }
}

void repaint_canvas (canvas, pw, repaint_area)
/*--------------------------------------------------------------------*/
/* Repaints the entire canvas.                                        */
/*--------------------------------------------------------------------*/
    Canvas canvas;
    Pixwin *pw;
    Rectlist *repaint_area;
/*--------------------------------------------------------------------*/
{
    if (SssDebug) fprintf (stderr, "at repaint canvas\n");
    scrwrt (0, 0, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 1);
}

screen_clear()
/*--------------------------------------------------------------------*/
/* This opcode clears all image and graphics channels, but is meant   */
/* to leave scroll and zoom "registers" alone.                        */
/*--------------------------------------------------------------------*/
{
   int channel, i, j, k;
/*--------------------------------------------------------------------*/
   channel = dat[0];
   if ((channel < 0) || (channel > NGRTOT))
      return (-1);
   if (NGREY >= 1) {
      if ((channel == 0) || (channel == 1))
         pr_rop (mem1_pr, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, PIX_CLR,
            NULL, 0, 0);
         }
   if (NGREY >= 2) {
      if ((channel == 0) || (channel == 2))
         pr_rop (mem2_pr, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, PIX_CLR,
            NULL, 0, 0);
      }
   if (NGREY >= 3) {
      if ((channel == 0) || (channel == 3))
         pr_rop (mem3_pr, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, PIX_CLR,
            NULL, 0, 0);
      }
   if (NGREY >= 4) {
      if ((channel == 0) ||  (channel == 4))
         pr_rop (mem4_pr, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, PIX_CLR,
            NULL, 0, 0);
      }

   if (channel == 0) {
      pr_rop (memg_pr, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, PIX_CLR,
         NULL, 0, 0);
      }

   if (channel > NGREY) {
      gph_mask = 15;
      if (channel == NGREY + 1) gph_mask = 14;
      if (channel == NGREY + 2) gph_mask = 13;
      if (channel == NGREY + 3) gph_mask = 11;
      if (channel == NGREY + 4) gph_mask = 7;
      pr_rop (memg_pr, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT,
         (PIX_DST & PIX_SRC) | PIX_COLOR(gph_mask), NULL, 0, 0);
      }

   repaint_canvas (canvas, pw, (Rectlist *) NULL);
   return (0);
}

ViewData()
/*--------------------------------------------------------------------*/
/* turns on/off command buffering by scrwrt()                         */
/*--------------------------------------------------------------------*/
{
   if ((scrhold) && (dat[0] == 0)) {
      scrhold = 0;
      if (numhold > 0) scrwrt (uxs, uys, uxe, uye);
      numhold = 0;
      uxe = uye = 0;
      uxs = SCREEN_WIDTH;
      uys = SCREEN_HEIGHT;
      }
   scrhold = dat[0] ;
   if (Maxhold <= 1) scrhold = 0;

   return (0);
}

int zoom()
/*--------------------------------------------------------------------*/
/* Sets the zoom registers                                            */
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   if ((dat[0] < 0) || (dat[0] > NGRTOT)) {
      fprintf (stderr, "Illegal channel %d\n", dat[0]);
      return (-1);
      }
   else if (dat[0] > NGREY) {
      }
   else if (dat[0] == 0) {
      upleft_mag = dat[1];
      for (i = 0; i < NGREY; i++) {
         upleft_x[i] = dat[2];
         upleft_y[i] = dat[3];
         }
      repaint_canvas (canvas, pw, (Rectlist *) NULL);
      }
   else {
      upleft_mag = dat[1];
      upleft_x[dat[0]-1] = dat[2];
      upleft_y[dat[0]-1] = dat[3];
      if ((dat[0] == cur_chan) || (cur_chan == 0))
         repaint_canvas (canvas, pw, (Rectlist *) NULL);
      }

   return (0);
}
--XYZZY--
cat > socket.c << --XYZZY--
#include "header.h"

Notify_value get_client(me, which)
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) locates a client request, gets and closes sockets   */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Get a client from the specified socket.  Note that this blocks.    */
/*--------------------------------------------------------------------*/
   Notify_client me;
   int which;
/*--------------------------------------------------------------------*/
{
   int len, optlen;
   static struct timeval time_0;
   static int my_client_object;/* These two lines make a unique handle */
   static int *me2 = &my_client_object;
   static Notify_value sock_io();
/*--------------------------------------------------------------------*/
   time_0.tv_sec = 0;
   time_0.tv_usec = 0;
/*     We're only interested in one socket Be careful if you have > 1 */
   read_mask = 1 << s;
   if ((connected == False) && (select(32, &read_mask, (int *) NULL,
      (int *) NULL, &time_0) > 0)) {
      if (domain_type == INET_DOMAIN) {
         len = sizeof(from_in);
         if ((g = accept(s, &from_in, &len)) < 0) {
            perror("Accept (INET)");
            connected = False;
            }
         else {
            (void) notify_set_input_func(me2, sock_io, g);
            connected = True;
            }
         }
                                                       /* Unix domain */
      else {
         len = sizeof(from);
         if ((g = accept(s, &from, &len)) < 0) {
            perror("Accept");
            connected = False;
            }
         else {
            (void) notify_set_input_func(me2, sock_io, g);
            connected = True;
            }
         }
     if (connected) {
        optlen = sizeof (Z_maxseg);
        if (getsockopt (g, IPPROTO_TCP, TCP_MAXSEG,
           (char *) &Z_maxseg, &optlen) < 0) {
           perror("TCP_MAXSEG get");
           Z_maxseg = 1024;
           }
        }
      }

   return (NOTIFY_DONE);
}

get_socket()
/*--------------------------------------------------------------------*/
/* Get a socket and bind it appropriately, if possible.  If the       */
/* environment variable TVDEV1 (currently hard coded!) is equal to    */
/* sssin:machine_name  (sssin is in /etc/services at #5000 in Toronto)*/
/* then it is assumed we are in the internet domain, otherwise it is  */
/* assumed to be the name of a unix-domain socket.                    */
/*                                                                    */
/* MRC 88/Sep/19: Modified to use TVDEV.                              */
/*--------------------------------------------------------------------*/
{
   char device[80];
/*--------------------------------------------------------------------*/
   server.sun_family = AF_UNIX;

   sprintf(device, "%s", getenv(getenv("TVDEV")));

                                               /* TVDEVn is undefined */
   if (strcmp(device, "(NULL)") == 0) {
      perror("get_socket getenv");
      return (-1);
      }
                                                       /* INET domain */
   if (strncmp(&device[0], "sssin",5)==0) {
      domain_type = INET_DOMAIN;
      if (strncmp(&device[0], "
         buffered = True;
      else
         buffered = False;
      if ((sp_in=getservbyname("sssin","tcp")) == NULL) {
         perror("SOCKET.C: sssin not a service\n");
         return (-1);
         }
      server_in.sin_port = sp_in->s_port;
      if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
         perror("get_socket socket (INET)");
         return (-1);
         }
      if (bind(s, (caddr_t)&server_in, sizeof(server_in)) < 0) {
         perror("get_socket bind error (INET)");
         return (-1);
         }
      }
                                                       /* UNIX domain */
   else {
      domain_type = UNIX_DOMAIN;
      buffered = False;
      if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
         perror("get_socket socket (UNIX)");
         return (-1);
         }
                                            /* Otherwise, open socket */
      unlink(device);                    /* first unlink if it exists */
      strcpy(server.sun_path, device);
      if (bind(s, &server, strlen(server.sun_path) + 2) < 0) {
         perror("get_socket bind error (UNIX)");
         return (-1);
         }
      }
                                           /* Queue up to 5 requests. */
   listen(s, 5);

    /* Set up the opcodes we want to buffer. Basically all the writes */
   if (buffered) {
      bufferop[CLEAR]=True;
      bufferop[VIEW]=True;
      bufferop[IMWRT]=True;
      bufferop[WLUT]=True;
      bufferop[WOFM]=True;
      bufferop[WCURS]=True;
      bufferop[GRAPH]=True;
      bufferop[SPLIT]=True;
      bufferop[WGRFX]=True;
      bufferop[WZOOM]=True;
      bufferop[WSCROL]=True;
      bufferop[WZSCR]=True;
      }

   return (0);
}

close_socket()
/*--------------------------------------------------------------------*/
/* Close and unlink the socket.                                       */
/*--------------------------------------------------------------------*/
{
   if (shutdown(s, 0) < 0) {
      perror("close_socket shutdown");
      return (-1);
      }
   if (close(s) < 0) {
      perror("close_socket close");
      return (-1);
      }
   if (domain_type == UNIX_DOMAIN)
      if (unlink(server.sun_path) < 0) {
         perror("close_socket unlink");
         return (-1);
         }

   return (0);
}
--XYZZY--
cat > sockxf.c << --XYZZY--
#include "header.h"

Notify_value sock_io(me, fd)
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) does IO on socket, reading from client, sending back*/
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* In a sense this is the programs "main loop". When there is input   */
/* from the client control passes here, the opcode is read, it is     */
/* acted upon, status is passed back to the client and control returns*/
/* to the windows.  We also take care of broken connections in here   */
/* (for now).                                                         */
/*                                                                    */
/* MRC 89/Jun/02: Added WGRFX, and RGRFX.                             */
/*--------------------------------------------------------------------*/
   int *me;
   int fd;
/*--------------------------------------------------------------------*/
{
                                    /* Flaky connection, get  another */
   if (sock_rcv(&op, dat, &ndata, buf) < 0) {
      shutdown(g, 0);
      close(g);
      connected = False;
      (void) notify_set_input_func(me, NOTIFY_FUNC_NULL, g);
      }
                                     /* Good conn, dispatch opcodes   */
   else {
      if (op == CLEAR) {
         if (SssDebug) fprintf (stderr, "CLEAR %d", dat[0]);
         status = screen_clear();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == VIEW) {
         if (SssDebug)
            fprintf (stderr, "VIEW %d", dat[0]);
         status = ViewData();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, " done\n");
         }
      else if (op == IMWRT) {
         status = imwrt();
         nwsd = 0;
         }
      else if (op == IMRD) {
         status = imrd(&nwsd);
         }
      else if (op == INTGT) {
         status = Interogate(&nwsd);
         }
      else if (op == WLUT) {
         if (SssDebug) fprintf (stderr, "WLUT %d", dat[3]);
         status = cmap_wlut();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == RLUT) {
         if (SssDebug) fprintf (stderr, "RLUT %d", dat[3]);
         status = cmap_rlut();
         nwsd = NCOLOUR;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == WOFM) {
         if (SssDebug) fprintf (stderr, "WOFM %d %d %d",
            dat[0], dat[1], dat[2]);
         status = cmap_wofm();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == ROFM) {
         if (SssDebug) fprintf (stderr, "ROFM %d %d %d",
            dat[0], dat[1], dat[2]);
         status = cmap_rofm();
         nwsd = NINTENS;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == GRAPH) {
         if (SssDebug) fprintf (stderr, "GRAPH %d %d",
            dat[0], dat[1]);
         status = cmap_graph();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == SPLIT) {
         if (SssDebug) fprintf (stderr, "SPLIT %d", dat[0]);
         status = cmap_split();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == WGRFX) {
         if (SssDebug) fprintf (stderr, "WGRFX %d", dat[0]);
         status = cmap_wgrfx();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == RGRFX) {
         if (SssDebug) fprintf (stderr, "RGRFX %d", dat[0]);
         status = cmap_rgrfx();
         nwsd = 3;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == RCURS) {
         status = cursor_position();
         nwsd = 2;
         }
      else if (op == RBUTT) {
         status = button_status();
         nwsd = 4;
         }
      else if (op == WCURS) {
         if (SssDebug) fprintf (stderr, "WCURS %d %d", dat[0], dat[1]);
         status = cursor_move();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == RCURB) {
         status = cursor_button();
         nwsd = 6;
         }
      else if (op == WZSCR) {
         if (SssDebug) fprintf (stderr, "WZSCR %d %d %d %d",
            dat[0], dat[1], dat[2], dat[3]);
         status = zoom();
         nwsd = 0;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == WINDO) {
         if (SssDebug) fprintf (stderr, "WINDO %d %d %d %d",
            dat[0], dat[1], dat[2], dat[3]);
         status = windo_status();
         nwsd = 4;
         if (SssDebug) fprintf (stderr, "  done\n");
         }
      else if (op == OPEN) {
         if (SssDebug) fprintf (stderr, "OPEN\n");
         status = 0;
         nwsd = 0;
         }
      else {
         if (SssDebug) fprintf (stderr, "Unknown op %d\n", op);
         status = -1;
         nwsd = 0;
         }

      sock_snd (&status, &nwsd, buf_out, &op);
      }

   return (NOTIFY_DONE);
}

sock_rcv (op, dat, ndata, buffer)
/*--------------------------------------------------------------------*/
/* gets opcode, number of words of data, and the data from the client */
/* (AIPS). The send/receive procedures are so simple that the client  */
/* and server shouldn't (?) be able to get out of sync, although at   */
/* some point I should add an out of band signal or at least a panel  */
/* item to reset the connection.                                      */
/* Outputs:                                                           */
/*    op      I*2      opcode from client                             */
/*    dat     I*2(4)   "always present" data                          */
/*    ndata   I*2      number of words of data                        */
/*    buffer  I(*)     buffer containing variable data, discard excess*/
/*--------------------------------------------------------------------*/
   short int *op, *dat, *ndata;
   unsigned char *buffer;
/*--------------------------------------------------------------------*/
{
   static int size_i2 = sizeof(short int);
   int bytes_togo, bytes_trans, ldata, lbytes;
   short int lbuf[6];
   unsigned char * abuf = (unsigned char *)lbuf;
/*--------------------------------------------------------------------*/
                             /* Read op, ndata, buffer in that order  */
                             /* hopefully  buffer is long enough.     */
   bytes_togo = 6 * size_i2;
   ldata = bytes_togo;
   while (bytes_togo > 0) {
      bytes_trans = read (g, (abuf+(ldata - bytes_togo)), bytes_togo);
      if (bytes_trans <= 0) {
         perror("sock_recv 4 read");
         return (-1);
         }
      bytes_togo -= bytes_trans;
      }
   *op = ntohs (lbuf[0]);
   *dat = ntohs (lbuf[1]);
   *(dat+1) = ntohs (lbuf[2]);
   *(dat+2) = ntohs (lbuf[3]);
   *(dat+3) = ntohs (lbuf[4]);
   *ndata = ntohs (lbuf[5]);
                     /* "Variable length" data is in bytes, not words */
                              /* always read an even number of bytes. */
   bytes_togo = *ndata + (*ndata)%2;
   ldata = bytes_togo;
   while (bytes_togo > 0) {
      lbytes = (bytes_togo > Z_maxseg) ? Z_maxseg : bytes_togo;
      bytes_trans = read (g, (buffer+(ldata - bytes_togo)), lbytes);
      if (bytes_trans <= 0) {
         perror("sock_recv 4 read");
         return (-1);
         }
      bytes_togo -= bytes_trans;
      }
   return (0);
}

sock_snd (istat, ndata, buffer, op)
/*--------------------------------------------------------------------*/
/* the obverse of sock_rcv.  It sends the status and ndata words of   */
/* status data in buffer to the client.                               */
/* Input:                                                             */
/*    istat  I*2      status to be returned to client (or print if    */
/*                    buffered op)                                    */
/*    ndata  I*2      number of words of data                         */
/*    buffer I*2(*)   buffer containing data.                         */
/*    op     I*2      the opcode that generated this send, needed to  */
/*                    see if this is a buffered opcode or not.        */
/*--------------------------------------------------------------------*/
   short int *istat, *ndata, *buffer, *op;
/*--------------------------------------------------------------------*/
{
   static int size_i2 = sizeof(short int);
   register int i, j;
   static short int packet[4096+2];
   int buflen, lbytes, nbytes, mbytes;
   unsigned char *pp;
/*--------------------------------------------------------------------*/
                                         /*Send return, unbuffered op */

   pp = (unsigned char *) packet;
   if (!bufferop[*op]) {
      packet[0] = htons (*istat);
      packet[1] = htons (*ndata);
      i = 2; j = 0;
      while (j < *ndata)
         packet[i++] = htons (buffer[j++]);
      buflen = (*ndata +  2) * size_i2;
      for (nbytes = buflen; nbytes > 0; nbytes -= mbytes) {
         lbytes = (nbytes > Z_maxseg) ? Z_maxseg : nbytes;
         mbytes = write (g, pp+(buflen-nbytes), lbytes);
         if (mbytes <= 0) {
            perror ("sss:sock_snd write ");
            return (-1);
            }
         }
      }
   else {
      if (*istat != 0){
         fprintf (stderr, "Buffered op %d, istat=%d\n",*op,*istat);
         }
      }

   return (0);
}
--XYZZY--
cat > sss.c << --XYZZY--
#include "header.h"

main (argc, argv)
/*--------------------------------------------------------------------*/
/*! SUN Screen Server main program: get socket, call window_start     */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/*   Main program, barely does anything                               */
/*--------------------------------------------------------------------*/
int argc;
char **argv;
/*--------------------------------------------------------------------*/
{
   int i;
/*--------------------------------------------------------------------*/
   sc_centre_x = SCREEN_WIDTH / 2 - 1;
   sc_centre_y = SCREEN_HEIGHT / 2 - 1;
   for (i = 0; i < NGREY; i++) {
      upleft_x[i] = 0;
      upleft_y[i] = 0;
      }
   upleft_mag = 1;
                                              /* Default, buffer none */
   for (i = 0; i < (NUMOP+1); i++)
      bufferop[i] = 0;
                                                   /* For I*2 returns */
   buf_out = (short int *)buf;
                                               /* get a socket to use */
   if (get_socket() != 0) {
      close_socket();
      exit(-1);
      }
   read_mask = 1 << s;                                  /* for select */
   connected = False;

   window_start (argc, argv);

}
--XYZZY--
cat > window.c << --XYZZY--
#include "header.h"
#include <math.h>
#define TEXT_FONT "/usr/lib/fonts/fixedwidthfonts/screen.r.14"
Pixfont *standard;

window_start (argc, argv)
/*--------------------------------------------------------------------*/
/*! (SUNView SSS) establishes AIPS TV window, watch points, starts it */
/*# TV-IO                                                             */
/*--------------------------------------------------------------------*/
/*;  Copyright (C) 1995, 1996                                         */
/*;  Associated Universities, Inc. Washington DC, USA.                */
/*;                                                                   */
/*;  This program is free software; you can redistribute it and/or    */
/*;  modify it under the terms of the GNU General Public License as   */
/*;  published by the Free Software Foundation; either version 2 of   */
/*;  the License, or (at your option) any later version.              */
/*;                                                                   */
/*;  This program is distributed in the hope that it will be useful,  */
/*;  but WITHOUT ANY WARRANTY; without even the implied warranty of   */
/*;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    */
/*;  GNU General Public License for more details.                     */
/*;                                                                   */
/*;  You should have received a copy of the GNU General Public        */
/*;  License along with this program; if not, write to the Free       */
/*;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,     */
/*;  MA 02139, USA.                                                   */
/*;                                                                   */
/*;  Correspondence concerning AIPS should be addressed as follows:   */
/*;         Internet email: aipsmail@nrao.edu.                        */
/*;         Postal address: AIPS Project Office                       */
/*;                         National Radio Astronomy Observatory      */
/*;                         520 Edgemont Road                         */
/*;                         Charlottesville, VA 22903-2475 USA        */
/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This subroutine starts up the SSS window, and sets up the notifier */
/* so that it handles i/o properly.                                   */
/*--------------------------------------------------------------------*/
int argc;
char *argv[];
/*--------------------------------------------------------------------*/
{
    void crscol();
    unsigned char *mypradd;
                              /* These two lines make a unique handle */
    static int my_client_object;
    static int *me = &my_client_object;

    register int i, j;
    int window_wid, window_hgt;
    double xx, yy, zz;

    static Notify_value get_client();
                                        /* Frame fore- and background */
                                        /* colours.                   */
    struct singlecolor fore, back;
    static short icon_image[] =
    {
#include "aips.icon"
    };
/*--------------------------------------------------------------------*/
   DEFINE_ICON_FROM_IMAGE (icon, icon_image);
/*   mpr_static(icon_pixrect, 64, 64, 1, &icon_image);                */
/*   SSS_icon = icon_create(ICON_IMAGE, &icon_pixrect, 0);            */

   standard = pf_open (TEXT_FONT);
   if (standard == NULL) exit (1);

                                        /* Redefine the frame fore-   */
                                        /* and background colours.    */
   back.red   = 175;
   back.green = 127;
   back.blue  = 175;
   fore.red   = 0;
   fore.green = 0;
   fore.blue  = 0;
   window_wid = 518 + SCREEN_XMARG;
   window_hgt = 518 + SCREEN_YMARG;
   frame = window_create (NULL, FRAME, FRAME_ICON, &icon,
      FRAME_BACKGROUND_COLOR, &back, FRAME_FOREGROUND_COLOR, &fore,
      WIN_WIDTH, window_wid, WIN_HEIGHT, window_hgt, FRAME_ARGS, argc,
      argv, WIN_ERROR_MSG, "window_start: can't create frame", 0);

   window_get (frame, WIN_HEIGHT, window_hgt, WIN_WIDTH, window_wid, 0);

   sc_centre_x = SCREEN_WIDTH / 2 - 1;
   sc_centre_y = SCREEN_HEIGHT / 2 - 1;
   cur_size = 0;
   cur_xcorn = 0;
   cur_ycorn = 0;
   cur_xsize = window_wid;
   cur_ysize = window_hgt;
   sc_width  = window_wid - SCREEN_XMARG;
   sc_height = window_hgt - SCREEN_YMARG;
   sc_width2 = sc_width / 2;
   sc_height2 = sc_height / 2;
   scrhold = numhold = uxe = uye = 0;
   uxs = SCREEN_WIDTH;
   uys = SCREEN_HEIGHT;
                                        /* Drop the panel in return   */
                                        /* for more screen area.      */
   canvas = window_create (frame, CANVAS, CANVAS_RETAINED, False,
      CANVAS_REPAINT_PROC, repaint_canvas,
      CANVAS_RESIZE_PROC, resize_canvas,
      CANVAS_FIXED_IMAGE, False,
      WIN_EVENT_PROC, handle_events,
      WIN_ERROR_MSG, "window_start: can't create canvas", 0);
                  /* Add an event for "dragging" to follow the cursor */
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, LOC_DRAG, 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, MS_LEFT, 0, 0);
            /* Add events for function key buttons as well (F1,2,3,4) */
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(2), 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(3), 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(4), 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(5), 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(6), 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(7), 0, 0);
   window_set (canvas, WIN_CONSUME_PICK_EVENTS, KEY_TOP(8), 0, 0);

                                               /* set memory pointers */
   mypradd = &mem_image[0][0][0];
   mem1_pr = mem_point (SCREEN_WIDTH, SCREEN_HEIGHT, NBITS, mypradd);
   if (NGREY > 1) {
      mypradd = &mem_image[1][0][0];
      mem2_pr = mem_point (SCREEN_WIDTH, SCREEN_HEIGHT, NBITS, mypradd);
      }
   if (NGREY > 2) {
      mypradd = &mem_image[2][0][0];
      mem3_pr = mem_point (SCREEN_WIDTH, SCREEN_HEIGHT, NBITS, mypradd);
      }
   if (NGREY > 3) {
      mypradd = &mem_image[3][0][0];
      mem4_pr = mem_point (SCREEN_WIDTH, SCREEN_HEIGHT, NBITS, mypradd);
      }
   mem_line_pr = mem_point (SCREEN_WIDTH, ZOOM_HARD, NBITS, mem_line);
   memg_pr = mem_point (SCREEN_WIDTH, SCREEN_WIDTH, NBITS, gph_image);
   mem_full_pr = mem_point (SCREEN_WIDTH, 1, NBITS, mem_full);
                                        /* Define default cursor and  */
                                        /* graphics colours.          */
    rgrfx[0] = 255;
    ggrfx[0] = 0;
    bgrfx[0] = 255;
    rgrfx[1] = 255;
    ggrfx[1] = 255;
    bgrfx[1] = 0;
    rgrfx[2] = 16;
    ggrfx[2] = 255;
    bgrfx[2] = 0;
    rgrfx[3] = 255;
    ggrfx[3] = 171;
    bgrfx[3] = 255;
    rgrfx[4] = 0;
    ggrfx[4] = 0;
    bgrfx[4] = 0;
/*                                      make cross colors             */
   crscol (rgrfx, rgcol);
   crscol (ggrfx, ggcol);
   crscol (bgrfx, bgcol);

                                 /* Start up the window with a linear */
                                 /* transfer function                 */

                                        /* set OFM, Gamma = 2.2       */
   yy = NINTENS - 1;
   zz = 1.0 / 2.2;
   for (i = 0; i < NINTENS; i++) {
      xx = i / yy;
      rofm[i] = gofm[i] = bofm[i] = yy * pow (xx, zz);
      }

   zz = NCOLOUR - 1;
   zz = yy / zz;
   for (i = 0; i < NVALUE; i++) {
      if (i < NCOLOUR) {
         rlut[0][i] = glut[0][i] = blut[0][i] = i * zz;
         if (NGREY > 1) {
            for (j = 1; j < NGREY; j++)
               rlut[j][i] = glut[j][i] = blut[j][i] = rlut[0][i];
            }
         red[i] = green[i] = blue[i] = rofm[rlut[0][i]];
         }
      else {
         red[i]   = rgcol[i-NCOLOUR];
         green[i] = ggcol[i-NCOLOUR];
         blue[i]  = bgcol[i-NCOLOUR];
         }
      }

                /*-   pw = (Pixwin *)window_get (canvas, WIN_PIXWIN); */
   pw = (Pixwin *) canvas_pixwin (canvas);
   pw_setcmsname (pw, "SSS_CM");
   pw_putcolormap (pw, 0, NVALUE, red, green, blue);
                                        /* graphics, channel 1 are on */
   rwgraph = 0;
   cur_chan = 1;
   SssDebug = False;
                           /* set up the timer for accept connections */
   accept_timer.it_interval.tv_usec = 500000;
   accept_timer.it_interval.tv_sec = 0;
   accept_timer.it_value.tv_sec = 0;
   accept_timer.it_value.tv_usec = 500000;

   (void) notify_set_itimer_func (me, get_client, ITIMER_REAL,
      &accept_timer, ITIMER_NULL);

                               /* Make them and stick until notified. */
   window_main_loop (frame);
}
--XYZZY--
