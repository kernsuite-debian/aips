$     ---- COMAP.001 ----
$-----------------------------------------------------------------------
$;  Copyright (C) 1995, 1997, 1999
$;  Associated Universities, Inc. Washington DC, USA.
$;
$;  This program is free software; you can redistribute it and/or
$;  modify it under the terms of the GNU General Public License as
$;  published by the Free Software Foundation; either version 2 of
$;  the License, or (at your option) any later version.
$;
$;  This program is distributed in the hope that it will be useful,
$;  but WITHOUT ANY WARRANTY; without even the implied warranty of
$;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
$;  GNU General Public License for more details.
$;
$;  You should have received a copy of the GNU General Public
$;  License along with this program; if not, write to the Free
$;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
$;  MA 02139, USA.
$;
$;  Correspondence concerning AIPS should be addressed as follows:
$;         Internet email: aipsmail@nrao.edu.
$;         Postal address: AIPS Project Office
$;                         National Radio Astronomy Observatory
$;                         520 Edgemont Road
$;                         Charlottesville, VA 22903-2475 USA
$-----------------------------------------------------------------------
$Automatic Mapping batch map making procedures
$Procedures search for a maximum in the field and shift
$the center of a high resolution map to the maximum.
$Procedures next self-calibrate the UV data and produce
$high dynamic range I Q and U images.
$BECAUSE of limited AIPS procedure space, comments are
$mostly outside the procedures.
$
$Glen Langston, MIT, MPIfR, NRL, and NRAO
$last editted by glen langston on 1993 April 6
RESTORE 0

$turn off messages for long procedures
MSGKILL TRUE
$Define variables
PROC DECLARE;SCALAR OKSCAL
SCALAR RACELL,DECELL,PIXSI,XAXIS,ISTOKE,INBX,II,IJ,IJK,IIM
SCALAR PEAK,NUMCC,NSCAL,SNVER,UVFREQ,CRP1,CRP2,UV0SEQ,BMSIZ
SCALAR UVDIS,MSCDIS,MADIS,UV0DIS,IN0DI,IN0SE,MSCSEQ,UVSEQ
SCALAR VIEW,OTIME,LOOP,CCFACT,UVLOW,UVMAX,X1,X2,Y1,Y2,XY,DXY
SCALAR BOXSI,PEEK1,PEEK2,RMS,LASTRMS,RMSFACT,RMSLIM,NOLDUV
SCALAR MNSIZ,MSOLIN,CSOLIN,NSOLIN,ZRMS,ZFLUX,PBIF,PEIF
SCALAR MNMAP,CLSAV,CLFLUX,CLIMIT,NUMVIS,NUMIF,NUMSTOK,NUMFREQ
SCALAR MGAIN,MNITER,MFLUX,MBMAJ,MBMIN,MBPA,MFACT,MPIXSI,MBOX
SCALAR DOAMP,MDOPOL,MDOTV,DOSTOP,DOZAP,DOINT,MDOINT,MDOALL,MNBOX
SCALAR PHASET,DOTKPL,NSIGMA,FGSIGMA,COTIME,VECRAT,DOPLT,SQNUM
SCALAR DONEG,CLSIGMA,DONOYES,DOPRT,DOGAUSS,DOSCLP,DODIV,DOPHS
SCALAR SCSEQ,SCDIS,ISFACT,SUMFLUX,DOPOINT,NVBPLT,NPLOT
SCALAR SNITER,SSOLIN,SCSNR,SCTIME,SNR
ARRAY  MUVRANG(2),MFLDSI(2,16),RMSBOX(4),SOLFAC(20),XYSIZE(2)
ARRAY  MRASHI(16),MDECSHI(16),MIMSIZ(2)
STRING*1 ASTOKE,BSTOKE(7),DSTOK
STRING*2 MUVWTFN
STRING*4 SCTYPE
STRING*6 MAPCLASS,MSCLASS,UVCLASS,UV0CLAS,IN0CL,STCLASS(7),SCLAS
STRING*6 MPCLSS(16),CCMCL
STRING*8 MAPKEY(3,7),INTASK;STRING*16 MSCNAM,UVNAM,MAPNAM,IN0NAM
STRING*50 OUTLIN,WEAKPEA,ENTBOX,GOODBX,NOBOX,TWOPEA,NOCLIP
STRING*53 POUNDS,BIGMAPA,BIGMAPB,ADJUSTV,MDLPNT,MDLIMG,MDLFST
STRING*53 STRNOYES
FIN

$gwt: sets the task name, goes and waits
PROC GWT(TASK);CATA;GO;WAIT;RET;FIN

$clrzap: clears the file status and zaps it
PROC CLRZAP;INP ZAP;CLRST;ZAP;RET;FIN

$gent: fix common spelling errors
PROC GENT(I);GETN(I);RET;FIN
PROC TYEP(I);TYPE I;RET;FIN

$thecat: utility for listing all files with same name
PROC THECAT; INTASK=TASK;TPUT ZAP
 INCL='';INS=0;INTY='';CATA;TGET ZAP;TASK=INTASK;RET;FIN

$gotxpl: Puts TXPL output in history and on CRT
$        plot on tty with no waiting. plot file is deleted
PROC GOTXPL;INS=0;INV=0;DOCRT=3;GWT('TXPL')
 IF (DOTKPL>0) THEN GWT('TKPL'); END
 IF (DOPRT>0) THEN DPARM=0;OUTFI='';GWT('LWPLA');END
 INEXT='PL';CLRST;IF(DOZAP>1)THEN EXTDES;END
RET;FIN

$typound: TYPE POUNDS to mark STEPS
POUNDS='#####################################################'
PROC PRPND;TYP POUND;RET;FIN

$head: Types next COMAP Step.
$      Pounds signs surround output
PROC HEAD(OUTLIN);PRPND;TYP '#',OUTLIN;PRPND;RET;FIN

$setmap: Set Name adverbs for Latest MAP
PROC SETMAP
 INN=MAPNA;INDI=MADI;INCL=MAPCL;INS=0;INTY='MA';RET;FIN

$setmod: Set Name of self cal input model
PROC SETMOD;IN2N=MSCNA;IN2D=MSCDI;IN2C=MSCLA;IN2S=MSCS;RET;FIN

$resetmap: ReSet Map Name adverbs to Inname
PROC RESETMAP;MAPNAM=INN;MADIS=INDI;MAPCL=INCL;RET;FIN

$setuvd: Set Name adverbs for input UV-Data
PROC SETUVD
 INN=UVNAM;INDI=UVDI;INCL=UVCL;INS=UVSE;INTY='UV';CLRST;RET;FIN

$getsize: return ra and dec size in pixels of current map
PROC GETSIZE;KEYW='NAXIS1';GETH;XYSIZ(1)=KEYV(1)
 KEYW='NAXIS2';GETH;XYSIZ(2)=KEYV(1);RET;FIN

$peakfnd: find peak in map
$ PEAK  - OUTPUT brightness of highest peak in the images
$ PIXXY - OUTPUT pixel containing highest peak
PROC PEAKFND;HEAD('FINDING PEAK')
 SETMAP;DOINV=0;BLC=0;TRC=0;IMST;PEAK=PIXV;RET;FIN

$getpeak: return PEAK value of the map
PROC GETPEAK; KEYW='DATAMAX';GETH;PEAK=KEYV(1);RET;FIN

$tvpix: procedure to load the central part of an image to
$       to the tv.
$ PEAK - Peak of image to be loaded
$ RMS  - Rms noise level of image to be loaded
PROC TVPIX(PEAK,RMS);PIXRA=-2*RMS,MIN(20*RMS,PEAK)
 GETSIZ;TXINC=XYSIZ(1)/512;TYINC=XYSIZ(2)/512;TVLOD;RET;FIN

$gettvb: Get TV box for MX; Asks the user for input clean boxes
$        The previous clean image is loaded on TV.
$        TV pixel range is set so that faint features are seen
$        User Fiddles the TV colors until satisfied.
$        Next user may quit or enter a number of clean boxes
$        Boxes are placed in the center of the screen
$DOINT   - IF > 0 then DO interactive setting of clean boxes.
$DOSTOP  - IF > 0 then DO stop map+self-cal loop
$RMS     - RMS Noise level of image.
$LASTRMS - Increase Last RMS to allow new boxes to be used.
ADJUSTV = 'ADJUST TV and INPUT CLEAN BOXES:'
NOBOX ='Enter  0 to Continue without stopping again:'
ENTBOX='Enter Number of Clean Boxes (<0 Means stop):'
GOODBX='Enter >0 to Continue (<0 = re-select boxs) :'
PROC GETTVB
 IF (DOINT>0&DOSTOP<0) THEN HEAD(ADJUSTV);TVIN;TVPIX(PEAK,RMS)
  TVFID;BOXSI=MNSIZ/5;NBOX=0;INBX=11
  WHILE (INBX<-10!INBX>10) TYP ENTBOX;TYP NOBOX;READ INBX;END
  IF (INBX<0) THEN GO AWAY; END
  IF (INBX>0) THEN INBX=MIN(MAX(INBX,1),10);NBOX=INBX
   FOR II=1:INBX
    IF (CLBOX(1,II)=0) THEN XY=II*3
     CLBOX(1,II)=XY+(XYSIZ(1)*.4); CLBOX(2,II)=XY+(XYSIZ(2)*.4)
     FOR IJ=1:2;CLBOX(IJ+2,II)=CLBOX(IJ,II)+BOXSI;END
    END;END; LASTRMS=2*LASTRMS
   REBOX;TYP GOODBX;TYP NOBOX;READ INBX
   IF (INBX<0) THEN REBOX;INBX=1;END
  END;END
 IF (INBX=0) THEN DOINT=-1;END;PIXRA=0
 IF (INBX<0) THEN HEAD('STOPPING SELF-CAL');DOSTOP=1;END
RET;FIN

$startmx: runs mx and cleans up files after mx has finished
$  All files (UVWORK, CLEAN and BEAM) are created on MADIS
$  UVWORK and BEAM are deleted.
$  Inname is reset to output map name
PROC STARTMX;SETUVD;CLR2N;CLRON;IN2DI=MADI;OUTD=MADI
 FACTOR=MFACT;GWT('MX');INS=0
 INCL='UVWORK';INTY='UV';INDI=OUTD;CLRZA
 INCL='?BM001'; INTY='MA';INDI=OUTD;CLRZA;SETMAP
RET;FIN

$setnear( BOXSI) : sets a box around PIXXY(1,2) location
$                  Limits box to within the image
$ PIXXY  - X and Y pixel number for box center
$ BOXSI  - radius of region to set blc and trc
$ XYSIZ  - size of image in pixels
PROC SETNEAR(BOXSI)
 BLC MAX(1,PIXX(1)-BOXSI),MAX(1,PIXX(2)-BOXSI);GETSIZE
 TRC MIN(XYSIZ(1),PIXX(1)+BOXSI),MIN(XYSIZ(2),PIXX(2)+BOXSI)
RET;FIN

$GETBOX  - Returns the rms inside a box at X,Y
$ BOXSI  - Radius of the box for statistics measurement
$ RMS    - OUTPUT RMS noise of box centered on X,Y
PROC GETBOX(X,Y,BOXSI,RMS)
 PIXXY=X,Y,0;SETNEAR(BOXSI);IMST;RMS=PIXSTD;RET;FIN

$GETRMS: Search four corners for second lowest RMS
$ More than one corner may have the source in it.
$ RMS   - OUTPUT average of middle 2 RMS values
$         RMSNOISE is put in map header.
$ X2, Y2- Scratch variables used nowhere else
PROC GETRMS(RMS); HEAD('FINDING RMS NOISE IN IMAGE')
 DOINV=-1;GETSIZ;BOXSI=XYSIZ(1)/10;XY=1.5*BOXSI
 GETBOX(XY,XY,BOXSI,RMSB(1));X2=XYSIZ(1)-XY
 GETBOX(X2,XY,BOXSI,RMSB(2));Y2=XYSIZ(2)-XY
 GETBOX(X2,Y2,BOXSI,RMSB(3));GETBOX(XY,Y2,BOXSI,RMSB(4))
 RMS=MAX(MIN(RMSB(1),RMSB(2)),MIN(RMSB(3),RMSB(4)))/2
 RMS=MIN(MAX(RMSB(1),RMSB(2)),MAX(RMSB(3),RMSB(4)))/2+RMS
 KEYWORD='RMSNOISE';KEYV=RMS,0;KEYTYP='R';PUTHEAD
 PRPND; TYP '# SOURCE ',INN,', RMS =',RMS,'#'; PRPND
RET;FIN

$calcshift: Set MX parameters to put map center on peak.
$           If map was shifted, add previous shift.
$ PIXXY(1) - INPUT Ra  Pixel location
$ PIXXY(2) - INPUT Dec Pixel location
$ X        - OUTPUT Ra  shift in arc seconds
$ Y        - OUTPUT Dec shift in arc seconds
PROC CALSHIFT
 KEYW='CDELT1';GETH;RACELL=KEYV(1)
 KEYW='CDELT2';GETH;DECELL=KEYV(1)
 KEYW='CRPIX1';GETH;CRP1=KEYV(1)
 KEYW='CRPIX2';GETH;CRP2=KEYV(1)
 X=((PIXX(1)-CRP1)*RACELL)*3600;RASHI=X,0
 Y=((PIXX(2)-CRP2)*DECELL)*3600;DECSH=Y,0
RET;FIN

$MIDSHIFT: locates the best shift location;
$          If first peak is 6 times noise, get position
$          if second peak > than 50 % of first and 7 RMS
$          then shifts between two peaks, if both peaks in view
$ VIEW      - Field of view of final image, shift between two
$             peaks must be smaller, or they both fall off map
$ RASHI(1)  - output shift in arc seconds.
$ DECSH(1)  - output shift in arc seconds.
TWOPEA ='# SHIFT: Shifting between two peaks'
PROC MIDSHIFT;DOINV=-1;PEAKFND;PEEK1=PEAK;X1=0;Y1=0;PRPND
 IF (PEEK1>6*RMS) THEN
  MAXFIT;CALSHI;X1=X;Y1=Y;DOINV=1;SETNEAR(12);IMST
  DOINV=0;PEEK2=PIXV;CALSHI;DXY=MAX(ABS(X1-X),ABS(Y1-Y))
  IF (PEEK2>MAX(PEEK1/2,SCSNR*RMS) & DXY<VIEW) THEN
   X1=(X1+X)/2;Y1=(Y1+Y)/2;FLDSI=0;MFLDSI=0; TYP TWOPEA
  END; END
 TYP '# SHIFT: DELTA RA  =',X1,' DEC =',Y1
 RASHI(1)=X1;DECSH(1)=Y1;PRPND
RET;FIN

$GETANT: Get Reference antenna if not already set
$ The reference antenna is put in header by UVPRM.
PROC GETANT(REFANT)
 IF (REFANT<1) THEN HEAD('GET REFERENCE ANTENNA')
  SETUVD; BPARM=0; DOPOL=0; INTY='UV'; GWT('UVPRM')
  KEYW='UVPREFAN';GETH;REFANT=KEYV(1)
 END
RET;FIN

$CLPIT: Remove wild points many sigma above mean
$ set clip flux limit based on number of vis and RMS
$ assume source is less than 90% polarized
$ Source Flux and RMS noise are read from UVDATA header
$ CLFLUX - Flux level to clip data
$ NUMVIS - Number of visiblities
$ ZFLUX  - Flux of source measured by UVPRM
$ ZRMS   - RMS noise of UVdata measured by UVPRM
PROC CLPIT; SETUVD;UVRA=MUVRA;ANTE=0;BASELI=0
 KEYW='UVPFLUX0';GETH;ZFLUX=KEYV(1)
 KEYW='UVPRMSF0';GETH;ZRMS =KEYV(1)
 IF (CLFLUX<=0) THEN CLFLUX=ZFLUX+(SQNUM*ZRMS);END
 APARM=CLFLUX,(CLFLUX*.9),(ZRMS/SQRT(NUMVI)),0
 IF (CLFLUX>CLIMIT) THEN PRPND
  TYP '# Clipping points brighter than ',CLFLUX,'#';PRPND
  CLRON; OUTD=MADIS; OUTCL='UVCLIP'; OUTS=0; GWT('CLIP')
  END
RET;FIN

$GETIT:  GET Number of clean ITerations
$ NITER   - Output Number of clean iterations in map
PROC GETIT;SETMAP;KEYW='NITER';GETH;NITER=KEYV(1);RET;FIN

$GETSEQ:  GET sequence number of file
PROC GETSEQ;INS=0;KEYW='IMSEQ';GETH;INS=KEYV(1);RET;FIN

$BPLT: Plot UV-data for baselines versus time
$ NVBPLT - Antenna number to include in plot of 5 baselines
$ UV-Data must be in TB order
PROC BPLT; KEYWOR='SORTORD'; GETHEAD
 IF (NVBPLT>0&KEYSTR='TB') THEN
  HEAD('Plotting baseline+model vs time')
  ANTENNA = REFANT,0;BASELI=1,2,3,4,5
  IF (NVBPLT>3&NVBPLT<>REFANT) THEN BASELI(5)=NVBPLT; END
  FOR I=1:5
   IF (BASELI(I)=REFANT) THEN BASELI(I)=6; END
  END
  SNITER=NITER; SSOLIN=SOLINT
  NITER=MNITER; SOLINT=MIN(OTIME/7,MAX(COTIME,OTIME/200))
  DOTV=0;BPARM=0;BPARM(8)=5;POLPLOT='';DOCAL=-1;SOURC=''
  SETUVD; SETMOD; GWT('VBPLT'); GOTXPL
  ANTENN=0;BASELI=0;SOLINT=SSOLIN;NITER=SNITER
 END
RET;FIN

$mamx: clean map, using dirty map to shift the phase center
$  PIXSI  - size of one pixel in arcseconds
$  FLUX   - cut off flux for clean
$  MUVRANG- Limit of UV range to use for deconvolution
$  RMS    - OUTPUT rms noise in map
PROC MAMX;HEAD('DE-CONVOLVING');SETUVD;UVRANG=MUVRA
 OUTD=MADIS;OUTN='';OUTS=0;CELLS=PIXSI;DOTV=MAX(MDOT-1,-1)
 QH;STARTMX;UVRANG=0;DOTV=-1
 GETPEAK;GETRMS(RMS);SNR=PEAK/MAX(RMS,1.E-10)
 IF (MDOT>0) THEN TVIN;TVPIX(PEAK,RMS);END
 INV=1;OUTV=1;GWT('CCMRG')
RET;FIN

$spltit: Copies a the self calibration SN table
$        to the 0th UV data and creates a self
$        calibrated version using SPLIT.
$ Input name should be last CALIB input UV-data.
$ Output is class, sequence of the
$ Self-calibrated Uvdata UVCLAS, UVSEQ
$ The input data is not deleted, but the SN table is.
PROC SPLTIT
 HEAD('Transfering Self-calibration solution')
 OUTCL=UVCLAS;OUTS=UVSE;OUTDI=UVDI;INTY='UV'
 INVER=0;NCOUNT=1;INEXT='SN';CLRST;GWT('TACOP')
 EXTDES
$ now apply SN table to original data
 SETUVD;OUTCL='SCAL';OUTS=0;DOCAL=1;DOUVCOMP=-1;CLRST
 APARM=0; CHANSEL=0; GWT('SPLIT')
 UVCL='SCAL';UVSE=0
 IF (DOZAP>0) THEN INCLAS='PHS-TB';INS=0;INDI=UVDI;CLRZAP;END
RET;FIN

$GETCC: find positive clean components for self-cal
$         Mapname is assumed to be correctly set.
$ NUMCC - Output Number of clean components brighter than
$         FACTOR times first negative flux
$ FLUX  - Output Sum of flux of first NUMCC clean components
$         CCFND passes the number of CCs found via MAP
$         header NTHCC.
PROC GETCC(NUMCC,FLUX); HEAD('SELECT CLEAN COMPONENTS')
 CCMCL=INCL
 FOR I=1:MAX(NFIELD,1)
  FLUX=0;FACTOR=CCFACT;ECOUNT=0;INV=1;OUTV=1
  INCL=MPCL(I);IF (I>1) THEN GWT('CCMRG'); END
  INV=0;OUTV=0;GWT('CCFND')
  KEYW='NTHCC';GETH;NCOMP(I)=KEYV(1)
  IF (I=1) THEN
   NUMCC=KEYV(1)
   KEYW='SUMFLUX';GETH;SUMFLUX=KEYV(1)
  END
 END
 FLUX=SUMFLUX;INCL=CCMCL
RET;FIN

$divit:  Does division of image model into uvdata.
$        produces a 'DIVIDE' uvdata set
$ NUMCC - Number of clean components to divid
$ DOGAUS- Convert clean compenents to gausian to smooth
$         Subtraction. (Experimental, not usually used)
$
PROC DIVIT; HEAD('DIVIDING Source model into UVDATA')
 IF (DOPOINT>0) THEN
    IN2N=''; IN2S=0; IN2CL='';SMODEL=ZFLUX,0;NUMCC=0
 ELSE
  IF (DOGAUS>0) THEN
   SETMAP;INVER=1;BMAJ=CELLS(1);BMIN=CELLS(2);BPA=0
   FACTOR=3.14159/1.1774
   INV=1;OUTV=2;GWT('CCGAU')
   BMAJ=MBMAJ;BMIN=MBMIN;BPA=MBPA;FACTOR=0
  END
  SETMOD; SMODEL=0
  IF (NUMCC>0) THEN
   TYP '# Number of Clean Components ',NUMCC
   NCOMP(1)=NUMCC
   ELSE TYP '#','Using All Clean Components'; NCOMP=0; END
  TYP POUNDS
 END
SETUVD
OPCOD='DIV'; CMOD='COMP';INVER=0; SMOOTH=3,0
CMETH='DFT'; FACTOR=0; BCOMP=0
APARM(2)=1;OUTCL='DIVIDE';OUTS=0;OUTN='';OUTDI=UVDI
GWT('UVSUB')
INCL=OUTCL;INS=OUTS;INDI=OUTDI; NCOMP=0; CMETH=''
IF (DOSCLP>0) THEN
 UVRA=0; BPARM=0; BPARM(8)=1; DOPOL=0; ANTE=0;BASELI=0
 GWT('UVPRM')
 KEYW='UVPFLUX0';GETH;ZFLUX=KEYV(1)
 KEYW='UVPRMSF0';GETH;ZRMS =KEYV(1)
 SNR=ZFLUX/ZRMS
 CLSIGMA=4*SQNUM*ZRMS;CLFLUX=ZFLUX+CLSIGMA
 APARM=CLFLUX,(CLFLUX*.9),MAX(ZFLUX-CLSIGMA,ZRMS/SQNUM),0
 CLRON; OUTD=MADIS; OUTCL='SUB-CL'; OUTS=0; GWT('CLIP')
 IF (DOZAP>0) THEN CLRZAP; END
 INCL=OUTCL;INS=OUTS;INDI=OUTDI
END
RET;FIN

$GETUVLOW: Find lower limit of UV data represented
$          by Clean components
$ FLUX - Input to UVPRM, is the brightness represented by
$          the image clean components.
$ UVLOW- Output Lower Limit of UV Range for self-cal (k-lambda)
$          limit uvlow to less than 25% of the UV range
PROC GETUVLOW(FLUX,UVLOW); DOCAL=-1; SETUVD
 UVRA=MUVRA;BPARM=0;BLVER=-1;SUBAR=0;GWT('UVPRM')
 KEYW='UVPFLMIN';GETH;UVLOW=KEYV(1)
 KEYW='UVPRAMAX';GETH;UVMAX=KEYV(1)
 UVLOW=MAX(MIN(UVMAX/4,UVLOW),UVMAX/50)/1000
RET;FIN

$phasit: Does coherence time averaging of input data
$        produces a coherence time averaged
$        UV-data set called 'PHS-TB'
$ NSIGMA - Number of sigma visabilities to flag.
$ COTIME - Timer interval to write out averaged data
$        Intermediate UV-data sets 'BT' and 'PHS-BT'
$        are created and deleted.
$ VECRAT - The Vector/Scalar Ratio used to determine
$        Coherence time
$ SOLINT - Output time average for self-calibration
$ PHASET - The minimum coherence time of the baselines
$ Outputs are the Class, Sequence and Disk of the
$ coherent averaged data set.
$ A side effect is that APARM is set.
$ The COTIME is also reset each execution.
PROC PHASIT(NSIGMA,SOLINT); FLUX=0
 INNA=MSCNA;INDI=MSCDI;INCLA=MSCLA;INSE=MSCS;INTY='MA'
 GETCC(NUMCC,FLUX);GETUVLOW(FLUX,UVLOW)
 IF (DOAMP>0 ! LOOP>NSCAL/2) THEN NUMCC=0;NCOMP=0;END
 IF (DODIV>0) THEN DIVIT; ELSE SETUVD; END
 IF (DOPHS>0) THEN
  HEAD('Coherence time smooth the uv-data')
  OUTCL='BT'; SORT 'BT'; ROTATE=0; OUTDI=UVDI; OUTS=0
  INS=0; GWT('UVSRT')
  IF (DOZAP>0) THEN CLRZAP; END
  INDI=OUTDI; INCL='BT'; OUTCL='PHS-BT'
  APARM=SCTIME,NSIGMA,0,VECRAT,1, 0,0,0,0,0
  IF (DOPOINT>0) THEN
   APARM(2)=2*APARM(2);APARM(4)=APARM(4)*.5; END
  INS=0; GWT('PHASE')
  IF (DOZAP>0) THEN CLRZAP; END
  INCL=OUTCL; KEYWOR='PHASETIM'; GETHEAD; PHASET=KEYVAL(1)
  COTIME=PHASET*24*60.
  OUTCL='PHS-TB'; OUTS=0; INS=0
  SORT='TB'; GWT('UVSRT'); KEYWOR=''; KEYSTR=''
  IF (DOZAP>0) THEN CLRZAP; END
  INCL='PHS-TB'; INDI=UVDI; INSEQ=0
 ELSE
  ISFACT=MIN(LOOP,NSOLIN)
  SOLINT=CSOLIN * SOLFA(ISFACT)
 END
RET; FINIS

$scalit: self calibrate UV file, using the clean image
$  NUMCC - number of clean components for model
$  UVLOW - lower limit of uvdata to self-calibrate
$  REFANT- reference antenna number
$  DOAMP - Do amplitude selfcalibration
$  SOLINT- Solution interval (min). Calculated from input
$          interval (CSOLIN) times a facter for each LOOP
$ CALIB APARM parameters are important for solution
$ quality: APARM(1) == Number of antennas for solution
$          APARM(3) >0 Average RR, LL data
$          APARM(5) >0 Average IFs
$          APARM(7) == SNR cutoff (default is 3)
$          APARM(9) >0 Pass Failed Solutions (Passing is
$                      a good idea for first few solutions)
$ avoid aliases on side lobes by varying cell size
$ do amp and phase self-cal only if requested
$ Major difficulty is calculating the solutoin interval
$ Attempt to find solution interval that gives SNR = 5
$ or the COherence TIME of the data.
PROC SCALIT;SETUVD
 SOLMOD='P';NMAP=NFIELD;UVRANGE=UVLOW,1E12;SOLCON=0;INEXT=''
 SNVER=0;XINC=0;CALSOUR='';SUBAR=0;SMOOTH=0;INVER=0
 SOLINT=COTIME*SOLFA(MIN(MAX(1,LOOP),10))
 IF (SNR>5) THEN SOLINT=MAX(OTIME/SQRT(SNR),COTIME); END
 IF (SNR>50) THEN SOLINT=SOLINT/SQRT(SNR-49); END
 SOLINT=MAX(SOLINT,CSOLIN)
 IF (DOPOINT>0) THEN SOLINT=SCTIME
  ELSE  PHASIT(FGSIGMA,SOLINT); END
 ANTWT=0;GAINERR=0;APARM=3,0,0,0,0, 0,3,0,1,0;CPARM=0,1,0
 IF (DODIV>0&DOPOINT<=0) THEN APARM(2)=1;END
 SOLTYP=SCTYPE
 IF (PEAK<MDOALL*RMS) THEN
  APARM(5)=MIN(NUMIF-1,1);APARM(3)=MIN(NUMSTO-1,1)
 ELSE
  IF (LOOP>0.75*NSCAL&DOALL>0) THEN DOAMP=DOAMP+1; END
 END
 IF (DOAMP>0&(PEAK>MDOALL*RMS)&DOALL>0) THEN
  SOLMOD='A&P'; SCTYPE=''; APARM(1)=4; APARM(7)=7
  SOLINT=MAX(COTIME,OTIME/3)*SOLFA(DOAMP)
  END
 HEAD('SELF-CALIBRATE UV-DATA')
 CLRON; OUTDI=UVDI; OUTCL='SCAL0'
 SCLAS=INCLAS; SCSEQ=INS; SCDIS=INDIS
 IF (DODIV<=0) THEN
  IF (NUMCC>0) THEN TYP '#','Number of Clean Components',NUMCC
  ELSE TYP '#','Using All Clean Components';END
  SETMOD
 END
 IF (LOOP>NSCAL/2) THEN APARM(9)=0; END
 SOLINT=MIN(SOLINT,SCTIME)
 TYP '# Reference Antenna    ',REFANT
 TYP '# UV Minimum (K-lambda)',UVLOW
 TYP '# Averaging Time (min) ',SOLINT
 TYP '# Solution Mode        ',SOLMOD; PRPND
 SMOOTH=1,0; OUTCL='SCAL0';INVER=0;DOCAL=-1;DOFIT=0
 GWT('CALIB')
 INS=0;INVER=0;XAXIS=0;NCOUNT=0;PIXRA=0;INEXT='SN'
 OPTYP='SUM';GWT('SNPLT');GOTXPL;OPTYP=''
 IF (DODIV<=0 ! DOPOINT>0) THEN
  INCLA=OUTCL;INDI=OUTDI;INS=OUTS
  OUTCL='SCAL';OUTS=0;RENAM
  UVCLA=OUTCL
 ELSE
  SPLTIT
 END
RET;FIN

$PLOTIT: Plot UV data vs Antenna Spacings
$        set XINC to plot only 2000 points
$ NUMVIS - Input Number of visibilities in UV data set
$ Two plots are made for each IF,
$  1) amplitude vs baseline length and 2) amplitude vs time
PROC PLOTIT;SETUVD;PBIF=MIN(BIF,NUMIF);PEIF=EIF
 IF (PEIF<BIF!PEIF<=0) THEN PEIF=NUMIF;END
 IF (DOPLT>0) THEN
  FOR BIF=MAX(1,PBIF):MAX(1,PEIF);BPARM=0;BPARM(8)=250
   PRPND;TYP '# Plotting UV-data for IF Number',BIF,'#';PRPND
   XINC=0;TIMER=0;INV=0;DOPOL=0;DOCAL=-1;SUBAR=0;SOURC=''
   FACTOR=0;GWT('UVPLT');GOTXPL;XINC=MAX(1,NUMVIS/2E3);BPARM=11,0
   GWT('UVPLT');GOTXPL;XINC=0;BPARM=0
  END; END; BIF=PBIF
RET;FIN

$GETPIX: Read Min and max UV range and observing duration
$ PIXSI - Pixel size in arc seconds, calculated if not set
$ UVMAX - OUTPUT maximum uvrange of input data (in lambda)
$ OTIME - OUTPUT duration of observation in minutes.
$         Time is converted from days to minutes
$ Task UVPRM finds the Min and Max Uvrange, within input
$      UVRANGE; UVPRM results are passed in Keywords
PROC GETPIX; HEAD('Finding Min and Max UV-Range')
 SETUVD;UVRA=MUVRA;BPARM=0;DOPOL=0;GWT('UVPRM')
 IF (MUVRA(2)>0) THEN UVMAX=MUVRA(2)*1000
 ELSE KEYW='UVPRAMAX'; GETH; UVMAX=KEYV(1); END
 PRPND; KEYW='UVPOTIME'; GETH; OTIME=KEYV(1)*1440
 TYP '# DURATION OF OBSERVATION  (MIN): ',OTIME,'#'
 TYP '# MAXIMUM UV RANGE (KILO-LAMBDA): ',CEIL(UVMAX/1E3),'#'
 IF (PIXSI<=0) THEN PIXSI=2.06E5/(3.5*UVMAX); END
 TYP '# PIXEL SIZE       (arc seconds): ',PIXSI,'#'
RET;FIN

$getaxis: determine whether data are compressed and
$         find number of stokes parameters and IFs
$         if COMPLEX axis size is not 3,
$         then then data are compressed.
PROC GETAXIS; KEYW='GCOUNT';GETH;NUMVIS=KEYV(1)
 KEYW='NAXIS';GETH;NAXIS=KEYV(1);NUMSTO=0;NUMIF=0;NUMFRE=0
 FOR I = 1 TO NAXIS
  KEYW=MAPKEY(1,I); GETH; KEYW=MAPKEY(2,I); GETH
  IF (KEYSTR='STOKES') THEN NUMSTO=KEYV(1);END
  IF (KEYSTR='IF') THEN NUMIF=KEYV(1);END
  IF (KEYSTR='FREQ') THEN
   NUMFRE=KEYV(1);KEYW=MAPKEY(3,I);GETH;UVFREQ=KEYV(1)
  END; END
SQNUM=SQRT(NUMVI)
RET;FIN

$print yes or no answers to options
PROC NOYES(DONOYES,STRNOYES)
 IF (DONOYES>0) THEN
  TYPE '#   ',STRNOYES
 ELSE
  TYPE '# NO',STRNOYES
 END
RET;FIN

$DOLOG:  Log user inputs
PROC DOLOG
 TYPE POUNDS
 NOYES(DOALL, 'AMPLITUDE SELF CAL')
 NOYES(DODIV, 'Dividing uvdata by Model before coherence test')
 NOYES(DOPHS, 'Coherence time averaging of data before self-cal')
 NOYES(DOGAUS,'Converting Point components to gaussians')
 NOYES(DOSCLP,'Clipping UV-data after model division')
 NOYES(DONEG, 'Stoping at negative/small clean components')
 NOYES(MDOPOL,'POLARIZATION IMAGING')
 NOYES(DOZAP ,'ZAPPING OF bad UV-data/Images')
 NOYES(MDOTV ,'Displaying intermediate images on TV')
 NOYES(DOINT ,'Interactive setting of clean boxes')
 NOYES(DOPLT ,'Plotting uvdata')
 NOYES(DOPRT ,'Printing copies of plots')
 NOYES(DOTKPL,'Plotting on tektronix server ')
 NOYES(NVBPLT,'Plotting Baselines+model vs time')
 TYPE POUNDS
RET; FIN

$CHECKIN: Check User input via COMAP.HLP
$ parameters are stored for latter re-use
$  UVNAM =INNAM - Input UVdata
$  MSCNAM=IN2NA - Model Self Cal Image (for restarting)
$  MAPNAM       - Output Image name
$  NSCAL =NMAPS - Number of self calibration loops
$  The "M" ADVERBS are used to recored the COMAP inputs
PROC CHECKIN; CLRMSG; HEAD('CHECKING INPUT'); MSOLI=SOLIN
 NUMVIS=1;KEYV=1;UVMAX=1;LOOP=-1;NSCAL=1;UVFREQ=22E9
 PRTAS=''; PRNU=0; INP COMAP_NA; INP COMAP_UV; INP COMAP_MX
 TPUT COMAP; TPUT COMAP_MX; TPUT COMAP_DO
 PIXSI=CELLS(1);CSOLIN=SOLINT;PHAT=0;XTYPE=0;YTYPE=0
 IN0CL=INCL;IN0S=0;IN0DI=INDI;IN0N=INN;SUBAR=0;BCOM=0;DOAMP=0
 MDOT=DOTV;MFACT=FACTOR;IF(MFACT>.5) THEN MFACT=-.1;END
 MUVWTFN=UVWTFN;MNMAP=NMAP;GAINU=0;OKSCAL=-1;CMETH=''
 MFLUX=FLUX;MNIT=NITER;MGAIN=GAIN;MDOPOL=DOPOL;MBOX=NBOX
 MBMAJ=BMAJ;MBMIN=BMIN;MBPA=BPA;MUVRA=UVRANG;MFLDSI=FLDSI
 MRASHI=RASHI;MDECSHI=DECSHI;DOTV=-1;DOCAL=-1;MIMSIZ=IMSIZ
 CLSAV=CUTOF;CLFLU=CUTOF;CUTOF=0;DOBAN=-1;DOPOL=-1;DOSTOP=-1
 ANTENN=0;BASELI=0;NSCAL=NMAP; IF (NMAP=0) THEN NSCAL=3; END
 MDOALL=DOALL; IF (MDOALL<5) THEN MDOALL=30; END
 RMS=1E-9; PEAK=10*RMS; PIXV=RMS; LASTRMS=RMS/2; PIXSTD=RMS
 UVNAM=INN;UVCLAS=INCL;UVSEQ=INS;UVDI=MAX(INDI,1)
 UV0CL=INCL;UV0SE=INS;MAPNAM=INN;MAPCL='ICL001';MADIS=OUTD
 MSCNA=IN2N;MSCLAS=IN2CLA;MSCSE=IN2S;MSCD=IN2DI
 CLRON; OUTDI=MADIS; ASTOK=SUBSTR(STOKES,1,1)
 FOR I=1 TO 7; IF (ASTOK=BSTOKE(I)) THEN ISTOK=I; END; END
 IF (ISTOK=7) THEN DSTOK=BSTOKE(1);ELSE;DSTOK=ASTOK;END
 IF (ISTOK=2!ISTOK=3) THEN ISTOK=1;END; MAPCL=STCLA(ISTOK)
 STOKES=BSTOK(ISTOK); IF (MADIS<=0) THEN MADIS=INDI;END
 IF (NFIELD<0) THEN NFIELD=1; END
 IF (NFIELD>1) THEN
  FOR I=2:NFIELD;SUBSTR(MPCLS(I),1,1)=DSTOK;END
 END
 IF (MNIT<=0) THEN MNIT=1000;END
 IF (MGAI<=0) THEN MGAI=0.05;END
$ get UV par
 GETAXIS; GETPIX; BMSIZ=FLOOR((2.7E12/UVFREQ)/PIXSI)
 TYP '# VLA Primary beam (FWHM pixels): ',BMSIZ,'#'
 IF (IMSIZ(1)<=7) THEN
  IMSIZ=MIN(2**CEIL(LN(BMSIZ)/LN(2)),512); END
 MNSIZ=MIN(IMSIZ(1),IMSIZ(2))
 TYP '# Image size            (pixels): ',MNSIZ,'#'
 PRPND; VIEW=IMSIZ(1)*PIXSI*.95; MPIXS=PIXSI
 IF (CSOLI<=0) THEN CSOLI = MIN((OTIME+.5)/2,0.5); END
 TYP '# Self-Calibrate if Signal/Noise >',SCSNR,'#'
 IF (DOALL>0) THEN
  TYP '# Ampl. Self-cal if Signal/Noise >',MDOALL,'#';END
RET;FIN

$RECHECK: Reset a few adverbs to the input values
PROC RECHECK; RASH=MRASH;DECSH=MDECSH;NMAP=MNMAP
 FLUX=MFLUX;NITER=MNIT;GAIN=MGAIN;DOPOL=MDOPOL;IMSIZ=MIMSIZ
 BMAJ=MBMAJ;BMIN=MBMIN;BPA=MBPA;SOLINT=MSOLI;NBOX=MBOX
 UVRANG=MUVRA;FLDSI=MFLDS;DOTV=MDOT;FACTO=MFACT;SETMOD
 UVWTFN=MUVWT;CUTOF=CLSAV;DOINT=MDOIN
 INN=IN0N;INDI=IN0DI;INCL=IN0CL;INS=IN0S
RET;FIN

$GETSHIFT: Get ra and dec shift if requested.
$          Modifies MX inputs for a large field of view
$          First makes a map of large region around
$          the center of the observation. ONLY SHIFTS IF peak
$          is brighter than SCSNR times noise.
$ DOCENTER - If true find RASHIFT and DECSHIFT
BIGMAPA='# Making an Image with a large pixel size.  Peak in'
BIGMAPB='# next Image will be the center of de-convolutions'
PROC GETSHIFT
 IF (DOCENTER>0) THEN HEAD('CENTER MAP ON SOURCE')
  TYP BIGMAPA;TYP BIGMAPB;NITER=15;UVWTFN='NA';NBOX=0
  GAIN=.333;BMAJ=0;BMIN=0;FLDSI=0;PIXSI=2*PIXSI;MAMX;NBOX=MBOX
  PRPND; TYP '# SOURCE ',INN,', PEAK=',PEAK,'#';PRPND
  IF (PEAK>RMS*SCSNR) THEN MIDSHIFT;CLRZAP;END
  GAIN=MGAIN;UVWTFN=MUVWTFN;PIXSI=MPIXS
  BMAJ=MBMAJ; BMIN=MBMIN;FLDSI=MFLDSI
 END
RET;FIN

$DELMAPS: Delete multi-field MX CLEAN maps
$ MAP NAME, CLASS and SEQUENCE are assumed correct
$ First MAP is deleted and other fields if they exist
PROC DELMAPS; CLRZAP
 IF (NFIELD > 1 & INS>0) THEN
  FOR I = 2 TO NFIELD;INCL='?CL001';CLRZAP;END;  END
RET;FIN

$DELAST:  Delete last map and self calibration
PROC DELAST; HEAD('SOLUTION NOT IMPROVING, DELETING')
 SETMAP;GETSEQ;IF (INS>1) THEN DELMAPS;END
 SETUVD;INCL='SCAL';GETSEQ;IF (INS>1) THEN CLRZAP;END;INS=0
 SCTYPE=''
RET;FIN

$DELPRE: Delete Previous map and self calibration
$ DOZAP: if true, delete, else save for diagnostics
$ LOOP : Only Delete self-cal after first loop
PROC DELPRE(LOOP); HEAD('SOLUTION IMPROVED')
 IF (DOZAP>0) THEN HEAD('DELETING PREVIOUS');SETMAP
  GETSEQ;IF (INS>1) THEN INS=INS-1;DELMAPS;END
  SETUVD;IF (OKSCAL>0) THEN INCL='SCAL';GETSEQ;END
  IF (INS>1&LOOP>1) THEN INS=INS-1;CLRZ;END;INS=0
  END
RET;FIN

$POLARIT - creats I, Q and U maps and combines to make a plot
$  DOPOL - >0: make polarization plots.
$      Polarization maps do not require much cleaning,
$      so the number of iterations is one quarter of ICLN.
PROC POLARIT; GETPEA
 IF ((DOPOL>0)&(PEAK>MDOALL*RMS)) THEN FACTOR=MFACT
  HEAD('Q and U IMAGES');ZEROSP=0;FLUX=MAX(0,MFLUX)
  NITER=MNITER/4;STOKES='Q';MAMX;STOKES='U';MAMX;STOKE=''
  END
RET;FIN

$GETSCAL: Determine parameters for self-calibration
$         After first third of self-calibration passes,
$         use previously self-calibrated data for next
$         self-calibration.  (Input Image name must be set)
$ NUMCC - Number of clean components in model
$ UVLOW - Lower limit of UV range to self-calibrate
$ NSCAL - Number of self-calibration loops
$ FLUX  - Brightness containined in clean component model
$ NOLDUV- Number of loops to use original UV data for self cal
PROC GETSCAL;
  IF (LOOP<MAX(NSCAL/3,NOLDUV+1)) THEN
   UVCLAS=UV0CLAS; UVSEQ=UV0SEQ; END
  SMODEL=0;IN2N=INN;IN2CL=INCL;IN2S=INS;IN2DI=INDI
  INTY='UV';
SCALIT
RET;FIN

$PSCAL: Point Source Model Self CALibration
$ZFLUX - Estimated point source model Flux
$       Source is assumed to be at the phase center
PROC PSCAL
 CLR2N;IN2DI=INDI
 GETUVLOW(ZFLUX,UVLOW)
 DOPOINT=1; SCALIT; DOPOINT=-1
RET;FIN

$GETMOD: Get model image for first self calibration
$ MSCNAM - Model Self Cal image name (IN2Name set by SETMOD)
$          If the model name is set, restart with model
$        - The next map set will use UVCLAS for imaging
MDLPNT='Starting Self-Cal with POINT MODEL'
MDLIMG='Starting Self-Cal with Input Image'
MDLFST='Creating Image for First Self-Calibration Loop'
PROC GETMOD; LOOP=0; DOPOINT=-1
 IF (MSCNAM<>'') THEN
  IF (MSCNAM='POINT') THEN HEAD(MDLPNT);PSCAL
  ELSE
   HEAD(MDLIMG);INN=MSCNA;INCL=MSCLA;INS=MSCS;INDI=MSCD
   GETRMS(RMS); GETSCAL;SETMAP;GETPEA
  END;
 END
 FLUX=MFLUX
 IF(NSCAL>0)THEN
  HEAD(MDLFST);IF(DONEG>0)THEN FLU=-1;END
  NITE=MNIT;MAMX
 END
 IF (DOINT>0) THEN GETTVB;SETMAP;DELMAPS;MAMX;END
 GETPEA;LASTRMS=RMS
$ from now on, model is output clean image
 MSCNA=MAPNA;MSCLA=MAPCL;MSCS=0;MSCDI=MADI
RET;FIN

$MAPLOOP: Inner Deconvolution and Self-calibration loop.
$         Amplitude self-cal is done on 80 % of cycles.
$         Loop executes only if noise is getting smaller.
$         Shifts phase center again after first pass.
$ LOOP  - Execution number
$ NSCAL - Maximum number of self calibration executions
$ MFLUX - for all but last loop, clean only to first negative
$         source model component
$         Loop stops executing when RMS is significantly worse
$         Than previous execution. setting RMS=LASTRMS allows
$         another try with different Self-Cal parameters
$ PIXSI - Cell Size of image
$ DOSTOP- STOP executing loop
$ The GO STOP line causes the procedures to stop.
WEAKPEA='PEAK TOO FAINT TO SELF-CALIBRATE'
PROC MAPLOOP(LOOP); RMSLIM=RMSFAC*LASTRMS; PIXSI=MPIXS
 IF ((DOSTOP<=0)&(RMS<=RMSLIM)&(LOOP<=NSCAL)) THEN
  PRPND; PRINT '# LOOP ',LOOP,' OF ',NSCAL,'#';PRPND;SETMAP
  IF (PEAK<SCSNR*RMS) THEN DOSTOP=1;HEAD(WEAKPEA)
  ELSE GETSCAL;SETMAP;GETTVB
   IF (LOOP<NSCAL&DOSTOP<=0) THEN
    IF (DONEG>0) THEN
     IF (LOOP>NSCAL/2) THEN FLUX=-500; ELSE FLUX=-1; END
    ELSE FLUX=MFLUX; END
    MAMX;BPLT;SETMAP
$   if rms worse, delete; then do amp s-cal or stop
    IF (RMS>RMSLIM) THEN DELAST
     IF (DOAMP<=0&DOALL>0) THEN
      DOAMP=1;RMS=LASTRMS
     ELSE
      GO STOP
     END
    ELSE OKSCAL=1
     IF (DOCENTER>0) THEN MIDSHIFT;END;DELPRE(LOOP)
   END; END; END; END
 LASTRMS=MIN(LASTRMS,RMS)
RET;FIN

$COMAP: Main procedure for mapping and self-calibration
$ Inputs to COMAP are set with the COMAP Help file
$ i.e. INPUT COMAP
$    The self calibration loop continues only if peak is
$    seven times the noise level.
$ COMAP first attemps self-calibration based on the Fourier
$       Transform (FT) of the UV data.  If the FT fails, a
$       point source model is used for self-calibration.
$ Self Cal only if noise greater than SCSNR time RMS
PROC COMAP
  CHECKIN; DOLOG; CLPIT
  UV0CLAS=OUTCL;UVCL=OUTCL;UVDI=MADIS;UVSE=0;UV0SE=0;SETUVD
  PLOTIT
$ ref ant, shift center, 1st s-cal
  GETANT(REFANT); GETSHIFT; GETMOD
$ If Self-calibrating
  IF (NSCAL>0) THEN FOR LOOP=1:NSCAL;MAPLOOP(LOOP);END;END
  DOPOL=MDOPOL;POLARIT;OUTS=0
$ final clean, clean-up
  FLUX=MFLUX;NITER=MNIT;MAMX
  IF (RMS<LASTRMS*RMSFAC) THEN DELPRE(NSCAL);END
$  IF (DOZAP>2&OKSCAL>0) THEN SETUVD;INCL='SCAL';CLRZ;END
  HEAD('DONE WITH SOURCE ==> '!!INNA); RECHECK
RET;FIN

$ reset COMAP inputs to previous execution
PROC REMEMBER
 TGET COMAP_MX; TGET COMAP_DO; TGET COMAP
RET;FIN

$map parameters
XYSIZ=512; MGAIN=0.1; GAIN=MGAIN;ZEROSP=0; UVBOX=0
UVWTFN=''
DOCENTER = -1; DOPOL = -1; DOALL = -1
NUMVIS=1; LASTRMS=0.5; RMS=1; KEYV=1,1; ZRMS=1; PEAK=RMS
UVMAX=1; LOOP=1; NSCAL=1; PIXSI=1; UVFREQ=22E9; PIXV=PEAK

$FACTOR determines MX minor cycle clean stopping point.
$       a small value stops clean just before reaching
$       side-lobe level (FACTOR=0 => stop at level)
$       FACTOR=-1 => one component per minor cycle. (slow)
FACTOR=-.1
MINPATCH=150
UVWTFN='NA'

$DOINT:   Do interactive set of boxes before MX
DOINT=-1
$DOPLT:   Do ploting of UVdata.
DOPLT=1
$DOGAUS:  Convert clean components to gaussians
DOGAUS=-1
$DOSCLP:  Clip uv-data after model division
DOSCLP=-1
$DOPRT:   print out copies of plots
DOPRT=-1
$ stop at first negative during clean
DONEG=1
$ do coherence time averaging
DOPHS=1
$ do division before calibration/coherence averaing
DODIV=1
$ do plot on tektronix terminal
DOTKPL=1
$ do show image after clean (but not during clean)
DOTV=1
$ do zap intermediate files
DOZAP=1
$DOSTOP:  Flag to stop self-cal + image loop
$DOSTOP is only true if set during interactive mode
DOSTOP=-1

DOCRT=-1; PRNU=-1; INEXT='PL'; NVBPLT=1

$RMSFAC is the rms noise factor for stopping the MAPLOOP
$RMSFAC if RMS is less than RMSFAC*LASTRMS the loop continues
$RMSFAC > 1 implies solution is allowed to get a little worse.
$       before the solution improves
RMSFAC=1.2
$CLIMIT is minimum source flux for CLIP
CLIMIT=0.04

$CCFACT determines the CC components to include in SCAL
$       model.
CCFACT=2

$Self-Calibration solution interval Factor Defaults
FOR I=1 TO 20; SOLFA(I) = 1/I; END

$"Tuned" Self-Calibration Solution Interval Factors
NSOLIN=10
SOLFA(1)=1  ;SOLFA(2)=3/4;SOLFA(3)=2/3;SOLFA(4)=1/2;
SOLFA(5)=1/3;SOLFA(6)=1/4;SOLFA(7)=1/5;SOLFA(8)=1/6;
SOLFA(9)=1/8;SOLFA(10)=1/10

$sctype is the self cal solution type used in comap.
$ SCTYPE='L1' or SCTYPE=''
$Self-Cal minimum Signal to Noise ratio
SCSNR=8
$Self-Cal Maximum Averaging time (minutes)
SCTIME=15

$nolduv is number of loops to use orginal UVdata for self-cal
$after NOLDUV self-cals, the previous self-cal output is used as
$input to the next self-cal input.
NOLDUV=2

$general parameters
$ set keywords used to read map and uvdata headers
FOR I = 1 TO 7; MAPKEY(1,I)='CTYPE'!!CHAR(I);END
FOR I = 1 TO 7; MAPKEY(2,I)='NAXIS'!!CHAR(I);END
FOR I = 1 TO 7; MAPKEY(3,I)='CRVAL'!!CHAR(I);END

$ set stokes clean classes
BSTOKE= 'I','Q','U','V','L','R',' '
FOR I = 1 TO 6; STCLASS(I)=BSTOKE(I)!!'CL001';END
$default stokes is I
STCLASS(7) = 'ICL001'
MPCLSS(1) = 'ICL001'
MPCLSS(2) = 'ICL002'
$Set map classes for fields > 2
FOR I =3:10;MPCLS(I)=MPCLS(2);SUBSTR(MPCLS(I),6,6)=CHAR(I-1);END
FOR I =11:16;MPCL(I)=MPCLS(2);SUBSTR(MPCLS(I),5,6)=CHAR(I-1);END

$PHASE optimizations
FGSIGMA=3
VECRAT=.9

$clear messages
CLRMSG

$save for quick recovery
SAVE COMAP
$turn on the message file
MSGKILL FALSE

$To execute COMAP:
$ set INDISK, and the NAME of the INPUT UV data set.
$ set OUTDISK and BADDISK to speed execution.
$ TYPE:
$       COMAP
$ to start execution

$restore previous parameters
$(FOLLOWING STEP WILL NOT WORK ON FIRST EXECUTION !!)
$(BUT DO NOT WORRY ABOUT IT !?!)
REMEMBER

$save again for quick recovery
SAVE COMAP

