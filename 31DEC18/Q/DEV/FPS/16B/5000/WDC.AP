         $LIB
"-----------------------------------------------------------------------
";  Copyright (C) 1995
";  Associated Universities, Inc. Washington DC, USA.
";
";  This program is free software; you can redistribute it and/or
";  modify it under the terms of the GNU General Public License as
";  published by the Free Software Foundation; either version 2 of
";  the License, or (at your option) any later version.
";
";  This program is distributed in the hope that it will be useful,
";  but WITHOUT ANY WARRANTY; without even the implied warranty of
";  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
";  GNU General Public License for more details.
";
";  You should have received a copy of the GNU General Public
";  License along with this program; if not, write to the Free
";  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
";  MA 02139, USA.
";
";  Correspondence concerning AIPS should be addressed as follows:
";         Internet email: aipsmail@nrao.edu.
";         Postal address: AIPS Project Office
";                         National Radio Astronomy Observatory
";                         520 Edgemont Road
";                         Charlottesville, VA 22903-2475 USA
"-----------------------------------------------------------------------
"
"     FPS AP-120B array processor routine library - W. D. Cotton
"
"     All routines should work for fast or slow AP memory, in some
"     cases fast and slow memory sections are coded seperatly and
"     marked for conditional assembly.  In these cases a variable
"     name FSSLO is set to indicate the memory speed to the assembler.
"                        FSSLO = 1 for 166 nsec memory (fast)
"                        FSSLO = 0 for 333 nsec memory (slow)
"
"     Current members:
"
"        APGRD1             July 1980
"        HIST               July 1980
"        CSQTRN             June 1980
"        CVCMUL             July 1980
"        MAKMSK             July 1980
"        MAXMIN             July 1980 Rev. Feb. 1982(WDC)
"        VIDIV              July 1980
"        CVJADD             July 1980
"        MOVE1              July 1980
"        SUB1               July 1980
"        SQMUL              July 1980
"        PHSROT             August 1980
"        BOXSUM             September 1980
"        APGRD2             October 1980
"        BAKSUB             November 1980
"        VTRANS             March 1981
"        IMOD               March 1981
"        IMULT              March 1981
"        IADD               March 1981
"        ISUB               March 1981
"        CVSDIV             March 1982
"        S9SAV              March 1982
"        CVSMS              July 1982
"        APGRD3             January 1983
"        GRDMIX             January 1983
"        VRVRS              February 1983  Fixed FPS version.
"        CVMMAX             March 1983
"        APGRD4             August 1983
"        APINTP             October 1983
"        DIRADD             Old B. Clark routine, added Oct 1983
"        CLNSUB             B. Clark routine, mod W. Cotton and
"                           J. Hudson. Added Oct 1983
"        APINT              August 1984
"        CLNMAX             October 1984
"        CLNPKS             October 1984
"
"
"APGRD1
         $TITLE APGRD1
         $ENTRY APGRD1,9.
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     APGRD1 convolves visibility data onto a grid.
"     Works for total intensity mapping, accumulating weighted
"     gridded visibility values, weights and the number of times
"     a given cell has been accumulated into.
"
"     CALLING SEQUENCE - CALL APGRD1(UV,VIS,WT,GRID,CONX,CONY,NO2
"                                    ,M,LROW)
"                        UV = Location of (u,v) values in cells.
"                        VIS = Location of (complex) visibilities.
"                        WT = Weight for data. Assumes any tapering
"                             has already been done.
"                        GRID = base address of gridded data.
"                               Order assumed to be the following
"                               for each of the M rows:
"                               1) 2 * LROW visibilities
"                               2) 2*LROW (count,sum weights)
"                        CONX = base address of X convolving fn.
"                        CONY = base address of Y convolving fn.
"                        NO2 = INT( (# cells used on a row) / 2 )
"                        M = number of rows kept in the AP.
"                        In the above, X refers to rows and y to columns
"                        in the gridded data, NOT on the sky.  The total
"                        numbers of rows and cells used on a row should
"                        be odd.
"                        LROW = length of a row ( max. X).
"
"
"     All AP memory I/O values are assumed floating.
"     It is assumed that all values of v correspond to row M/2.
"
"     Source contains versions for both fast and slow AP memory
"     Timing = 7.5 + 1.2 N + 3.3 M * N for slow memory
"              9.3 + 1.3 n + 1.7 M * N for fast memory
"
"     Programmer: W. D. Cotton, July 1980.
"
"        SET SPAD ASSIGNMENTS
"
UV       $EQU  0
VIS      $EQU  1
WT       $EQU  2
GRID     $EQU  3
CONX     $EQU  4
CONY     $EQU  5
NO2      $EQU  6
M        $EQU  7
LROW     $EQU  8.
"
"        SET WORK SPAD ASSIGMNENTS
"
IX       $EQU  0
FOUR     $EQU  0
A        $EQU  1                          "SUM OF WEIGHTS AND COUNT
N        $EQU  9.
IN       $EQU  10.
ICONX    $EQU  11.
INCR     $EQU  12.
C27      $EQU  13.
WTX      $EQU  13.
TWO      $EQU  13.
WTY      $EQU  14.
HAF      $EQU  14.
IADD     $EQU  14.
IHUN     $EQU  15.
"
"        SET MEMORY SPEED, 1 = FAST, 0 = SLOW
"
         FSSLO = 1
"
APGRD1:  INC UV; SETMA                    "FETCH X
         LDTMA; DB=!HALF                  "0.5 TO TM
         LDSPI IHUN; DB=100.              "100 TO IHUN
         LDSPI C27; DB=27.                "C27 = CONST.FOR FLOATING.
         DECMA;                           "FETCH Y
              MOVR LROW,HAF               "HAF = LROW / 2
         FIX  MD;                         "FIX X (ROUNDED)
              MOV IHUN,IHUN; DPX(3)<SPFN  "100. TO DPX(3) FOR FLOAT
         MOV VIS,VIS; SETMA;              "FETCH REAL ( VIS )
              FADD TM, MD                 "ADD 0.5 TO X
         FADD ZERO,MDPX(3); MOV C27,C27;  " FLOAT 100.
              DPX(2)<FA;                  "SAVE FIXED X
              DPY(-1)<MD                  "SAVE Y
         FIX  MD;                         "FIX Y (ROUNDED)
              DPY(1)<FA;                  "SAVE X + 0.5 IN DPY(1)
              DEC GRID                    "DECREMENT GRID BEFORE LOOP
         LDSPI IX; DB=DPX(2);             "FIXED X TO IX
              FADD TM, DPY(-1);           "ADD 0.5 TO Y
              DPX(3)<FA                   "SAVE 100.0 IN DPX(3)
         INCMA;                           "FETCH IMAG ( VIS )
              FADD ZERO,MDPX(2);
                   MOV C27,C27;           "FLOAT(IX)
                   DPX(-2)<FA             "FIXED Y TO DPX(-2)
         INC HAF;                         "HAF = LROW/2 + 1
              DPY(-1)<FA;                 "SAVE Y+0.5 IN DPY(-1)
              FADD                        "PUSH
         ADD HAF,IX;                      "ADD BIAS TO IX
              DPX(0)<MD;                  "SAVE REAL ( VIS )
              FSUBR DPY(1),FA             "IX - X - 0.5
         MOV LROW,IADD;                   "CHECKING FOR END OF ROW
              FADD                        "PUSH
         MOV WT,WT; SETMA;                "FETCH WEIGHT
              DPY(0)<MD;                  "SAVE IMAG(VIS)
              FMUL DPX(3),FA              "100.0*(IX-X-0.5)
         FADD ZERO,MDPX(-2);
                   MOV C27,C27            "FLOAT(FIX(Y))
         SUB NO2,IADD;                    "CHECKING FOR END OF ROW
              FADD                        "PUSH
         SUB IX,IADD;                     "CHECKING FOR END OF ROW.
              FSUBR DPY(-1),FA;           "FIX(Y)-Y-0.5
              DPX(1)<MD;                  "SAVE WEIGHT
              DPY(1)<MD                   "TEMP WEIGHT.
         MOVL NO2,N;                      "2 * N/2 TO N
              FADD ZERO,DPY(1);           "CHECK WEIGHT <= 0.0
              BGE .+4                     "BRANCH IF UPPER X LIMIT OK
         ADD IADD,N                       "REDUCE N FOR UPPER LIMIT.
         BGT .+2                          "MAKE SURE N POSITIVE
         JMP S999                         "N .LE. 0 - RETURN
         FMUL DPX(3),FA;                  "100 * (FIX(Y) - Y - 0.5)
              FADD;                       "PUSH
              MOVL LROW,A                 "CONSTRUCT GRID POINTERS
         FMUL;                            "PUSH
              ADD GRID, A                 "CONSTRUCT GRID POINTERS
         DPY(3)<FM;                       "STUPID RESTRICTIONS.
              FMUL;                       "PUSH
              BFGT .+2                    "BRANCH IF WEIGHT POSITIVE
         JMP S999                         "NON. POS. WEIGHT - RETURN
         INC N                            "N = 2 * NO2 + 1
         FIX  DPY(3);                     "FIX X CONV. FN. INDEX
              DPX(3)<FM                   "STUPID RESTRICTIONS.
         FIX  DPX(3)                      "FIX Y CONV. FN. INDEX
         DPY(-1)<FA;                      "X CONV INDEX TO DPY(-1)
              FADD                        "PUSH
         LDSPI WTX; DB=DPY(-1);           "X CONV. FN. INDEX TO WTX
              DPY(-2)<FA                  "Y CONV INDEX TO DPY(-2)
         LDSPI WTY; DB=DPY(-2)            "Y CONV. FN. INDEX TO WTY
         ADD WTX,CONX                     "X CONV. FN. FIRST ADDRESS
         ADD WTY,CONY                     "Y CONV. FN. FIRST ADDRESS
         ADD IHUN,CONY                    "POINTER=100*(FIX(Y)-Y-.5)+100
                                          "100 ADDED TO CONX IN LOOP
         SUB NO2,IX                       "CHECK FRONT OF ROW
         DEC IX                           "CHECK IX .GE. NO2 + 1
         MOV CONX,ICONX;                  "SAVE POINTER
              BGE LONG                    "BRANCH IF FRONT OK
"        FRONT END OF ROW ENCOUNTERED.
         ADD IX, N                        "REDUCE N
         BGT .+2                          "MAKE SURE N POSITIVE
         JMP S999                         "N .LE. 0 - RETURN
         CLR IADD
         SUB IX,IADD
         DEC IADD
         ADD IHUN,CONX;                   "UPDATE CONX
              BGT .-1
         MOV CONX,ICONX;
              BR START
LONG:    ADD IX,IX                        "FOR COMPLEX VALUES.
         ADD IX,A                         "FINISH SUM WT POINTER
         ADD IX,GRID                      "FINISH GRIDDED VIS POINTER
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
"
START:   MOVL LROW,INCR;                  "2*LROW TO INCR
              LDTMA; DB=!ONE              "1.0 TO TM
         SUB N,INCR
         ADD INCR,INCR                    "INCR = 4 * LROW - 2 * N
         MOV N,IN;
              BGE LOOP                    "
         JMP S999                         "SOMETHING WRONG - RETURN
LOOP:    ADD IHUN,ICONX; SETMA            "FETCH CONV X.
         NOP
         MOV CONY,CONY; SETMA             "FETCH CONV Y.
         FMUL DPX(1),MD                   "WT*CX
         INC A; SETMA;                    "FETCH COUNT
              FMUL                        "PUSH
         FMUL                             "PUSH
         INC A; SETMA;                    "FETCH SUM WEIGHTS
              FMUL FM,MD                  "WT*CX*CY = WEIGHT
         FADD TM,MD;                      "UPDATE COUNT
              FMUL                        "PUSH
         INC GRID; SETMA;                 "FETCH REAL (GRID)
              FMUL                        "PUSH
         FADD FM,MD;                      "SUM WEIGHTS
              DPX(2)<FM;                  "SAVE WEIGHT
              FMUL FM,DPX(0)              "WEIGHT * REAL(VIS)
         INC GRID; SETMA;                 "FETCH IMAG(GRID)
              FMUL DPX(2),DPY(0)          "WEIGHT * IMAG(GRID)
         FMUL                             "PUSH
         DEC A; SETMA;MI<FA;              "SAVE COUNT
              FADD FM,MD;                 "UPDATE REAL(GRID)
              FMUL                        "PUSH
         FADD FM,MD;                      "UPDATE IMAG(GRID)
              DPY(1)<FA                   "SAVE SUM WEIGHTS IN DPY(1)
         INC A; SETMA; MI<DPY(1)          "SAVE SUM OF WEIGHTS
         NOP
         DEC GRID; SETMA; MI<FA           "SAVE REAL(GRID)
         DEC IN;                          "DECR. INNER LOOP COUNT
              FADD                        "PUSH
         INC GRID; SETMA; MI<FA;          "SAVE IMAG(GRID)
              BGT LEND                    "BRANCH IF INNER LOOP IS
                                          "NOT FINISHED.
"
"        INNER LOOP FINISHED
"
         DEC M                            "DECR OUTER LOOP COUNT
         MOV CONX,ICONX;                  "RESET X CONV. FN. POINTER.
              BGT .+2                     "BRANCH IF NOT FINISHED.
         BR S999                          "FINISHED, RETURN.
         ADD INCR,A                       "UPDATE SUM WEIGHTS POINTER
         ADD INCR,GRID                    "UPDATE GRID POINTER
         ADD IHUN,CONY                    "UPDATE Y CONV. FN. POINTER
         MOV N,IN                         "RESET INNER LOOP COUNT
LEND:    JMP LOOP                         "LOOP
         $ENDIF                            "END OF SLOW VERSION
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
START:   LDSPI C27; DB=27.                 "27 TO SPAD TO FLOAT N
         LDSPI FOUR; DB=4.                 "4 TO FOUR
         MOV N,N; DPX(-4)<SPFN             "FLOAT N
         FADD ZERO,MDPX(-4); MOV C27,C27;  "FLOAT N
              BGT .+2                      "MAKE SURE N>0
         JMP S999                          "N <= 0 - RETURN
         FADD;                             "PUSH
              LDSPI TWO; DB=2.             "2 TO TWO
         MOVL LROW,INCR;                   "2*LROW TO INCR
              LDTMA; DB=!ONE               "1.0 TO TM
         SUB N,INCR;                       "2*LROW - N
              DPX(-4)<FA                   "SAVE FLOAT N
         ADD INCR,INCR                     "4*LROW-2*N
         INC INCR;                         "INCR=4*LROW-2*N+1
              DPY(-4)<FA                   "SAVE FLOAT N IN DPY
         SUB INCR,GRID                     "DECREMENT GRID BEFORE LOOP
         SUB INCR,A                        "DECREMENT A BEFORE LOOP
         SUB IHUN,CONY                     "DECREMENT CONY BEFORE LOOP
         ADD IHUN,CONX                     "SET CONX FOR FAST MEMORY
         INC A                             "UNDO DEC GRID DONE FOR
         INC GRID                          "SLOW MEMORY VERSION.
"
"        BEGIN OUTER LOOP
"
OLOOP:   MOV CONX,ICONX; SETMA             "1.FETCH CX
         ADD IHUN,CONY; SETMA              "1.FECTH CY
         ADD INCR,A; SETMA                 "1.FETCH COUNT
         INC A; SETMA;                     "1.FETCH SUM OF WEIGHTS
              FMUL DPX(1),MD               "1. WT*CX
         ADD INCR,GRID; SETMA;             "1.FETCH REAL(GRID)
              DPX(-1)<MD;                  "1.SAVE CY
              FMUL                         "1.PUSH
         INCMA;                            "1.FETCH IMAG(GRID)
              FADD TM,MD;                  "1. INCREMENT COUNT
              FMUL;                        "1.PUSH
              DPY(-4)<DPX(-4)              "  SAVE INNER LOOP COUNT
         FMUL FM,DPX(-1);                  "1. WT*CX*CY
              DPY(-1)<MD;                  "1.SAVE SUM WEIGHTS
              FSUBR TM,DPY(-4)             "  DECREMENT INNER LOOP COUNT
         DEC A; SETMA; MI<FA;              "1.STORE NEW COUNT
              DPX(-2)<MD;                  "1.SAVE REAL(GRID)
              FADD;                        "  PUSH
              FMUL                         "1.PUSH
         FMUL                              "1.PUSH
         FMUL FM,DPX(0);                   "1. WT*CX*CY*REAL(VIS)
              DPX(2)<FM;                   "1. SAVE WT*CX*CY
              SUB TWO,GRID;                "  SET GRID FOR ILOOP
              DPY(-4)<FA;                  "  SAVE NEW ILOOP COUNT
              BFGT ILOOP                   "  BRANCH IF N > 1
         JMP DP1                           "  N=1 SKIP LOOP
"
"        BEGIN INNER LOOP
"
ILOOP:   ADD IHUN,ICONX; SETMA;            "1.FETCH CX
              FMUL DPX(2),DPY(0)           "2.WT*CX*CY*IM(VIS)
         MOV CONY,CONY; SETMA;             "1.FETCH CY
              FMUL;                        "2.PUSH
              DPY(-2)<MD                   "2.SAVE IMAG(GRID)
         ADD TWO,A; SETMA;                 "1.FETCH COUNT
              FADD FM,DPX(-2);             "2.ADD REALS
              FMUL                         "2.PUSH
         INC A; SETMA;                     "1.FETCH SUM OF WEIGHTS
              FMUL DPX(1),MD;              "1.WT*CX
              FADD FM,DPY(-2)              "2.ADD IMAG
         ADD FOUR,GRID; SETMA;             "1.FETCH REAL(VIS)
              DPX(-1)<MD;                  "1.SAVE CY
              FMUL;                        "1.PUSH
              FADD DPX(2),DPY(-1);         "2.SUM WEIGHTS
              DPY(-3)<FA                   "2.SAVE NEW REAL(GRID)
         INCMA;                            "1.FETCH IMAG(GRID)
              FADD TM,MD;                  "1.INCREMENT COUNT
              FMUL;                        "1.PUSH
              DPX(-3)<FA                   "2.SAVE NEW IMAG(GRID)
         FMUL FM,DPX(-1);                  "1.WT*CX*CY
              DPY(-1)<MD;                  "1.SAVE SUM WEIGHT
              SUB TWO,A; SETMA; MI<FA;     "2.STORE NEW SUM OF WEIGHTS
              FSUBR TM ,DPY(-4)            "  DECREMENT ILOOP COUNT
        INC A; SETMA; MI<FA;               "1.STORE NEW COUNT
              FMUL;                        "1.PUSH
              DPX(-2)<MD;                  "1.SAVE REAL(GRID)
              FADD                         "  PUSH
        FMUL;                              "1.PUSH
              DEC GRID; SETMA; MI<DPX(-3)  "2.STORE NEW IMAG(GRID)
        FMUL FM,DPX(0);                    "1.WT*CX*CY*REAL(VIS)
              DPX(2)<FM;                   "1.SAVE WT*CX*CY
              DEC GRID; SETMA; MI<DPY(-3); "2.STORE NEW REAL(GRID)
              DPY(-4)<FA;                  "  SAVE NEW ILOOP COUNT
              BFGT ILOOP                   "  LOOP IF NOT FINISHED
"
"       FINISHED INNER LOOP - DROP PASS 1
"
DP1:    FMUL DPX(2),DPY(0)                 "2.WT*CX*CY*IMAG(VIS)
        FADD DPX(2),DPY(-1);               "2.SUM WEIGHTS
             FMUL                          "2.PUSH
        FADD FM,DPX(-2);                   "2.ADD REALS
             FMUL                          "2.PUSH
        FADD FM,MD;                        "2.ADD IMAG
             INC A; SETMA; MI<FA           "2.STORE NEW SUM WEIGHTS
        ADD TWO, GRID; SETMA; MI<FA;       "2.STORE NEW REAL GRID
             FADD                          "2.PUSH
        DEC M                              "  DECREMENT OLOOP COUNT
        INC GRID; SETMA; MI<FA;            "2.STORE NEW IMAG(GRID)
             BGT LEND                      "  LOOP IF NOT FINISHED
        JMP S999                           "FINISHED - RETURN
LEND:   JMP OLOOP                          "  LOOP
        $ENDIF
"
S999:   RETURN
        $END
"HIST
         $TITLE HIST
         $ENTRY HIST,7
         $EXT VCLIP
         $EXT SPFLT
         $EXT DIV
"     MICROCODE ROUTINE FOR FPS AP-120B ARRAY PROCESSOR
"
"        HIST COMPUTES THE HISTOGRAM OF A VECTOR
"
"     CALLING SEQUENCE = CALL HIST(A,I,C,N,NB,AMAX,AMIN)
"
"        A = SOURCE VECTOR BASE ADDRESS.
"        I = A ADDRESS INCREMENT
"        C = HISTOGRAM VECTOR BASE ADDRESS
"            ( MUST BE CLEARED BEFORE FIRST CALL)
"        N = ELEMENT COUNT FOR A. (MUST BE < 32768.)
"        NB = NUMBER OF BINS IN HISTOGRAM.
"        AMAX = ADDRESS OF HISTOGRAM MAXIMUM.
"        AMIN = ADDRESS OF HISTOGRAM MINIMUM.
"
"        TIMING = 8.5 + 1.5N   109? WORDS.
"
"        HISTOGRAM ELEMENT (NB-1)*(DATA-MIN)/(MAX-MIN) INCREMENTED
"        SHOULD ALSO WORK WITH SLOW AP MEMORY WHEN LINKED WITH SLOW
"        VCLIP. SHOULD HANDLE ANY N AND DUPLICATE SEQUENTIAL DATA.
"
"     Programmer = W. D. Cotton, July 1980.
"
"        SET INPUT PARAMETERS
"
A        $EQU  0
I        $EQU  1
C        $EQU  2
N        $EQU  3
NB       $EQU  4
AMAX     $EQU  5
AMIN     $EQU  6
"
"        SET PARAMETERS FOR VCLIP.
"
A0       $EQU  0                     "A
A1       $EQU  1                     "I
A2       $EQU  2                     "AMIN
A3       $EQU  3                     "AMAX
A4       $EQU  4                     "A
A5       $EQU  5                     "I
A6       $EQU  6                     "N
"
"        SET WORK PARAMETERS
"
ATEMP    $EQU  7                     "STORAGE FOR A
COUNT    $EQU  8.                    "LOOP COUNTER
NEXT     $EQU  9.                    "ADDRESS OF NEXT HISTOGRAM VALUE.
LAST     $EQU 10.                    "ADDRESS OF LAST HISTOGRAM VALUE.
NBINS    $EQU 15.                    "N-1
CTEMP    $EQU 12.                    "STORAGE FOR C
"
"        SET CALL TO VCLIP AND COMPUTE CONSTANTS FOR LOOP.
"
HIST:    MOV N,COUNT                 "STORE N
         MOV AMAX,A3; SETMA;         "FETCH HIST. MAX
              BGT RUN                "CHECK FOR N=0
         RETURN                      "RETURN IF N.LE. 0
RUN:     MOV NB,NBINS                "SAVE NUMBER OF BINS
         MOV C,CTEMP                 "SAVE HIST. START ADDRESS.
         DEC NBINS                   "NBINS = NB - 1
         MOV AMIN,A2;SETMA;          "FETCH HIST. MIN
              DPY(2)<MD              "HIST. MAX TO DPY(2)
         MOV A,ATEMP                 "STORE A
         MOV A,A4                    "SET DESTINATION VECTOR FOR VCLIP
         FSUB DPY(2),MD              "HIST. MAX - HIST. MIN
         MOV I,A5;                   "SET DEST. INC. FOR VCLIP
              FADD                   "PUSH
         MOV COUNT,A6;               "SET EL. COUNT FOR VCLIP
              DPX(2)<FA              "DPX(2) = HIST MAX - MIN
         JSR VCLIP                   "CLIP DATA VECTOR
"
"        SETUP FOR HISTOGRAM COMPUTATION.
"
         JSR SPFLT                  "FLOAT NBINS TO DPX(1)
         DPX(0)<DPX(2);              "MOVE MAX-MIN TO DPX(0)
              MOV A2,A2; SETMA       "FETCH HIST. MIN.
         DPY(0)<DPX(1)               "MOVE NBINS TO DPY(0)
         JSR DIV                     "NBINS / ( MAX - MIN ) TO DPX(0)
"
"        FLOAT COUNT TO DPX(1)
"
         CLR NBINS                   "ZERO SP15
         SUB COUNT,NBINS;            "NEGATE COUNT TO SP15 FOR SPFLT
              DPX(2)<DPX(0)          "SAVE DPX(0) (FACTOR) IN DPX(2)
         JSR SPFLT                   "FLOAT
"
"        COMPUTE HISTOGRAM
"
"        START PASS1
"
         LDTMA; DB=!ONE              "SET TM TO 1.0
         MOV ATEMP,A; SETMA          "FETCH FIRST VALUE
         DPY(0)<MD;                  "SAVE HIST. MIN IN DPY(0)
              MOV CTEMP,C            "RESTORE C
         FADD  TM,DPX(1)             "   DECR LOOP COUNTER
         FSUBR DPY(0),MD;            "1. VALUE - MIN
              DPX(0)<DPX(2)          "   RESTOR FACTOR TO DPX(0)
         FADD;                       "1. PUSH
              DPX(1)<FA              "   SAVE NEW LOOP COUNTER
         FMUL DPX(0),FA;             "1. COMPUTE HIST. INDEX
              BFLT AP2               "   BRANCH IF N>1.
         SFL0                        "   N=1, SET FLAG 0
"
"        START PASS 2
"
AP2:     ADD I,A; SETMA;             "1. FETCH VALUE
              FMUL;                  "2. PUSH
              FADD  TM,DPX(1)        "   DECREMENT LOOP COUNTER
         FMUL;                       "2. PUSH
              FADD                   "   PUSH
         DPY(1)<FM;                  "2. SAVE INDEX
              DPX(1)<FA              "   SAVE LOOP COUNTER
         FSUBR DPY(0),MD;            "1. VALUE - MIN
              BFLT NXT               "   BRANCH IF N>2
         SFL1                        "   N=2, SET FLAG 1
NXT:     FIX  DPY(1)                 "2. FIX INDEX
         FMUL DPX(0),FA;             "1. COMPUTE HIST. INDEX
              FADD                   "2. PUSH
"
"        START PASS 3
"
         ADD I,A; SETMA;             "1. FETCH VALUE
              FMUL;                  "2. PUSH
              DPX(2)<FA;             "3. SAVE FIXED INDEX
              FADD  TM,DPX(1)        "   DECR LOOP COUNTER.
         FMUL;                       "2. PUSH
              LDSPI NEXT; DB=DPX(2); "3. HIST INDEX TO SPAD
              FADD                   "   PUSH
         DPY(1)<FM;                  "2. SAVE INDEX
              ADD C,NEXT; SETMA;     "3. FETCH OLD HIST. VALUE
              DPX(1)<FA              "   SAVE LOOP COUNTER
         FSUBR DPY(0),MD;            "1. VALUE - MIN
              BFLT NXT2              "   BRANCH IF N>3
         SFL2                        "   N=3, SET FLAG 2
NXT2:    FIX  DPY(1)                 "2. FIX HIST INDEX
         FMUL DPX(0),FA;             "1. COMPUTE HIST INDEX
              FADD TM,MD;            "3. INCR HIST. VALUE
              MOV NEXT,LAST          "3. SAVE LAST HIST. ADDRESS
"
"        MAIN LOOP
"
LOOP:    ADD I,A; SETMA;             "1. FETCH VALUE
              FMUL;                  "2. PUSH
              DPX(2)<FA;             "3. SAVE FIXED HIST INDEX
              FADD  TM,DPX(1)        "   DECR LOOP COUNTER
         FMUL;                       "2. PUSH
              LDSPI NEXT; DB=DPX(2); "3. HIST INDEX TO SPAD
              FADD;                  "   PUSH
              DPX(3)<FA              "4. SAVE NEW HIST. VALUE
         DPY(1)<FM;                  "2. SAVE INDEX
              ADD C,NEXT; SETMA;     "2. SAVE INDEX
              DPX(1)<FA              "   SAVE LOOP COUNTER.
         FSUBR DPY(0),MD;            "1. VALUE - MIN
              BFGE AFTER;            "   CHECK IF FINISHED
              DPY(2)<DPX(3);         "4. NEW HIST. VALUE TO DPY(2)
              SUB NEXT,LAST          "3. CHECK IF SAME HIST AS LAST.
         FIX  DPY(1);                "2. FIX INDEX
              BEQ MULT;              "3. BRANCH IF NEXT=LAST
              ADD NEXT,LAST; SETMA;
                          MI<DPX(3)  "4. STORE NEW HIST VALUE.
         FMUL DPX(0),FA;             "1. COMPUTE HIST INDEX
              FADD TM,MD;            "3. INCREMENT HIST VALUE
              MOV NEXT,LAST;         "3. SAVE LAST HIST ADDRESS
              BR LOOP                "   LOOP
"
"        IF INCREMENTING SAME HIST. VALUE AS LAST INCREMENT OLD
"
MULT:    FMUL DPX(0),FA;             "1. COMPUTE HIST INDEX
              FADD TM,DPY(2);        "3. INCR PREV. HIST. VALUE
              MOV NEXT,LAST;         "3. SAVE LAST HIST ADDRESS
              BR LOOP                "   LOOP
"
"        WIND DOWN
"
AFTER:   FIX  DPY(1);                "2. FIX HIST INDEX
              BEQ MULTP1;            "   BRANCH IF NEXT=LAST
              ADD NEXT,LAST; SETMA;
                          MI<DPX(3)   "4. STORE NEW HIST VALUE
         FMUL DPX(0),FA;             "1. COMPUTE HIST. INDEX
              FADD TM,MD;            "3. INCR HIST. VALUE
              MOV NEXT,LAST;         "3. SAVE LAST HIST ADDRESS
              BR DP1
"
"        INCREMENT PREVIOUS NEW HIST. VALUE.
"
MULTP1:  FMUL DPX(0),FA;             "1. COMPUTE HIST INDEX
              FADD TM,DPY(2);        "3. INCR LAST HIST. VALUE
              MOV NEXT,LAST          "3. SAVE LAST HIST VALUE
"
"        DROP PASS 1
"
DP1:     FMUL;                       "2. PUSH
              DPX(2)<FA;             "3. SAVE FIXED INDEX
              BFL0 UP                "   IF N=1 (FLAG 0) RETURN.
         FMUL;                       "2. PUSH
              LDSPI NEXT; DB=DPX(2)  "3. HIST. ADDRESS TO SPAD
         DPY(1)<FM;                  "2. SAVE INDEX
              ADD C,NEXT; SETMA      "3. FETCH OLD HIST. VALUE
         FADD;                       "   PUSH
              SUB  NEXT,LAST         "3. CHECK IS NEXT=LAST
         FIX  DPY(1);                "2. FIX HIST INDEX
              DPY(2)<FA;             "3. SAVE HIST. VALUE
              BEQ MULTP2;            "   BRANCH IF NEXT=LAST
              ADD NEXT,LAST; SETMA;
                             MI<FA   "4. STORE NEW HIST. VALUE
         FADD TM,MD;                 "3. UPDATE HIST VALUE
              MOV NEXT,LAST;         "3. SAVE LAST HIST. ADDRESS
              BR DP2
"
"        UP IS AN INTERMEDIATE STOP IF N=1.
"
UP:      BR S999
"
"        INCREMENT LAST NEW HISTOGRAM VALUE
"
MULTP2:  FADD TM,DPY(2);             "3. INCR LAST HIST VALUE
            MOV NEXT,LAST            "3. SAVE LAST HIST ADDRESS
"
"        DROP PASS 2
"
DP2:     DPX(2)<FA;                  "3. SAVE FIXED INDEX
              BFL1 S999              "   IF N=2 (FLAG 1) RETURN
         LDSPI NEXT; DB=DPX(2)       "3. HIST INDEX TO SPAD
         ADD C,NEXT; SETMA           "3. FETCH OLD HIST. VALUE
         FADD;                       "   PUSH
              SUB  NEXT,LAST         "3. CHECK IF NEXT=LAST
         DPY(2)<FA;                  "3. SAVE LAST HIST. VALUE
              BEQ MULTP3;            "   BRANCH IF NEXT=LAST
              ADD NEXT,LAST; SETMA;
                             MI<FA   "4. STORE NEW HIST VALUE.
         FADD TM,MD;                 "3. INCREMENT HIST VALUE.
              BR DP3
"
"        LAST=NEXT INCREMENT LAST NEW HISTOGRAM VALUE.
"
MULTP3:  FADD TM,DPY(2)              "3. INCR LAST HIST. VALUE
"
"        DROP PASS 3
"
DP3:     FADD;                       "   PUSH
              BFL2 S999              "   IF N=3 (FLAG 2) RETURN
         MOV NEXT,NEXT; SETMA; MI<FA "4. STORE NEW HIST VALUE
         RETURN
"        CLEAR FLAGS BEFORE RETURNING.
S999:    CFL0
         CFL1
         CFL2;
              RETURN
              $END
         $TITLE CSQTRN
         $ENTRY CSQTRN,3
         $EXT VSWAP
"
"        CSQTRN does an in place transpose of square matrices of
"        complex values using VSWAP.
"
"        CALLING SEQUENCE: CALL CSQTRN(CORNER,SIZE,ROW)
"
"        CORNER = AP location of first corner of matrix encountered.
"        SIZE = Size (number of reals) of a row or column.
"        ROW = Number of locations in AP between beginnings of rows.
"
"        PROGRAMMER: W. D. Cotton, April 1980.
"
"        Set SPAD entry parameters.
CORNER   $EQU   0
SIZE     $EQU   1
ROW      $EQU   2
"
"        Set SPAD work variables.
LCOUNT   $EQU   6                    "Loop counter.
CURCRN   $EQU   7                    "Current matrix corner.
CRNINC   $EQU   8.                   "Increment for CURCRN from
                                     "one imaginary to next real.
"
"        Set SPAD VSWAP parameters.
A1       $EQU   0                    "CURCRN
A2       $EQU   1                    "2
A3       $EQU   2                    "CURCRN
A4       $EQU   3                    "ROW
A5       $EQU   4                    "Loop count +1
"
"        Setup
"
CSQTRN:  MOV CORNER,CURCRN           "Save CORNER
         MOV ROW,CRNINC              "Set CRNINC
         MOV SIZE,LCOUNT             "Set LCOUNT
         MOV CURCRN,A1               "Set initial A1
         MOV CURCRN,A3               "Set initial A3
         MOV CRNINC,A4               "Set initial A4
         MOV LCOUNT,A5               "Set initial A5
         CLR A2                      "Set A2 = 2
         INC A2
         INC A2
         INC CRNINC                  "Set CRNINC to ROW + 1
         DEC LCOUNT                  "Loops = SIZE - 1
"
"        Ready to loop.
"
LOOP:    JSR VSWAP                   "Call VSWAP for reals
         INC CURCRN                  "Update CORNER for imaginaries
         MOV CURCRN,A1               "Update A1.
         MOV CURCRN,A3               "Update A3
         MOV LCOUNT,A5               "Update A5
         INC A5
         JSR VSWAP                   "Call VSWAP for imaginaries.
         ADD CRNINC,CURCRN           "Update CURCRN
         MOV CURCRN,A1               "Update A1
         MOV CURCRN,A3               "Update A3
         MOV LCOUNT,A5               "Update A5
         DEC LCOUNT                  "Decrement loop counter.
         BGT LOOP                    "Loop
         RETURN
         $END
         $TITLE CVCMUL
         $ENTRY CVCMUL,6
"     MICROCODE FOR FPS AP-120B ARRAY PROCESSOR
"
"         CVCMUL multiplies a scalar complex value times the complex
"         conjugate of a complex vector producing a real vector
"
"    CALLING SEQUENCE - CALL CVCMUL(A,I,B,C,J,N)
"               A = Source complex vector base address
"               I = Increment of A
"               B = Address of scalar (real part)
"               C = Destination real vector base address
"               J = Increment for C
"               N = Element count (number of reals)
"
"         C(K) = REAL(B) * A(K) + IMAG(B) * A(K+1)
"
"         Timing = 1.0 N + 3.0 microseconds
"
"         Should work on either fast or slow AP memory.
"
"     Programmer = W. D. Cotton, July 1980.
"
"     SET SPAD REGISTERS
"
A        $EQU  0
I        $EQU  1
B        $EQU  2
C        $EQU  3
J        $EQU  4
N        $EQU  5
"
"     DATA PAD ASSIGNMENTS
"
"         DPX(0) = REAL PART OF B
"         DPY(0) = IMAG PART OF B
"         DPX(1) = STORAGE FOR REAL(B) * REAL(A)
"
CVCMUL:   MOV B,B; SETMA              "FETCH REAL(B)
          SUB J,C                     "DECREMENT C BY J BEFORE LOOP
          INCMA;                      "FETCH IMAG(B)
               DEC N                  "DECREMENT LOOP COUNT BEFORE LOOP
          DPX(0)<MD;                  "SAVE REAL(B) IN DPX(0)
               MOV N,N                "CHECK FOR N .LE. 0
          MOV A,A; SETMA;             "1. FETCH REAL(A)
               BGT RUN                "   BRANCH IF N > 0
          RETURN                      "   N <= 0, RETURN
RUN:      DPY(0)<MD                   "   SAVE IMAG(B) IN DPY(0)
          INCMA                       "1. FETCH IMAG(A)
          FMUL DPX(0),MD              "1. REAL(B) * REAL(A)
          FMUL;                       "1. PUSH
               DEC N                  "   DECREMENT LOOP COUNT
          FMUL DPY(0),MD;             "1. IMAG(B) * IMAG(A)
               BGE LOOP               "   BRANCH IN N > 1
          SFL0                        "   N = 1, SET FLAG 0
LOOP:     ADD I,A; SETMA;             "1. FETCH REAL(A)
               DPX(1)<FM;             "2. STORE PRODUCT OF REALS
               FMUL                   "2. PUSH
          FMUL                        "2. PUSH
          INCMA;                      "1. FETCH IMAG(A)
               FADD FM,DPX(1)         "2. SUM PRODUCTS
          FMUL DPX(0),MD;             "1. REAL(B) * REAL(A)
               FADD;                  "2. PUSH
               DEC N                  "   DECREMENT LOOP COUNT
          FMUL;                       "1. PUSH
               ADD J,C; SETMA; MI<FA; "2. STORE RESULT
               BGE LEND               "   CHECK IF FINISHED
          BR AFTER                    "   FINISHED, EXIT LOOP
LEND:     FMUL DPY(0),MD;             "1. IMAG(B) * IMAG(A)
               BR LOOP                "   LOOP
AFTER:    FMUL DPY(0),MD              "1. IMAG(B) * IMAG(A)
          DPX(1)<FM;                  "2. STORE PRODUCTS OF REALS
               FMUL                   "2. PUSH
          FMUL                        "2. PUSH
          FADD FM, DPX(1)             "2. SUM PRODUCTS
          FADD;                       "2. PUSH
               BFL0 S999              "   BRANCH IF N = 1.
          ADD J,C; SETMA; MI<FA       "2. STORE RESULTS
S999:     CFL0;                       "CLEAR FLAG 0
               RETURN                 " FINISHED RETURN
          $END
         $TITLE MAKMSK
         $ENTRY MAKMSK,7
         $BOX
"        MICROCODE PROGRAM FOR FPS AP-120B ARRAY PROCESSOR

     MAKMSK Makes a mask from a vector depending on a comparison of
     the vector A and scalar C.
                                 B(k) = 1.0 if A(k) < C
                                 B(k) = 0.0 if A(k) >= C.

     CALLING SEQUENCE - CALL MAKMSK(A,I,C,B,J,N,COUNT)
                        A = source vector base address.
                        I = increment of A.
                        C = scalar address.
                        B = destination vector base address.
                        J = increment of B.
                        N = element count
                        COUNT = number of times A(k) >= C.

     Should work for fast or slow AP memory.

     Timing = 2.0 + 0.7 N microseconds + 0.2 for each point clipped.

     Programmer = W. D. Cotton, July 1980.
         $ENDBOX
"
"        SET SPAD VALUES
"
A        $EQU  0
I        $EQU  1
C        $EQU  2
B        $EQU  3
J        $EQU  4
N        $EQU  5
COUNT    $EQU  6
ICOUNT   $EQU  7                 "NUMBER OF TIMES 0.0 STORED
"
MAKMSK:  MOV C,C; SETMA                  "FETCH SCALAR
         SUB J,B;                        "DECREMENT B BY J
              LDTMA; DB=!ONE             "1.0 TO TM
         MOV A,A; SETMA                  "1. FETCH DATA
         DPY(0)<MD;                      "   STORE C IN DPY(0)
              DEC N                      "   DECREMENT LOOP COUNT
         BGT NEXT;                       "   BRANCH IF N>1
              CLR ICOUNT                 "   CLEAR CLIP COUNTER
         JMP S999                        "   N <= 1, RETURN
NEXT:    FSUBR DPY(0),MD                 "1. CHECK IF DATA >= C
"
"        START PASS2
"
         ADD I,A; SETMA                  "1. FETCH DATA
         DEC N                           "   DECREMENT LOOP COUNTER
         BGT NEXT2                       "   BRANCH IF N>2
         JMP AFTER                       "   N=2
NEXT2:   FSUBR DPY(0),MD                 "1. CHECK IF DATA >= C
"
"        BEGIN LOOP
"
LOOP:    ADD I,A; SETMA                  "1. FETCH DATA
         BFGE ZERO;                      "3. BRANCH IF DATA >= C
              DEC N                      "   DECREMENT LOOP COUNT
         ADD J,B;SETMA;MI<DB;DB=TM;      "3. STORE 1.0 B
              BGT LEND                   "   CHECK LOOP COUNT
         BR AFTER                        "   FINISHED, EXIT LOOP
LENDM1:  INC ICOUNT                      "   INCREMENT CLIP COUNT
LEND:    FSUBR DPY(0),MD;                "1. CHECK IF DATA >= C.
              BR LOOP                    "   LOOP
"
"        WRITE 0.0
"
ZERO:    ADD J,B;SETMA;MI<DB;DB=ZERO;    "3. STORE 0.0 IN B.
              BGT LENDM1                 "   CHECK LOOP COUNT
         INC ICOUNT                      "   INCREMENT CLIP COUNT.
"
"        FINISHED, WIND DOWN
"
AFTER:   FSUBR DPY(0),MD                 "1. CHECK IF DATA >= C
"
"        DROP PASS1
"
         NOP                             "   WAIT FOR FADDER RESULT
         BFGE ZERO1                      "3. BRANCH IF DATA >= C
         ADD J,B;SETMA;MI<DB;DB=TM       "3. STORE 1.0 IN B
LEND1:   FADD;                           "   PUSH
              BR DP2
"
"       WRITE 0.0
"
ZERO1:  ADD J,B;SETMA;MI<DB;DB=ZERO      "3. STORE 0.0 IN B
        INC ICOUNT;                      "   INCREMENT CLIP COUNTER
             BR LEND1
"
"       DROP PASS 2
"
DP2:    NOP                              "   WAIT FOR FADDER RESULT
        BFGE ZERO2                       "3. BRANCH IF DATA >= C
        ADD J,B;SETMA;MI<DB;DB=TM;       "3. STORE 1.0 IN B
             BR S999                     "   FINISHED
"
"       WRITE 0.0
"
ZERO2:  ADD J,B;SETMA;MI<DB;DB=ZERO      "3. STORE 0.0 IN B
        INC ICOUNT                       "   INCREMENT CLIP COUNT
"
"       FINISHED, WRITE CLIP COUNT.
"
S999:   MOV ICOUNT,ICOUNT; DPX(0)<DB;DB=SPFN  "ICOUNT TO DPX(0)
        MOV COUNT,COUNT; SETMA;MI<DPX(0) "STORE CLIP COUNT
        RETURN
        $END
         $TITLE MAXMIN
         $ENTRY MAXMIN,5
"
"        MAXMIN searches the given vector for maximum and minimum values
"        CALLIN SEQUENCE: CALL MAXMIN(A,I,MAX,MIN,N)
"                   A = Source vector base address
"                   I = Increment for A
"                   MAX = Location for maximum.
"                   MIN = Loaction for minimum
"                   N = Element count
"        MAXMIN should work for both fast and slow AP memory.
"
"        Timing = 1.0 + 0.7 N microseconds ( add 0.7 for each new min.
"                                            and 0.5 for each new max.)
"
"        Programmer = W. D. Cotton, July 1980.
"                     Revised Feb. 1982.
"
"        SET SPAD ASSIGNMENTS
"
A        $EQU  0
I        $EQU  1
MAX      $EQU  2
MIN      $EQU  3
N        $EQU  4
"
"        DATA PAD ASSIGNMENTS
"
"        DPX(0) = CURRENT MAXIMUM  (MAX)
"        DPY(0) = CURRENT MINIMUM  (MIN)
"        DPX(1) = LAST VALUE TESTED (LAST)
"
"        INITILIZE MAX AND MIN TO FIRST DATA VALUE.
"
MAXMIN:  MOV A,A; SETMA                "1. FETCH DATA
         DEC N                         "   DECREMENT LOOP COUNTER
         BGT NEXT                      "   BRANCH IF N>1
         RETURN                        "   N .LE. 1, RETURN
NEXT:    DPX(0)<MD;                    "   INITILIZE MAX
              FADD ZERO,ZERO           "   INITILIZE FA TO 0.0
         DPY(0)<MD;                    "   INITILIZE MIN
              FADD                     "   PUSH
"
"        START FIRST PASS
"
         ADD I,A; SETMA                "1. FETCH DATA
         DEC N                         "   DECREMENT LOOP COUNTER
         BGT NEXT2                     "   BRANCH IF N>2
         JMP AFTER                     "   N=2, FINISH
"
"        START SECOND PASS
"
NEXT2:   ADD I,A; SETMA;               "1. FETCH DATA
              FSUBR DPX(0),MD          "2. CHECK FOR NEW MAX
         FSUB DPY(0),MD;               "2. CHECK FOR NEW MIN
              DEC N                    "   DECREMENT LOOP COUNTER
         DPX(1)<MD;                    "2. SAVE DATA VALUE
              BGT LOOP                 "   BRANCH IF N>3
         JMP AFTER                     "   N=3, FINISH
"
"        BEGIN LOOP
"
LOOP:    ADD I,A; SETMA;               "1. FETCH DATA
              FSUBR DPX(0),MD;         "2. CHECK FOR NEW MAX
              DPY(2)<MD;               "2. SAVE DATA FOR NEW MAX-MIN
              BFGT MAX0                "3. BRANCH IF LAST=NEW MAX
         FSUB DPY(0),MD                "2. CHECK FOR NEW MIN
         BFGT MIN0;                    "3. BRANCH IF LAST=NEW MIN
              DEC N                    "   DECREMENT LOOP COUNTER
LEND:    DPX(1)<DPY(2);                "2. SAVE DATA
              BGT LOOP                 "   LOOP IF NOT FINISHED.
         BR AFTER                      "   FINISHED
"
"        NEW MAX VALUE
"
MAX0:    DPX(0)<DPX(1)                 "3. NEW MAX.
RSTRT:   MOV A,A; SETMA;               "   RESTART LOOP - FETCH DATA
              FSUBR DPX(0),DPY(2);     "2. CHECK FOR NEW MAX.
              DPX(2)<DPY(2)            "   STORE DATA IN DPX(2)
         FSUB DPY(0),DPX(2);           "2. CHECK FOR NEW MIN.
              DEC N                    "   DECREMENT LOOP COUNTER
         DPX(1)<DPY(2);                "2. SAVE DATA
              BGT LOOP                 "   REENTER LOOP
         BR AFTER                      "   FINISHED
"
"        NEW MIN VALUE
"
MIN0:    DPY(0)<DPX(1);                "3. NEW MIN.
              INC N;                   "   INCREMENT LOOP COUNT
              BR RSTRT                 "   REENTER LOOP
"
"        WIND DOWN, DROP PASS1
"
AFTER:   FSUBR DPX(0),MD;              "2. CHECK FOR NEW MAX
              BFGT MAX1;               "3. BRANCH FOR NEW MAX
              DPY(2)<MD                "   SAVE DATA
         FSUB DPY(0),MD                "2. CHECK FOR NEW MIN
LEND1:   BFGT MIN1;                    "3. BRANCH IF LAST=NEW MIN
              DPX(1)<MD                "2. SAVE DATA VALUE
         BR DP2                        "
"
"        NEW MAX VALUE
"
MAX1:    DPX(0)<DPX(1)                 "3. NEW MAX
RSTRT1:  FSUBR DPX(0),DPY(2);          "   RESTART LOOP - CHECK NEW MAX.
              DPX(2)<DPY(2)            "   STORE SATA IN DPX(2)
         FSUB DPY(0),DPX(2)            "2. CHECK FOR NEW MIN.
         DPX(1)<DPY(2);                "2. SAVE DATA
              BR AFTER
"
"        NEW MIN VALUE
"
MIN1:    DPY(0)<DPX(1);                "3. NEW MIN.
              BR RSTRT1
"
"        DROP PASS2
"
DP2:     BFGT MAX2                     "3. BRANCH IF LAST=NEW MAX
         BFGT MIN2                     "3. BRANCH IF LAST=NEW MIN
         BR SAVE                       "   FINISHED
"
"        NEW MAX VALUE
"
MAX2:    DPX(0)<DPX(1);                "3. REPLACE MAX WITH LAST
              BR SAVE                  "   FINISHED SEARCH
"
"        NEW MIN VALUE
"
MIN2:    DPY(0)<DPX(1)                 "3. REPLACE MIN WITH LAST
"
"        FINISHED, STORE RESULTS
"
SAVE:    MOV MAX,MAX; SETMA; MI<DPX(0) "STORE MAXIMUM
         NOP                           "WAIT FOR MEMORY
         MOV MIN,MIN; SETMA; MI<DPY(0) "STORE MINIMUM
         RETURN
         $END
"VIDIV
         $TITLE VIDIV
         $ENTRY VIDIV,7
         $EXT SPUFLT
         $EXT DIV
"
"   VIDIV divides the given vector by the product of two unsigned
"   integers.
"   Calling Sequence: CALL VIDIV(A,I,D1,D2,B,J,N)
"           A = Source vector base address.
"           I = Increment for A
"           D1 = First dividend (unsigned)
"           D2 = Second dividend (unsigned).
"           B = Destination vector base address.
"           J = Increment for B.
"           N = Element count.
"
"   Timing = 8.2 + 0.7 microseconds
"
"   Programmer = W. D. Cotton, July 1980.
"
"        SET SPAD PARAMETERS
"
A        $EQU  0
I        $EQU  1
D1       $EQU  2
D2       $EQU  3
B        $EQU  4
J        $EQU  5
N        $EQU  6
"
SP15     $EQU  15.
"
"        DATA PAD ASSIGNMENTS.
"
"        DPX(0) = 1.0 / ( D1 * D2 )
"        DPX(2) = LOOP COUNTER.
"        DPY(1) = 1.0
"
"        FLOAT LOOP COUNTER, D1 AND D2.
"
VIDIV:   MOV N,SP15                     "MOVE N TO SP15 FOR SPUFLT
         BGT NEXT                       " MAKE SURE N>0.
         RETURN                         "N .LE. 0 - RETURN
NEXT:    JSR SPUFLT                     "FLOAT N TO DPX(1)
         MOV D1,SP15;                   "MOVE D1 TO SP15 FOR SPUFLT
              DPX(2)<DPX(1)             "LOOP COUNTER TO DPX(2)
         JSR SPUFLT                     "FLOAT D1 TO DPX(1)
         MOV D2,SP15;                   "MOVE D2 TO SP15 FOR SPUFLT
              DPY(2)<DPX(1)             "SAVE FLOATED D1 IN DPY(2)
         JSR SPUFLT                     "FLOAT D2 TO DPX(1)
"
"        MULTIPLY D1 BY D2
"
         FMUL DPX(1),DPY(2)             "D1 * D3
         FMUL;                          "PUSH
              SUB J,B                   "DECREMENT B BEFORE LOOP
         FMUL;                          "PUSH
              DPY(0)<TM                 "1.0 TO DPY(0) FOR DIV
                                        "TM LEFT 1.0 BY SPUFLT.
"
"        DIVIDE 1.0 BY D1 * D2
"
         DPX(0)<FM;                     "D1*D2 TO DPX(0) FOR DIV
              DPY(1)<TM                 "1.0 TO DPY(1) TO DECR. LOOP
         JSR DIV                        "1.0/(D1*D2) TO DPX(0)
"
"        SCALE VECTOR
"
         MOV A,A; SETMA;                "1. FETCH DATA
              FSUB DPX(2),DPY(1)        "2. DEC LOOP COUNTER
         FADD;                          "2. PUSH
              BFPE S999                 "   CHECK FOR DIVIDE BY ZERO
         DPX(2)<FA                      "2. SAVE LOOP COUNTER
         FMUL DPX(0),MD;                "1. SCALE DATA
              BFGT LOOP                 "2. BEGIN LOOP IF NOT FINISHED
         BR AFTER                       "   N=1, BRANCH.
"
"        BEGIN LOOP
"
LOOP:    ADD I,A; SETMA;                "1. FETCH DATA
              FSUB DPX(2),DPY(1);       "2. DECR LOOP COUNTER
              FMUL                      "2. PUSH
         FMUL;                          "2. PUSH
              FADD                      "2. PUSH
         ADD J,B; SETMA; MI<FM;         "2. STORE RESULT
              DPX(2)<FA                 "2. SAVE LOOP COUNTER
         FMUL DPX(0),MD;                "1. SCALE DATA
              BFGT LOOP                 "2. LOOP IF NOT FINISHED
"
"        FINISH UP
"
AFTER:   FMUL                           "2. PUSH
         FMUL                           "2. PUSH
         ADD J,B; SETMA; MI<FM          "2. STORE RESULT
S999:    RETURN
         $END
"CVJADD
         $TITLE CVJADD
         $ENTRY CVJADD,7
"     CVJADD Complex conjugate add.
"
"              C(j) = Re(A(j)) + Re(B(j)) + i (Im(A(j)) _ Im(B(j)))
"                                                 for j = 0 , N - 1
"
"     CALLING SEQUENCE - CALL CVJADD(A,I,B,J,C,K,N)
"                        A = Source complex vector base address
"                        I = Increment of A
"                        B = Source vector base address ( conjugate )
"                        J = Increment of B
"                        C = Destination base address
"                        K = Increment of C (at least 2)
"                        N = Element count
"
"     Source contains fast and slow versions.
"     Timing = 0.7 + 2.2N for slow,  1.3 + 1.0N for fast.
"
"     Programmer = W. D. Cotton. July 1980.
"
"        SPAD ASSIGNMENTS
"
A        $EQU  0
I        $EQU  1
B        $EQU  2
J        $EQU  3
C        $EQU  4
K        $EQU  5
N        $EQU  6
"
"        SET MEMORY SPEED, 1 = FAST, 0 = SLOW
"
         FSSLO = 1                         "FAST MEMORY
CVJADD:  MOV N,N                           "CHECK THAT N>0
         SUB I,A;                          "DECREMENT A BEFORE LOOP
              BGT NEXT                     "BRANCH IF N > 0
         JMP S999                          "N <= 0 - RETURN
NEXT:    SUB J,B                           "DECREMENT B BEFORE LOOP
         SUB K,C                           "DECREMENT C BEFORE LOOP
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
LOOP:    ADD I,A; SETMA                    "FETCH REAL A
         NOP                               "WAIT
         ADD J,B; SETMA                    "FETCH REAL B
         DPX<MD                            "SAVE REAL A
         INC A; SETMA                      "FETCH IMAG A
         FADD DPX,MD;                      "ADD REALS
              DEC A                        "DECREMENT A
         INC B; SETMA                      "FETCH IMAG B
         FADD;                             "PUSH
              DPX<MD                       "SAVE IMAG A
         ADD K,C; SETMA; MI<FA             "STORE REALS
         FSUB DPX,MD;                      "SUBTRACT IMAG.
              DEC B                        "DECREMENT B
         FADD;                             "PUSH
              DEC N                        "DECREMENT LOOP COUNTER
         INCMA; MI<FA;                     "STORE IMAGINARY
              BGT LEND                     "BRANCH IF NOT FINISHED.
         BR S999                           "FINISHED - RETURN
LEND:    JMP LOOP                          "LOOP
         $ENDIF
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
"        START PASS 1
"
         ADD I,A; SETMA                    "1.FETCH REAL A
         INCMA                             "1.FETCH IMAG A
         ADD J,B; SETMA                    "1.FETCH REAL B
         INCMA;                            "1.FETCH IMAG B
              DPX(0)<MD                    "1. SAVE REAL A
         DPY(0)<MD;                        "1.SAVE IMAG A
              DEC N                        "  DECREMENT LOOP COUNT
         FADD DPX(0),MD;                   "1.ADD REALS
              BGT LOOP                     "  BRANCH IF NOT FINISHED
         JMP DP1                           "  N=1 SKIP LOOP
"
"        LOOP
"
LOOP:    ADD I,A; SETMA;                   "1.FETCH REAL A
              FSUB DPY(0),MD               "2.SUBTRACT IMAG.
         INCMA                             "1.FETCH IMAG A
         ADD J,B; SETMA                    "1.FETCH REAL B
         INCMA;                            "1.FETCH IMAG B
              DPX(0)<MD;                   "1.SAVE REAL A
              DEC N                        "  DECREMENT LOOP COUNT
         DPY(0)<MD;                        "1.SAVE IMAG A
              FADD;                        "2.PUSH
              ADD K,C; SETMA; MI<FA;       "2.STORE REAL
              BGT LEND                     "  BRANCH IF NOT FINISHED.
         BR AFTER;                         "  FINISHED
              DPX(0)<MD                    "  SAVE REAL B
LEND:    FADD DPX(0),MD;                   "1.ADD REALS
              INCMA; MI<FA;                "2.STORE IMAG.
              BR LOOP                      "  LOOP
"
"        AFTERWORD
"
AFTER:   FADD DPY(0),DPX(0);               "1.ADD REALS
              INCMA; MI<FA                 "2.STORE IMAG
"
"        DROP PASS 1
"
DP1:     FSUB DPY(0),MD                    "2.SUBTRACT IMAG
         ADD K,C; SETMA; MI<FA;            "2.STORE REAL
              FADD                         "2.PUSH
         INCMA; MI<FA                      "2.STORE IMAG
         $ENDIF
S999:    RETURN
         $END
"MOVE1
         $TITLE MOVE1
         $ENTRY MOVE1,2
"
"     MOVE1(A,B) moves the contents of location A to location B
"     Timing = 0.8 microseconds
"     Programmer = W. D. Cotton
"
A        $EQU  0
B        $EQU  1
MOVE1:   MOV A,A; SETMA                    "FETCH A
         NOP
         NOP
         MOV B,B; SETMA; MI<MD             "STORE B
         RETURN
         $END
"SUB1
         $TITLE SUB1
         $ENTRY SUB1,3
"
"     SUB1(A,B,C) subtracts contents of A from contents of B and
"     puts the result in C.
"
"     Timing = 1.5 microseconds
"     Programmer = W. D. Cotton
"
A        $EQU  0
B        $EQU  1
C        $EQU  2
SUB1:    MOV A,A; SETMA                     "FETCH A
         NOP                                "WAIT
         MOV B,B; SETMA                     "FETCH B
         DPX<MD                             "SAVE A
         NOP                                "WAIT
         FSUBR DPX,MD                       "SUBTRACT
         FADD                               "PUSH ADDER
         MOV C,C; SETMA; MI<FA              "STORE C
         RETURN
         $END
"SQMUL
         $TITLE SQMUL
         $ENTRY SQMUL,3
"
"     SQMUL(VALUE,C,D) floats and squares integer VALUE and multiplies
"     by the value in C and stores the result in D.
"                     VALUE = input integer
"                     C = Source AP location
"                     D = Destination AP location
"
"     Timing = 2.2 microseconds
"     Programmer = W. D. Cotton, July 1980.
"
VALUE    $EQU  0
C        $EQU  1
D        $EQU  2
C27      $EQU  3
"
SQMUL:   LDSPI C27; DB=27.                   "27 TO C27 FOR FLOAT
         MOV VALUE,VALUE; DPX(0)<SPFN        "VALUE TO DPX
         FADD ZERO,MDPX(0); MOV C27,C27      "FLOAT VALUE
         MOV C,C; SETMA;                     "FETCH C
              FADD                           "PUSH
         DPX(0)<FA                           "VALUE TO DPX FOR SQUARE
         FMUL DPX(0),FA                      "SQUARE VALUE
         FMUL                                "PUSH
         FMUL                                "PUSH
         FMUL FM,MD                          "MULT C BY VALUE**2
         FMUL                                "PUSH
         FMUL                                "PUSH
         MOV D,D; SETMA; MI<FM               "STORE D
         RETURN
         $END
"PHSROT
         $TITLE PHSROT
         $ENTRY PHSROT,7
"
"    MICROCODE ROUTINE FOR FPS AP-120B ARRAY PROCESSOR
"
"     PHSROT adds a phase gradient to a complex vector.
"
"     B(j) = A(j) * EXP ( -i * (PHAS0 + j * DELPHS)) j=0,N-1
"
"     CALLING SEQUENCE - CALL PHSROT(A,I,B,J,PHAS0,DELPHS,N)
"                        A = Source vector base address
"                        I = Increment of A
"                        B = Destination vector base address
"                        J = Increment of B
"                        PHAS0 = Address of complex unit vector with
"                                phase PHAS0 (cos,sin)
"                        DELPHS = Address of complex unit vector with
"                                phase DELPHS (cos,sin)
"                        N = Element count
"
"     Should work for fast or slow AP memory.
"     Timing = 2.0 + 1.3 N microseconds.
"
"     Programmer = W. D. Cotton, July 1980.
"
"        SET SPADS
"
A        $EQU  0
I        $EQU  1
B        $EQU  2
J        $EQU  3
PHAS0    $EQU  4
DELPHS   $EQU  5
N        $EQU  6
"
"        SET DATA PAD ASSIGNMENTS
"
SPH      $EQU  1             "DPX(1) = SIN(PHASE)
CPH      $EQU  1             "DPY(1) = COS(PHASE)
SDPH     $EQU  2             "DPX(2) = DPY(2) = SIN(DELPHS)
CDPH     $EQU  3             "DPX(3) = DPY(3) = COS(DELPHS)
TEMP     $EQU -1             "DPX(-1) AND DPY(-1) USED AS TEMP STORAGE
"
"        GET PHASE ROTATION VALUES
"
PHSROT:  MOV DELPHS,DELPHS; SETMA           "FETCH COS(DELPHS)
         NOP                              "WAIT
         INCMA                            "FETCH SIN(DELPHS)
         DPY(CDPH)<MD; DPX(CDPH)<MD;      "SAVE COS(DELPHS)
              MOV N,N                     "CHECK IF N<1
         MOV PHAS0,PHAS0; SETMA;        "FETCH COS(PHAS0)
              BGT NEXT                    "BRANCH IF N>0
         JMP S999                         "N <= 0 - RETURN
NEXT:    DPY(SDPH)<MD; DPX(SDPH)<MD       "SAVE SIN(DELPHS)
         INCMA                            "FETCH SIN(DELPHS)
         DPY(CPH)<MD                      "SAVE COS(PHAS0)
         NOP                              "WAIT FOR MEMORY
         FMUL DPY(CDPH),MD;               "0.SIN(PH)*COS(DPH)
              DPX(SPH)<MD                 "  SAVE SIN(PH)
"
"        START PASS1
"
         MOV A,A; SETMA;                  "1.FETCH REAL(VECTOR)
              FMUL DPY(CPH),DPX(SDPH)     "1.COS(PH)*SIN(DPH)
         FMUL DPY(CPH),DPX(CDPH);         "1.COS(PH)*COS(DPH)
              SUB J,B                     "  DECREMENT B BEFORE LOOP
         INCMA;                           "1.FETCH IMAG(VECTOR)
              FMUL DPX(SPH),DPY(SDPH);    "1.SIN(PH)*SIN(DPH)
              DPX(TEMP)<FM                "1.SAVE SIN(PH)*COS(DPH)
         FMUL DPY(CPH),MD;                "1.COS(PH)*RE(VEC)
              FADD FM,DPX(TEMP)           "1.NEW SIN(PH)
         FMUL DPX(SPH),MD;                "1.SIN(PH)*RE(VEC)
              DPY(TEMP)<FM;               "1.SAVE SIN(PH)*COS(DPH)
              FADD                        "1.PUSH
         FMUL DPX(SPH),MD;                "1.SIN(PH)*IM(VEC)
              FSUBR FM,DPY(TEMP);         "1.NEW COS(PH)
              DPX(SPH)<FA                 "1.STORE NEW SIN(PH)
         FMUL DPY(CPH),MD;                "1.COS(PH)*IM(VEC)
              FADD FM,ZERO;               "1.SAVE COS(PH)*RE(VEC) IN FA
              DEC N                       "  DECREMENT LOOP COUNT
         FMUL DPX(SPH),DPY(CDPH);         "1.SIN(PH)*COS(DPH)
              FADD FM,ZERO;               "1.SAVE SIN(PH)*RE(VEC) IN FA
              DPY(CPH)<FA;                "1.SAVE NEW COS(PH)
              BGT LOOP                    "  BRANCH IF N>1
         JMP DP1                          "  N=1 - SKIP LOOP
"
"        BEGIN LOOP
"
LOOP:    ADD I,A; SETMA;                  "1.FETCH RE(VEC)
              FSUBR FM,FA;                "2.NEW RE(VEC)
              FMUL DPY(CPH),DPX(SDPH)     "1.COS(PH)*SIN(DPH)
         FADD FM,FA;                      "2.NEW IM(VEC)
              FMUL DPY(CPH),DPX(CDPH)     "1.COS(PH)*COS(DPH)
         INCMA;                           "1.FETCH IM(VEC)
              FMUL DPX(SPH),DPY(SDPH);    "1.SIN(PH)*SIN(DPH)
              DPX(TEMP)<FM                "1.SAVE SIN(PH)*COS(DPH)
         FMUL DPY(CPH),MD;                "1.COS(PH)*RE(VEC)
              FADD FM,DPX(TEMP);          "1.NEW SIN(PH)
              DPY(TEMP)<FA                "2.SAVE NEW RE(VEC)
         FMUL DPX(SPH),MD;                "1.SIN(PH)*RE(VEC)
              ADD J,B; SETMA; MI<DPY(TEMP);"2.STORE NEW RE(VEC)
              DPY(TEMP)<FM;               "1.SAVE SIN(PH)*COS(DPH)
              FADD ZERO,FA                "2.SAVE NEW IM(VEC) IN FA
         FMUL DPX(SPH),MD;                "1.SIN(PH)*IM(VEC)
              FSUBR FM,DPY(TEMP);         "1.NEW COS(PH)
              DPX(SPH)<FA                 "1.STORE NEW SIN(PH)
         FMUL DPY(CPH),MD;                "1.SIN(PH)*IM(VEC)
              FADD FM,ZERO;               "1.SAVE COS(PH)*RE(VEC) IN FA
              INCMA; MI<FA;               "2.STORE NEW IM(VEC)
              DEC N                       "  DECREMENT LOOP COUNT
         FMUL DPX(SPH),DPY(CDPH);         "1.SIN(PH)*COS(DPH)
              FADD FM,ZERO;               "1.SAVE SIN(PH)*RE(VEC) IN FA
              DPY(CPH)<FA;                "1.SAVE NEW COS(PH)
              BGT LOOP
"
"       DROP PASS1
"
DP1:    FSUBR FM,FA;                      "2.NEW RE(VEC)
             FMUL                         "2.PUSH
        FADD FM,FA                        "2.NEW IM(VEC)
        MOV A,A; SETMA; MI<FA;            "2.STORE NEW RE(VEC)
             FADD                         "2.PUSH
        INCMA; MI<FA                      "2.STORE NEW IM(VEC)
"
"       FINISHED - RETURN
"
S999:   RETURN
        $END
"BOXSUM
         $TITLE BOXSUM
         $ENTRY BOXSUM,6
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     BOXSUM does a boxcar sum on a vector; values at the ends of
"     the vector are the sum of the values within one boxcar
"     length of the ends.
"
"     CALLING SEQUENCE - CALL BOXSUM(A,I,NB,C,J,N)
"                         A = Base address of source vector
"                         I = Increment of A
"                         NB = Width of the boxcar
"                         C = Destination vector base address;
"                              the destination vector should not overlap
"                              the source vector.
"                         J = Increment of C
"                         N = Element count
"
"     Should work for either fast or slow memory.
"     Timing = 2.5 + 1.0 N microseconds.
"     Programmer = W. D. Cotton, September 1980.
"
"        SET SPAD ASSIGNMENTS
"
A        $EQU  0
I        $EQU  1
NB       $EQU  2
C        $EQU  3
J        $EQU  4
N        $EQU  5
"
LOOP     $EQU  6                  "LOOP COUNTER
AA       $EQU  7                  "POINTER IN SOURCE VECTOR
EVEODD   $EQU  8.                 " -1 IFF NB ODD, 0 IFF  NB EVEN
RADIUS   $EQU  9.                 "RADIUS OF BOXCAR
"
"          SUM FIRST BOXCAR LENGTH
"
BOXSUM:  MOV NB,LOOP              "PREPARE LOOP COUNT
         SUB I,A;                 "DECREMENT A BEFORE LOOPS
              BGT .+2             "MAKE SURE NB > 0
         JMP S999                 "NB <= 0 - RETURN
         MOV N,N                  "MAKE SURE N > 0
         SUB J,C;                 "DECREMENT C BEFORE LOOPS
              BGT .+2             "CHECK N
         JMP S999                 "N <= 0 - RETURN
         MOV A,AA                 "KEEP POINTER FOR A
         FADD ZERO,ZERO           "CLEAR FA
LOOP1:   ADD I,A; SETMA           "FETCH VALUE
         FADD                     "PUSH ADDER
         DPX(0)<FA;               "SAVE FA
              DEC LOOP            "DECREMENT LOOP COUNTER
         FADD DPX(0),MD;          "SUM VALUE
              BGT LOOP1           "LOOP
"
"              MAKE NB THE RADIUS OF THE BOXCAR
"
         MOVR NB,EVEODD           "SET EVEODD TO NB/2
         MOV NB,RADIUS            "COMPUTE RADIUS
         INC RADIUS               "RADIUS = NB + 1
         MOVR RADIUS,RADIUS       "RADIUS => (NB+1)/2
         SUB RADIUS,EVEODD        "FINISH EVEODD
"
"        SET FRONT OF VECTOR TO CONSTANT VALUE
"
         FADD;                    "PUSH
              MOV RADIUS,LOOP     "PREPARE LOOP COUNTER
LOOP2:   DEC LOOP                 "DECREMENT LOOP COUNTER
         ADD J,C; SETMA; MI<FA;   "STORE SUM
              BGT LOOP2           "LOOP
"
"        BEGIN MAIN LOOP
"
         MOV N,LOOP               "PREPARE LOOP COUNTER
         ADD I,A; SETMA           "FETCH NEXT VALUE
         SUB NB,LOOP              "LOOP COUNT = N - NB
         ADD I,AA; SETMA          "FETCH VALUE TO DROP FROM SUM
         DPX(0)<MD;               "SAVE VALUE TO ADD
              DEC LOOP            "DECREMENT LOOP COUNTER
         BEQ DP1; BLT DP1         "CHECK LOOP COUNT
"
"        MAIN LOOP
"
LOOP3:   FADD DPX(0),FA           "ADD NEXT VALUE
         ADD I,A; SETMA;          "FETCH NEXT VALUE TO ADD
              FADD                "PUSH
         DPY(0)<FA                "SAVE SUM
         ADD I,AA; SETMA;         "FETCH VALUE TO DROP FROM SUM
              FSUB DPY(0),MD      "DROP VALUE FROM SUM
         DPX(0)<MD;               "SAVE VALUE TO ADD
              FADD;               "PUSH
              DEC LOOP            "DECREMENT LOOP COUNTER
         ADD J,C; SETMA; MI<FA;   "STORE SUM
              BGT LOOP3           "LOOP
"
"        DROP FIRST PASS
"
DP1:     FADD DPX(0),FA           "ADD NEXT VALUE
         FADD                     "PUSH
         DPY(0)<FA                "SAVE SUM
         FSUB DPY(0),MD           "DROP VALUE FROM SUM
         FADD                     "PUSH
         ADD J,C; SETMA; MI<FA    "SAVE SUM
"
         DEC NB                   "CHECK IF NB=1
         BEQ S999                 "NB = 1 - RETURN
"
"        SET END OF VECTOR TO CONSTANT VALUE
"
         ADD EVEODD,RADIUS        "PREPARE LOOP COUNTER
LOOP4:   DEC RADIUS               "DECREMENT LOOP COUNTER
         ADD J,C; SETMA; MI<FA;   "STORE VALUE
              BGT LOOP4           "LOOP
S999:    RETURN
         $END
"APGRD2
         $TITLE APGRD2
         $ENTRY APGRD2,9.
"
"     MICROCODE ROUTINE FOR FPS 120-B ARRAY PROCESSOR
"
"     APGRD2 convolves linear polarization visibility data into a
"     grid.  Accumulates two independent visibility channels with
"     the same convolution and weighting. Does nothing if WT not
"     positive or the point is too far off the end of the row.
"
"     CALLING SEQUENCE - CALL APGRD2(UV,VIS,WT,GRID,CONX,CONY,NO2,
"                          M,LROW)
"
"                        UV = Location of (u,v) values in cells.
"                        VIS = Location of (complex) visibilities.
"                        WT = Weight for data. Assumes any tapering
"                             has already been done.
"                        GRID = base address of gridded data.
"                               Order assumed to be the following
"                               for each of the M rows:
"                               1) 2 * LROW visibilities
"                               2) 2*LROW (count,sum weights)
"                        CONX = base address of X convolving fn.
"                        CONY = base address of Y convolving fn.
"                        NO2 = INT( (# cells used on a row) / 2 )
"                        M = number of rows kept in the AP.
"                        LROW = length of a row.
"                        In the above, X refers to rows and y to columns
"                        in the gridded data, NOT on the sky.  The total
"                        numbers of rows and cells used on a row should
"                        be odd.
"                        LROW = length of a row ( max. X).
"
"
"     All AP memory I/O values are assumed floating.
"     It is assumed that all values of v correspond to row M/2.
"
"     Source contains versions for both fast and slow AP memory
"
"     Programmer: W. D. Cotton, July 1980.
"
"        SET SPAD ASSIGNMENTS
"
UV       $EQU  0
VIS      $EQU  1
WT       $EQU  2
GRID     $EQU  3
CONX     $EQU  4
CONY     $EQU  5
NO2      $EQU  6
M        $EQU  7
LROW     $EQU  8.
"
"        SET WORK SPAD ASSIGMNENTS
"
IX       $EQU  0
FOUR     $EQU  0
GRID2    $EQU  1                          "VIS2 GRID
N        $EQU  9.
IN       $EQU  10.
ICONX    $EQU  11.
INCR     $EQU  12.
C27      $EQU  13.
WTX      $EQU  13.
TWO      $EQU  13.
WTY      $EQU  14.
HAF      $EQU  14.
IADD     $EQU  14.
IHUN     $EQU  15.
"
"       INSIDE THE LOOPS THE INPUT DATA ARE LOCATED AS FOLLOWS:
"
"       DPX(-1) = WEIGHT
"       DPX(0)  = REAL ( VIS1 )
"       DPX(1)  = REAL ( VIS2 )
"       DPY(0)  = IMAG ( VIS1 )
"       DPY(1)  = IMAG ( VIS2 )
"
"       SET FLAG FOR MEMORY SPEED FSSLO = 1 FOR FAST, 0 FOR SLOW
"
         FSSLO = 1
"
"        COMPUTE POINTERS AND FETCH DATA.
"
APGRD2:  INC UV; SETMA                    "FETCH X
         LDTMA; DB=!HALF                  "0.5 TO TM
         LDSPI IHUN; DB=100.              "100 TO IHUN
         LDSPI C27;  DB=27.               "C27 = CONST FOR FLOATING
         DECMA;                           "FETCH Y
              MOVR LROW,HAF               "HAF = LROW / 2
         FIX MD;                          "FIX X (ROUNDED)
              MOV IHUN,IHUN; DPX(3)<SPFN  "100 TO DPX(3) FOR FLOAT
         MOV VIS,VIS; SETMA;              "FETCH REAL VIS1
              FADD TM,MD                  "ADD 0.5 TO X
         FADD ZERO,MDPX(3); MOV C27,C27;  "FLOAT 100
              DPX(2)<FA;                  "SAVE FIXED X
              DPY(-1)<MD                  "SAVE Y
         FIX DPY(-1);                     "FIX Y (ROUNDED)
              DPY(1)<FA                   "SAVE X+0.5 IN DPY(1)
         LDSPI IX; DB=DPX(2);             "FIXED X TO IX
              FADD TM,DPY(-1);            "ADD 0.5 TO Y
              DPX(3)<FA                   "SAVE 100.0 IN DPY(3)
         INCMA;                           "FETCH IMAG VIS1
              FADD ZERO,MDPX(2);MOV C27,C27;" FLOAT IX
              DPX(-2)<FA                  "FIXED Y TO DPX(-2)
         INC HAF;                         "HAF = LROW / 2 + 1
              DPY(-1)<FA;                 "SAVE Y+0.5 IN DPY(-1)
              FADD                        "PUSH
         ADD HAF,IX;                      "ADD BIAS TO IX
              DPX(0)<MD;                  "SAVE REAL VIS1
              FSUBR DPY(1),FA             "IX - X - 0.5
         MOV LROW,IADD;                   "CHECK FOR END OF ROW
              FADD                        "PUSH
         INCMA;                           "FETCH REAL(VIS2)
              DPY(0)<MD;                  "SAVE IMAG(VIS1) IN DPY(0)
              FMUL DPX(3), FA             "100.0 * ( IX - X - 0.5 )
         FADD ZERO,MDPX(-2); MOV C27,C27  "FLOAT FIXED Y
         SUB NO2,IADD;                    "CHECKING FOR END OF ROW
              FADD                        "PUSH
         SUB IX,IADD;                     "CHECKING FOR END OF ROW
              FSUBR DPY(-1),FA;           "FIX(Y) - Y - 0.5
              INCMA;                      "FETCH IMAG (VIS2 )
              DPX(1)<MD                   "SAVE RE ( VIS2 )
         MOVL NO2,N;                      "2*N/2 TO N
              FADD;                       "PUSH
              BGE .+4                     "BRANCH IF X UPPER LIMIT OK
"
"        HIT END OF ROW
"
         ADD IADD,N                       "REDUCE N FOR UPPER LIMIT
         BGT .+2                          "MAKE SURE N POSITIVE.
         JMP S999                         "N .LE. 0 - RETURN
"
         FMUL DPX(3),FA;                  "100.0*(FIX(Y)-Y-0.5)
              FADD;                       "PUSH
              MOVL LROW,GRID2             "CONSTRUCT GRID2 POINTER
         FMUL;                            "PUSH
              ADD GRID,GRID2;             "CONSTRUCT GRID2 POINTER
              DPY(1)<MD                   "SAVE IM (VIS2)
         DPY(3)<FM;                       "SAVE FM FOR FIX
              FMUL;                       "PUSH
              MOV WT,WT; SETMA            "FETCH WT
         INC N                            "N = 2 * NO2 + 1
         FIX DPY(3);                      "FIX XCONV. FN INDEX
              DPX(3)<FM                   "SAVE FM FOR FIX
         FIX DPX(3);                      "FIX Y CONV. FN INDEX
              DPX(-1)<MD                  "SAVE WT
         DPY(-1)<FA;                      "X CONV INDEX TO DPY(-1)
              FADD ZERO,MD                "CHECK THAT WEIGHT POSITIVE
         LDSPI WTX; DB=DPY(-1);           "X CONV. FN INDEX TO WTX
              DPY(-2)<FA;                 "Y CONV. FN INDEX TO DPY(-2)
              FADD                        "PUSH
         LDSPI WTY; DB=DPY(-2)            "Y CONV. FN INDEX TO WTY
         ADD WTX,CONX;                    "X CONV. FN. START ADDRESS
              BFGT .+2                    "BRANCH IF WEIGHT POSITIVE
         JMP S999                         "WT .LE. 0.0 - RETURN
         ADD WTY,CONY                     "Y CONV. FN START ADDRESS
         ADD IHUN,CONY                    "POINTER=100*(FIX(Y)-Y-.5)+100
                                          "100 ADDED TO CONX LATER
         SUB NO2,IX                       "CHECK FOR FRONT OF ROW
         DEC IX                           "CHECK IF IX .GE. NO2+1
         MOV CONX,ICONX;                  "SAVE POINTER
              BGE LONG                    "BRANCH IF FRONT OF ROW OK
"
"        FRONT OF ROW ENCOUNTERED
"
         ADD IX,N                         "REDUCE N
         BGT .+2                          "MAKE SURE N POSITIVE
         JMP S999                         "N .LE. 0 - RETURN
         CLR IADD
         SUB IX,IADD
         DEC IADD                         "UPDATE
         ADD IHUN,CONX;                   "        CONX
              BGT .-1
         MOV CONX,ICONX;                  "SAVE NEW VALUE OF CONX
              BR START
"
LONG:    ADD IX,IX                        "BECAUSE VALUES ARE COMPLEX
         ADD IX,GRID                      "FINISH VIS1 POINTER
         ADD IX,GRID2                     "FINISH VIS2 POINTER
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
"
START:   MOVL LROW,INCR                   "2*LROW TO INCR
         SUB N,INCR
         ADD INCR,INCR                    "INCR = 4*LROW-2*N
         MOV N,IN                         "SET INNER LOOP COUNTER
         DEC GRID                         "DECREMENT GRID BEFORE LOOP
         DEC GRID2                        "DECREMENT GRID2 BEFORE LOOP.
LOOP:    ADD IHUN,ICONX; SETMA            "FETCH CONV X (CX)
         NOP                              "WAIT
         MOV CONY,CONY; SETMA             "FETCH CONV. Y (CY)
         FMUL DPX(-1),MD                  "CX * WT
         FMUL                             "PUSH
         FMUL                             "PUSH
         INC GRID;SETMA;                  "FETCH SUM REAL(VIS1)
              FMUL FM,MD                  "CY * CX * WT = W
         FMUL                             "PUSH
         INC GRID; SETMA;                 "FETCH SUM IMAG(VIS1)
              FMUL                        "PUSH
         FMUL FM,DPX(0);                  "W * RE(VIS1)
              FADD FM,ZERO;               "SAVE W IN FA
              DPX(-4)<MD                  "SAVE SUM RE(VIS1)
         INC GRID2; SETMA;                "FETCH SUM REAL(VIS2)
              FMUL; FADD                  "PUSH
         FMUL DPY(0),FA;                  "W * IM(VIS1)
              FADD ZERO,FA;               "SAVE W IN FA
              DPX(-3)<MD                  "SAVE SUM IM(VIS1)
         INC GRID2; SETMA;                "FETCH SUM IM(VIS2)
              FADD FM,DPX(-4);            "SUM REAL(VIS1)
              FMUL                        "PUSH
         FMUL DPX(1),FA;                  "W * RE(VIS2)
              FADD ZERO,FA;               "SAVE W IN FA
              DPX(-2)<MD                  "SAVE SUM RE(VIS2)
         DEC GRID; SETMA; MI<FA;          "STORE NEW SUM RE(VIS1)
              FADD FM,DPX(-3);            "SUM IMAG(VIS1)
              FMUL                        "PUSH
         FMUL DPY(1),FA;                  "W * IM(VIS2)
              FADD                        "PUSH
         INC GRID; SETMA; MI<FA;          "STORE NEW SUM IM(VIS1)
              FADD FM,DPX(-2);            "SUM RE(VIS2)
              FMUL                        "PUSH
         FADD; FMUL                       "PUSH
         DEC GRID2; SETMA; MI<FA;         "SAVE NEW SUM RE(VIS2)
              FADD FM,MD                  "SUM IM(VIS2)
         DEC IN;                          "DECREMENT LOOP COUNTER
              FADD                        "PUSH
         INC GRID2; SETMA; MI<FA;         "STORE NEW SUM IM(VIS2)
              BGT LEND                    "BRANCH IF INNER LOOP NOT
                                          "FINISHED
"
"        INNER LOOP FINISHED
"
         DEC M                            "DECREMENT OUTER LOOP COUNTER
         MOV CONX,ICONX;                  "RESET X CONV. FN POINTER
              BGT .+2                     "CHECK IF FINISHED
         BR S999                          "FINISHED - RETURN
         ADD IHUN,CONY                    "UPDATE Y CONV. FN POINTER
         ADD INCR,GRID2                   "UPDATE VIS2 POINTER
         ADD INCR,GRID                    "UPDATE VIS1 POINTER
         MOV N,IN                         "RESET INNER LOOP COUNTER
LEND:    JMP LOOP                         "LOOP
         $ENDIF
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
"        PREPARE POINTERS
"
START:   LDSPI FOUR; DB=4.               "4 TO FOUR
         LDSPI TWO; DB=2.                "2 TO TWO
         MOVL LROW,INCR                  "
         SUB N,INCR                      "MAKE GRID INCREMENT
         INC INCR
         ADD INCR,INCR                   "INCR = 4*LROW-2*N+2
         SUB INCR,GRID                   "DECREMENT GRID BEFORE LOOP
         SUB INCR,GRID2                  "DECREMENT GRID2 BEFORE LOOP
         SUB IHUN,CONY                   "SET CONY FOR FAST MEMORY
         ADD IHUN,CONX                   "SET CONX FOR FAST MEMORY
"
"        BEGIN OUTER LOOP
"
OLOOP:   MOV CONX,ICONX; SETMA           "1. FETCH CX
         ADD IHUN,CONY; SETMA            "1. FETCH CY
         ADD INCR,GRID; SETMA            "1. FETCH SUM RE(VIS1)
         INCMA;                          "1. FETCH SUM IM(VIS1)
              FMUL DPX(-1),MD            "1. WT * CX
         ADD INCR,GRID2; SETMA;          "1. FETCH SUM RE(VIS2)
              FMUL;                      "1. PUSH
              DPX(-2)<MD                 "1. SAVE CY IN DPX(-2)
         INCMA;                          "1. FETCH SUM IM(VIS2)
              FMUL;                      "1. PUSH
              DPX(2)<MD;                 "1. SAVE SUM RE(VIS1)
              MOV N,IN                   "   SET INNER LOOP COUNTER
         FMUL FM,DPX(-2);                "1. WT * CX * CY = W
              DPY(-3)<MD;                "1. SAVE SUM IM(VIS1)
              SUB TWO,GRID               "    SET GRID FOR INNER LOOP
         FMUL;                           "1. PUSH
              DPX(-4)<MD;                "1. SAVE SUM RE(VIS2)
              SUB TWO,GRID2              "   SET GRID2 FOR INNER LOOP
         FMUL;                           "1. PUSH
              DPX(-3)<MD;                "1. SAVE SUM IM(VIS2)
              DEC IN                     "   DECREMENT INNER LOOP COUNTE
         FMUL FM,DPX(0);                 "1. W * RE(VIS1)
              DPX(-2)<FM;                "1. SAVE W IN DPX(-2)
              FADD FM,ZERO;              "1. SAVE W IN FA
              BGT .+2                    "   CHECK IF INNER LOOP FINISHE
         JMP DP1                         "FINISHED INNER LOOP (N=1)
"
"        BEGIN INNER LOOP
"
ILOOP:   ADD IHUN,ICONX; SETMA;          "1. FETCH CX
              FMUL DPY(0),DPX(-2);       "2. W * IM(VIS1)
              FADD                       "2. PUSH
         MOV CONY,CONY; SETMA;           "1. FETCH CY
              FMUL DPX(1),FA             "2. W * RE(VIS2)
         ADD FOUR,GRID; SETMA;           "1. FETCH SUM RE(VIS1)
              FMUL DPY(1),FA;            "2. W*IM(VIS2)
              FADD FM,DPX(2)             "2. SUM RE(VIS1)
         INCMA;                          "1. FETCH IM(VIS1)
              FMUL DPX(-1),MD;           "1. WT * CX
              FADD FM,DPY(-3)            "2. SUM IM(VIS1)
         ADD FOUR,GRID2; SETMA;          "1. FETCH RE ( VIS2 )
              FMUL;                      "1. PUSH
              DPX(-2)<MD;                "1. SAVE CY
              FADD FM,DPX(-4);           "2. SUM RE(VIS2)
              DPY(2)<FA                  "2. SAVE SUM RE(VIS1)
         INCMA;                          "1. FETCH SUM IM(VIS2)
              FMUL;                      "1. PUSH
              DPX(2)<MD;                 "1. SAVE SUM RE(VIS1)
              FADD FM,DPX(-3);           "2. SUM IM(VIS2)
              DPY(3)<FA                  "2. SAVE SUM IM(VIS1)
         FMUL FM, DPX(-2);               "1. WT*CX*CY = W
              DPY(-3)<MD;                "1. SAVE OLD SUM IM(VIS1)
              SUB TWO,GRID2; SETMA;
                   MI<FA;                "2. STORE NEW SUM RE(VIS2)
              FADD ZERO,DPY(2)           "2. SAVE NEW SUM RE(VIS1) IN FA
         FMUL;                           "1. PUSH
              DPX(-4)<MD;                "1. SAVE OLD SUM RE(VIS2)
              INCMA; MI<FA;              "2. STORE NEW SUM IM(VIS2)
             FADD ZERO,DPY(3);           "2. SAVE NEW SUM IM(VIS1) IN FA
              DEC IN                     "   DECREMENT INNER LOOP COUNTE
         FMUL;                           "1. PUSH
              DPX(-3)<MD;                "1. SAVE OLD SUM IM(VIS2)
              SUB TWO,GRID; SETMA; MI<FA;"2. STORE NEW SUM RE(VIS1)
              FADD;                      "2. PUSH
              BGT .+2                    "   CHECK IF INNER LOOP FINISHE
        BR .+2                           "   FINISHED INNER LOOP
        FMUL FM,DPX(0);                  "1. W * RE(VIS1)
             DPX(-2)<FM;                 "1. SAVE W IN DPX(-2)
             FADD FM,ZERO;               "1. SAVE W IN FA
             INCMA; MI<FA;               "2. STORE NEW SUM IM(VIS1)
             BR ILOOP                    "   LOOP
"
"        FINISHED INNER LOOP
"
         FMUL FM,DPX(0);                 "1. W * RE(VIS1)
              DPX(-2)<FM;                "1. SAVE W IN DPX(-2)
              FADD FM,ZERO;              "1. SAVE W IN FA
              INCMA; MI<FA               "2. STORE NEW SUM IM(VIS1)
"
"        DROP PASS1
"
DP1:     FMUL DPY(0),DPX(-2);            "2. W * IM(VIS1)
              FADD                       "2. PUSH
         FMUL DPX(1),FA                  "2. W * RE(2)
         FMUL DPY(1),FA;                 "2. W * IM(VIS2)
              FADD FM,DPX(2)             "2. SUM RE(VIS1)
         FADD FM,DPY(-3);                "2. SUM IM(VIS1)
              FMUL                       "2. PUSH
         FADD FM,DPX(-4);                "2. SUM RE(VIS2)
              DPX(2)<FA;                 "2. SAVE NEW SUM RE(VIS1)
              FMUL                       "2. PUSH
         FADD FM,DPX(-3);                "2. SUM IM(VIS2)
              DPX(3)<FA                  "2. SAVE NEW SUM IM(VIS1)
         ADD TWO,GRID; SETMA; MI<DPX(2)  "2. STORE NEW SUM RE(VIS1)
         INCMA; MI<DPX(3)                "2. STORE NEW SUM IM(VIS1)
         ADD TWO,GRID2; SETMA; MI<FA;    "2. STORE NEW SUM RE(VIS2)
              FADD                       "2. PUSH
         DEC M                           "   DECREMENT OUTER LOOP COUNT
         INCMA; MI<FA;                  "2. STORE NEW SUM IM(VIS2)
            BGT .+2                     "  CHECK OUTER LOOP
         JMP S999                       "   FINISHED - RETURN
         JMP OLOOP                      "   OUTER LOOP
         $ENDIF
S999:    RETURN
         $END
"BAKSUB
         $TITLE BAKSUB
         $ENTRY BAKSUB,5
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     BAKSUB does the following loop:
"
"     DO K = N-2, 1, -1
"        B(K) = (B(K) - D(K) * B(K+1) - E(K) * B(K+2)) * CI(K)
"
"     CALLING SEQUENCE - CALL BAKSUB(B,D,E,CI,N)
"                        B = first vector, increment=1, also destination
"                        D = second vector, increment = 1
"                        E = third vector, increment = 1
"                        CI = fourth vector, increment = 1
"                        N = element count.
"
"     Should work for either fast or slow AP memory.
"
"     Timing = 0.5 + 1.7 (N-2) Microseconds.
"
"     Programmer: W. D. Cotton, Nov. 1980
"
"         SET SPAD ASSIGNMENTS
"
B         $EQU  0
D         $EQU  1
E         $EQU  2
CI        $EQU  3
N         $EQU  4
"
"         SET WORK ASSIGNMENTS
"
LCNT      $EQU  5.                   "LOOP COUNTER
"
"         SET DPA ASSIGNMENTS
"
K         $EQU   0.                  "DPX(0)  =     B(K)
KP1       $EQU   1.                  "DPX(1)  =     B(K+1)
KP2       $EQU   2.                  "DPX(2)  =     B(K+2)
EBT       $EQU   0.                  "DPY(0) = TEMP. E(K)*B(K+2)
CIT       $EQU   1.                  "DPY(1) = TEMP. CI(K)
"
"     BEGIN
"
BAKSUB:   LDSPI LCNT; DB=-3.         "PREPARE LOOP COUNTER.
          ADD N,LCNT                 "LCNT = N - 3
          ADD N,B                    "PREPARE B ADDRESS
          DEC B; SETMA               "FETCH B(K+2)
          ADD LCNT,D                 "PREPARE D ADDRESS
          DEC B; SETMA               "FETCH B(K+1)
          ADD LCNT,CI;               "PREPARE CI ADDRESS
               DPX(KP2)<MD           "SAVE B(K+2)
"
"         BEGIN FIRST PASS
"
          ADD LCNT,E; SETMA          "1. FETCH E(K)
          DPX(KP1)<MD                "   SAVE B(K+1)
          MOV D,D; SETMA             "1. FETCH D(K)
          FMUL DPX(KP2),MD           "1. E(K) * B(K+2)
          DEC B; SETMA;              "1. FETCH B(K)
               FMUL                  "1. PUSH
          FMUL DPX(KP1),MD           "1. D(K) * B(K+1)
          MOV CI,CI; SETMA;          "1. FETCH CI(K)
               FMUL;                 "1. PUSH
               DPY(EBT)<FM           "1. SAVE E * B
          DPX(K)<MD;                 "1. SAVE OLD B
               FMUL;                 "1. PUSH
               INC B                 "   PREPARE B FOR LOOP
          FADD FM,DPY(EBT);          "1. E*B + D*B
               MOV LCNT,LCNT         "   CHECK IF FINISHED.
          FADD;                      "1. PUSH
             DPX(KP2)<DPX(KP1);      "1. UPDATE B(K+2)
               BEQ DP1; BLT DP1      "   IF FINISHED GO TO DP1
"
"         BEGIN LOOP
"
LOOP:     DEC E; SETMA;              "1. FETCH E(K)
              FSUB DPX(K),FA         "2. B - (E*B + D*B)
          DEC B;                     "1. PREPARE B
               FADD;                 "2. PUSH
               DPY(CIT)<MD           "2. SAVE CI(K)
          DEC D; SETMA;              "1. FETCH D(K)
               FMUL DPY(CIT),FA      "2. CI *(B-(EB+DB))
          FMUL DPX(KP2),MD           "1. E*B(K+2)
          DEC B; SETMA;              "1. FETCH B(K)
               FMUL                  "   PUSH
          FMUL FM,MD;                "1. D*B(K+1)
               DPX(KP1)<FM           "2. SAVE NEW B(K)
          DEC CI; SETMA;             "1. FETCH CI(K)
               DPY(EBT)<FM;          "1. SAVE E*B
               FMUL                  "1. PUSH
          DPX(K)<MD;                 "1. SAVE OLD B(K)
               FMUL;                 "1. PUSH
               DEC LCNT              "   DECREMENT LOOP COUNT
          FADD FM,DPY(EBT);          "1. E*B + D*B
               INC B; SETMA;MI<DPX(KP1);"2. STORE NEW B(K)
               BGT .+2               "   CHECK IF FINISHED
          JMP LEND                   "   EXIT LOOP
          FADD;                      "1. PUSH
               DPX(KP2)<DPX(KP1);    "   UPDATE B(K+2)
               BR LOOP               "   LOOP
"
"         FINISHED
"
LEND:     FADD                       "1. PUSH
"
"         DROP PASS1
"
DP1:      FSUB DPX(K),FA             "2. B -(E*B + D*B)
          FADD;                      "2. PUSH
               DPY(CIT)<MD           "2. SAVE CI(K)
          FMUL DPY(CIT),FA           "2. CI*(B - (E*B + D*B))
          FMUL                       "2. PUSH
          FMUL                       "2. PUSH
          DEC B; SETMA; MI<FM;       "2. STORE NEW B(1)
               RETURN                "   RETURN
         $END
"VTRANS
         $TITLE VTRANS
         $ENTRY VTRANS,4
         $EXT VSWAP
         $EXT IMOD,IADD,ISUB,IMULT
"
"  MICROCODE ROUTINE FOR FPS AP-120B ARRAY PROCESSOR.
"  VTRANS transposes a row-stored MxN array of row vectors.
"  The algorithm works in place and is adapted from Boothroyd's
"  CACM alg. #302.
"
"  CALL SEQUENCE - CALL VTRANS(M,N,IAD,LV)
"                  M = No. col.
"                  N = No. row
"                  IAD = Base address
"                  LV = Length of vector
"
"  Integer arithmetic requiring more than 16 bits is done using
"  and storing integer values in the DPX and DPY registers.
"
"  Programmer: W. D. Cotton, March 1981.
"
"       INPUT PARAMETERS
"
M       $EQU  0.
N       $EQU  1.
IAD     $EQU  2.
LV      $EQU  3.
"
"       SPAD WORK VARIABLES.
"
IADI    $EQU  0.
IADJ    $EQU  2.
IN      $EQU  6.
MDMN    $EQU  7.
I       $EQU  8.
K       $EQU  9.
J       $EQU  10.
IL1     $EQU  11.
IDN     $EQU  12.
ITEMP   $EQU  13.
"
"       DPX AND DPY INTEGER VARIABLES
"
JN      $EQU  -1.                "DPX
J4      $EQU  -1.                "DPY
DLV     $EQU  -2.                "DPX
MNM1    $EQU  -2.                "DPY
JAD     $EQU  -3.                "DPX
WORK1   $EQU   0.                "DPX
WORK2   $EQU   0.                "DPY
"
"       BEGIN  - SETUP
"
VTRANS:  MOV LV,LV; DPX(DLV)<SPFN        "LV TO DPX
         MOV M,M; DPX(WORK1)<SPFN        "M TO DPX
         MOV N,IN; DPY(WORK2)<SPFN       "N TO DPX AND IN
         MOV IAD,IAD; DPX(JAD)<SPFN      "IAD TO DPX
         JSR IMULT                       "N*M
         DPY(WORK2)<DB; DB=1.            "1 TO DPY
         JSR ISUB                        "MNM1=N*M-1
         MOV IN,IN; DPY(WORK2)<SPFN      "N TO DPY
         DPY(MNM1)<DPX(WORK1);           "SAVE MNM1
              JSR ISUB                   "MDMN=MNM1-N
         LDSPI MDMN; DB=DPX(WORK1)       "MDMN TO SPAD
         LDSPI IDN; DB=DPY(MNM1)         "INIT IDN=MNM1-1
         DEC IDN                         "
         CLR K                           "INIT K=0
         LDSPI IL1; DB=1.                "INIT IL1=1
         MOV IL1,I                       "INIT I=IL1
"
"        BEGIN LOOP
"
S1:      INC I                           "I=I+1
         SUB# MDMN,K                     "IF(K-MDMN) 2,2,3
              BGT S3
S2:      ADD IN,K;                       "K=K+N
              BR S4                      "GO TO 4
S3:      SUB MDMN,K                      "K=K-MDMN
S4:      MOV K,J                         "J=K
S5:      SUB# IL1,J                      "IF (J.GE.IL1) GO TO 6
              BGE S6
         MOV J,J; DPX(WORK1)<SPFN        "J TO DPX
         MOV IN,IN; DPY(WORK2)<SPFN      "N TO DPY
         JSR IMULT                       "J*N TO DPX(WORK1)
         DPY(WORK2)<DPY(MNM1);           "MNM1 TO DPY(WORK2)
              JSR IMOD                   "J=MOD(J*N,MNM1)
         LDSPI J; DB=DPX(WORK1);         "SAVE J
              BR S5                      "GO TO 5
S6:      SUB# IL1,J                      "IF(J.EQ.IL1) GO TO 7
              BNE .+2
         JMP S7
         INC J                           "J=J+1
         DEC# I; DPX(WORK1)<SPFN         "I-1 TO DPX
         DPY(WORK2)<DPX(DLV);            "DLV TO DPY
              JSR IMULT                  "(I-1)*DLV
         DPY(WORK2)<DPX(JAD);            "IAD TO DPY(WORK2)
              JSR IADD                   "IADI=IAD+(I-1)*DLV
         LDSPI ITEMP; DB=DPX(WORK1)      "TEMP. IADI TO SPAD
         DEC# J; DPX(WORK1)<SPFN         "J-1 TO DPX
         DPY(WORK2)<DPX(DLV);            "DLV TO DPY
              JSR IMULT                  "(J-1)*DLV
         DPY(WORK2)<DPX(JAD);            "IAD TO DPY
              JSR IADD                   "IADJ=IAD+(J-1)*DLV
         LDSPI IADJ; DB=DPX(WORK1)       "IADJ TO SPAD
         MOV ITEMP,IADI                  "IADI TO SP(0)
         LDSPI 1; DB=1.                  "LOAD SP1 FOR VSWAP
         MOV 1,3                         "LOAD SP3 FOR VSWAP
         LDSPI 4; DB=DPX(DLV)            "LOAD SP4 = LV=DLV
         JSR VSWAP                       "SWAP ROW VECTORS.
S7:      MOV I,IL1                       "IL1=I
         SUB# IDN,I                      "IF(I.LT.IDN) GO TO 1
              BGE .+2
         JMP S1
         RETURN
         $END
"IMOD
         $TITLE IMOD
         $ENTRY IMOD
         $EXT DIV
"  MICROCODE ROUTINE FOR FPS AP-120B ARRAY PROCESSOR
"  IMOD returns DPX(0) modulo DPY(0) in DPX(0)
"  all input and output values assumed fixed.
"
"  Uses: DPX(0,1), DPY(0-2), SP(0), FA plus DIV
"  Timing: 7.0 microsecond.
"
"  Programmer: W. D. Cotton, March 1981.
"
C27      $EQU 0.
"        BEGIN
IMOD:    LDSPI C27; DB=27.            "SET CONSTANT FOR FLOATING
         FADD ZERO,MDPX(0); MOV C27,C27; "FLOAT ARG1=DPX(0)
              DPX(2)<DPY(0)           "MOV ARG2 TO DPX
         FADD ZERO,MDPX(2); MOV C27,C27 "FLOAT ARG2=DPY(0)
         FADD;                        "PUSH
              DPY(0)<FA               "FLOAT(ARG1) TO DPY
         DPX(0)<FA;                   "FLOAT(ARG2) TO DPX
              DPY(1)<DPY(0)           "STORE ARG1 IN DPY(1)
         JSR DIV                      "ARG1/ARG2
         FIXT DPX(0)                  "FIX RATIO
         FADD ZERO,MDPX(2);           "FLOAT ARG2 (AGAIN)
                   MOV C27,C27
         DPX(0)<FA                    "FIXED RATIO TO DPX
         FADD ZERO,MDPX(0);           "FLOAT RATIO
                   MOV C27,C27
         FADD;                        "PUSH
              DPX(1)<FA               "SAVE FLOAT(ARG2)
         FMUL DPX(1),FA               "ARG2*RATIO
         FMUL                         "PUSH
         FMUL                         "PUSH
         FSUBR FM,DPY(1)              "ARG1-ARG2*RATIO
         FADD                         "PUSH
         FIXT FA                      "FIX RESULT
         FADD                         "PUSH
         DPX(0)<FA;                   "RESULT TO DPX(0)
              RETURN
         $END
"IMULT
         $TITLE IMULT
         $ENTRY IMULT
"  MICROCODE ROUTINE FOR FPS AP 120B ARRAY PROCESSOR
"  IMULT  multiplies integers in DPX(0) and DPY(0) and returns
"  the result in DPX(0).
"  Uses: DPX(0,1), DPY(0), FA, SP(0), FM
"  Timing: 1.7 microsecond, 10 words.
"
"  Programmer: W. D. Cotton, March 1981.
"
C27      $EQU  0.
"
"        BEGIN
"
IMULT:   LDSPI C27; DB=27.                    "SET CONSTANT FOR FLOAT
         FADD ZERO,MDPX(0); MOV C27,C27;      "FLOAT ARG1
              DPX(1)<DPY(0)                   "ARG2 TO DPX(1)
         FADD ZERO,MDPX(1); MOV C27,C27       "FLOAT ARG2
         FADD;                                "PUSH
              DPY(0)<FA                       "FLOATED ARG1 TO DPY
         FMUL DPY(0),FA                       "ARG1*ARG2
         FMUL                                 "PUSH
         FMUL                                 "PUSH
         DPX(0)<FM                            "PRODUCT TO DPX
         FIX DPX(0)                           "FIX PRODUCT
         FADD                                 "PUSH
         DPX(0)<FA;                           "RESULT TO DPX(0)
              RETURN
         $END
"IADD
         $TITLE IADD
         $ENTRY IADD
"  MICROCODE ROUTINE FOR FPS AP 120B ARRAY PROCESSOR
"  IADD adds integers in DPX(0) and DPY(0) and returns the value
"  in DPX(0)
"  Uses: DPX(0,1), DPY(0), FA, SP(0)
"  Timing: 1.3 microsecond, 8 words.
"
"  Programmer: W. D. Cotton, March 1981.
"
C27      $EQU  0.
"
"        BEGIN
"
IADD:    LDSPI C27; DB=27.                    "SET CONSTANT FOR FLOAT
         FADD ZERO,MDPX(0); MOV C27,C27;      "FLOAT ARG1
              DPX(1)<DPY(0)                   "ARG2 TO DPX(1)
         FADD ZERO,MDPX(1); MOV C27,C27       "FLOAT ARG2
         FADD;                                "PUSH
              DPY(0)<FA                       "FLOATED ARG1 TO DPY
         FADD DPY(0),FA                       "ARG1+ARG2
         FADD                                 "PUSH
         FIX FA                               "FIX SUM
         FADD                                 "PUSH
         DPX(0)<FA;                           "RESULT TO DPX(0)
              RETURN
         $END
"ISUB
         $TITLE ISUB
         $ENTRY ISUB
"  MICROCODE ROUTINE FOR FPS AP 120B ARRAY PROCESSOR
"  ISUB subtracts integers in DPY(0) from DPX(0) and returns the value
"  in DPX(0)
"  Uses: DPX(0,1), DPY(0), FA, SP(0)
"  Timing: 1.3 microsecond, 8 words.
"
"  Programmer: W. D. Cotton, March 1981.
"
C27      $EQU  0.
"
"        BEGIN
"
ISUB:    LDSPI C27; DB=27.                    "SET CONSTANT FOR FLOAT
         FADD ZERO,MDPX(0); MOV C27,C27;      "FLOAT ARG1
              DPX(1)<DPY(0)                   "ARG2 TO DPX(1)
         FADD ZERO,MDPX(1); MOV C27,C27       "FLOAT ARG2
         FADD;                                "PUSH
              DPY(0)<FA                       "FLOATED ARG1 TO DPY
         FSUB DPY(0),FA                       "ARG1-ARG2
         FADD                                 "PUSH
         FIX FA                               "FIX SUM
         FADD                                 "PUSH
         DPX(0)<FA;                           "RESULT TO DPX(0)
              RETURN
         $END
"CVSDIV
         $TITLE CVSDIV
         $ENTRY CVSDIV,6.
         $EXT DIV,SQRT
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     CVSDIV divides a Complex vector with weights by a complex
"     scalar.  The complex vector is expected to have data in
"     the order real, imaginary, weight.  The weight is multiplied
"     by the amplitude of the complex scalar.
"     Since the element count is expected to be small the looping
"     is not very efficient.
"
"     CALLING SEQUENCE - CALL CVSDIV(A,I,B,C,J,N)
"                A = Source vector base address.
"                I = Increment of A (at least 3)
"                B = Complex scalar
"                C = Destination vector base address
"                J = Increment of C
"                N = Element count.
"
"     C(mJ) = (1./(B(1)**2+B(2)**2))*(A(mI)*B(1)+A(mI+1)*B(2))
"     C(mJ+1) = (1./B(1)**2+B(2)**2))*(A(mI+1)*B(1)-A(mI)*B(2))
"     C(mJ+2) = A(mI+2) * SQRT(B(1)**2+B(2)**2)  for m = 0, N-1
"
"     Timing = 14.7 + 2.2 * N microsec.
"     Should work for both fast and slow memory(?).
"
"         SET SPAD ASSIGNMENTS
"
A         $EQU  0
I         $EQU  1
B         $EQU  2
C         $EQU  3
J         $EQU  4
N         $EQU  5
"
"         SET DATA PAD ASSIGNMENTS
"
E         $EQU  3     "DPX(E) = B(1)/(B(1)**2+B(2)**2)
F         $EQU  3     "DPY(F) = B(2)/(B(1)**2+B(2)**2)
AMP       $EQU -1     "DPX(AMP) = B(1)**2 + B(2)**2
"                      IN LOOP DPX(AMP) => SQRT (DPX(AMP))
"
"         SETUP
"
CVSDIV:   MOV B,B; SETMA               "FETCH B(1)
          NOP                          "WAIT
          INCMA                        "FETCH B(2)
          DPX(E)<MD                    "SAVE B(1) IN E
          FMUL DPX(E),MD;              "B(1)**2
               SUB I,A                 "PREPARE A FOR LOOP
          DPY(F)<MD                    "SAVE B(2) IN F
          FMUL DPY(F),MD               "B(2)**2
          FMUL;                        "PUSH
               SUB J,C                 "PREPARE C FOR LOOP
          DPX<FM;                      "TEMP STORE FM
               FMUL;                   "PUSH
               INC C                   "SET C TO POINT TO WEIGHT
          FADD FM,DPX;                 "B(1)**2 + B(2)**2
               INC C                   "
          FADD;                        "PUSH
               DPY<DPX(E)              "E TO DPY FOR DIV
          DPX(AMP)<FA                  " SAVE AMP
          DPX<FA                       "AMP TO DPX FOR DIV
          JSR DIV                      "B(1) / AMP TO DPX
          DPX(E)<DPX                   "SAVE E
          DPX<DPX(AMP)                 "AMP TO DPX FOR DIV
          DPY<DPY(E)                   "B(2) TO DPY FOR DIV
          JSR DIV                      "B(2) / AMP TO DPX
          DPY(F)<DPX                   "SAVE F
          DPX<DPX(AMP)                 "AMP TO DPX FOR SQRT
          JSR SQRT                     "SQRT (AMP)
          DPX(AMP)<DPX                 "SAVE AMP
"
"         BEGIN LOOP
"
LOOP:     ADD I,A; SETMA               "FETCH A(1)
          NOP                          "
          INCMA                        "FETCH A(2)
          FMUL DPX(E),MD               "E * A(1)
          FMUL DPY(F),MD;              "F * A(1)
               INCMA                   "FETCH A(3) = WEIGHT
          FMUL DPX(E),MD               "E * A(2)
          FMUL DPY(F),MD;              "F * A(2)
               DPX<FM                  "DPX = E*A(1)
          FMUL DPX(AMP),MD;            "AMP * WEIGHT
               DPY<FM                  "DPY = F*A(1)
          FSUB FM,DPY;                 "E*A(2) - F*A(1)
               FMUL                    "PUSH
          FADD FM,DPX;                 "F*A(2) + E*A(1)
               FMUL                    "PUSH
          ADD J,C; SETMA; MI<FM;       "STORE NEW WEIGHT
               DPX<FA;                 "DPX = NEW IMAG.
               FADD                    "PUSH
          DECMA; MI<DPX;               "STORE C(2)
               DEC N                   "DECREMENT LOOP COUNTER
          DECMA; MI<FA;                "STORE C(1)
               BGT LOOP
S999:     RETURN
          $END
"S9SAV
         $TITLE S9SAV
         $ENTRY S9SAV,1
"     MICROCODE ROUTINE FOR FPS AP-120B ARRAY PROCESSOR
"
"     S9SAV SAVE THE INTEGER CONTENTS OF SPAD 9 IN AP LOC LOC.
"
"    TIMING = .50 MICROSEC.
"    PROGRAMMER W. D. COTTON, MARCH 1982.
"
LOC      $EQU  0.
SP09     $EQU  9.
"
S9SAV:   MOV SP09,SP09;                    "SP09 TO SPFN
               DPX<SPFN                    "SPFN TO DPX
         MOV LOC,LOC; SETMA; MI<DPX        "SAVE VALUE.
         RETURN
         $END
"CVSMS
         $TITLE CVSMS
         $ENTRY CVSMS,9.
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     CVSMS subtracts a real vector times a complex scalar from
"     a complex vector, alternately i (SQRT(-1)) times the real
"     vector times the complex scalar is subtracted from the
"     complex vector.
"     Since the element count is expected to be small the looping
"     is not very efficient.
"
"     CALLING SEQUENCE - CALL CVSMS(A,I,B,C,J,D,K,N,FLAG)
"                A = Source vector base address.
"                I = Increment of A (at least 3)
"                B = Complex scalar
"                C = Real vector
"                J = Increment of C
"                D = Destination vector base address
"                K = Increment of D
"                N = Element count.
"                FLAG = flag, if < 0 multiply complex scalar by i
"
"     IF FLAG > 0
"     D(mK) = A(mI) - B(1) * C(mJ)
"     D(mK+1) = A(mI+1) - B(2) * C(mJ)  for m=0, N-1
"
"     IF FLAG < 0
"     D(mK) = A(mI) - i * B(1) * C(mJ)
"     D(mK+1) = A(mI+1) - i * B(2) * C(mJ)  for m=0, N-1
"
"     Timing = 2.8 + (N-1)*1.7 microsecond
"     Should work for both fast and slow memory.
"
"         SET SPAD ASSIGNMENTS
"
A         $EQU  0
I         $EQU  1
B         $EQU  2
C         $EQU  3
J         $EQU  4
D         $EQU  5
K         $EQU  6
N         $EQU  7
FLAG      $EQU  8.
"
"         SET DATA PAD ASSIGNMENTS
B1        $EQU 3     "DPX(B1) = B(1)
B2        $EQU 3     "DPY(B2) = B(2)
CC        $EQU 2     "DPX(CC) = C
"
"         SETUP
"
CVSMS:    MOV C,C; SETMA               "FETCH FIRST C
          MOV FLAG,FLAG                "CHECK FLAG
          BGT .+2                      "BRANCH ON FLAG
          JMP COMPLEX                  "JUMP TO COMPLEX SECTION
          MOV B,B; SETMA               "FETCH B(1)
          DPX(CC)<MD                   "SAVE C
          INCMA                        "FETCH B(2)
          FMUL DPX(CC),MD;             "B(1)*C
               DPX(B1)<MD              "SAVE B1
          MOV A,A; SETMA;              "FETCH 1ST A(1)
               FMUL                    "PUSH
          FMUL DPX(CC),MD;             "B(2)*C
               DPY(B2)<MD              "SAVE B2
          INCMA                        "FETCH 1ST A(2)
          FSUBR FM, MD;                "A(1) - B(1)*C
             SUB K,D;                  "PREPARE D FOR LOOP
             FMUL                      "PUSH
          ADD J, C; SETMA;             "FETCH NEXT C
             FMUL
          FSUBR FM, MD;                "A(2) - B(1)*C
             DEC N                     "PRE-DECREMENT LOOP COUNT
"
"         BEGIN LOOP
"
LOOP:     ADD K,D; SETMA; MI<FA        "SAVE D(1)
          FMUL DPX(B1),MD;             "B1*C
               FADD                    "PUSH
          INCMA; MI<FA;                "SAVE D(2)
               FMUL DPY(B2),MD;        "B2*C
               DEC N                   "DEC LOOP COUNT
          BGE .+2                      "CHECK IF FINISHED
          JMP S999                     "FINISHED
          ADD I,A; SETMA               "FETCH A(1)
          FMUL                         "PUSH
          INCMA                        "FETCH A(2)
          FSUBR FM, MD                 "A(1)-B(1)*C
          ADD J,C; SETMA;              "FETCH NEXT C
               FMUL                    "PUSH
          FSUBR FM, MD;                "A(2)-B(2)*C
               BR LOOP                 "LOOP
"
"         I TIMES COMPLEX SCALAR PART
"
COMPLEX:  INC B; SETMA                 "FETCH -REAL(I*B)
          DPX(CC)<MD                   "SAVE C
          DECMA                        "FETCH IMAG(I*B)
          FMUL DPX(CC),MD;             "-REAL(I*B)*C
               DPX(B1)<MD              "SAVE -REAL(I*B)
          MOV A,A; SETMA;              "FETCH 1ST A(1)
               FMUL                    "PUSH
          FMUL DPX(CC),MD;             "C * IMAG(I*B)
               DPY(B2)<MD              "SAVE IMAG(I*B)
          INCMA                        "FETCH 1ST A(2)
          FADD FM, MD;                 "A(1) - C*REAL(I*B)
             SUB K,D;                  "PREPARE D FOR LOOP
             FMUL                      "PUSH
          ADD J, C; SETMA;             "FETCH NEXT C
             FMUL
          FSUBR FM, MD;                "A(2) - C*IMAG(I*B)
             DEC N                     "PRE-DECREMENT LOOP COUNT
"
"         BEGIN LOOP
"
LOOPI:    ADD K,D; SETMA; MI<FA        "SAVE D(1)
          FMUL DPX(B1),MD;             "-C*REAL(I*B)
               FADD                    "PUSH
          INCMA; MI<FA;                "SAVE D(2)
               FMUL DPY(B2),MD;        "C*IMAG(I*B)
               DEC N                   "DEC LOOP COUNT
          BLT S999                     "CHECK IF FINISHED
          ADD I,A; SETMA               "FETCH A(1)
          FMUL                         "PUSH
          INCMA                        "FETCH A(2)
          FADD FM, MD                  "A(1)-C*REAL(I*B)
          ADD J,C; SETMA;              "FETCH NEXT C
               FMUL                    "PUSH
          FSUBR FM, MD;                "A(2)-C*IMAG(I*B)
               BR LOOPI                "LOOP
S999:     RETURN
          $END
"APGRD3
         $TITLE APGRD3
         $ENTRY APGRD3,9.
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     APGRD3 convolves visibility data onto a grid.
"     Will result in one map plus a beam, accumulating weighted
"     gridded visibility values and weights for each cell.
"
"     CALLING SEQUENCE - CALL APGRD3(UV,VIS,WT,GRID,CONX,CONY,NO2
"                                    ,M,LROW)
"                        UV = Location of (u,v) values in cells.
"                        VIS = Location of (complex) visibilities.
"                        WT = Weight for data. Assumes any tapering
"                             has already been done.
"                        GRID = base address of gridded data.
"                               Order assumed to be the following
"                               for each of the M rows:
"                               1) 2 * LROW visibilities
"                               2) 2 * LROW (sum weights, 0)
"                        CONX = base address of X convolving fn.
"                        CONY = base address of Y convolving fn.
"                        NO2 = INT( (# cells used on a row) / 2 )
"                        M = number of rows kept in the AP.
"                        In the above, X refers to rows and y to columns
"                        in the gridded data, NOT on the sky.  The total
"                        numbers of rows and cells used on a row should
"                        be odd.
"                        LROW = length of a row ( max. X).
"
"
"     All AP memory I/O values are assumed floating.
"     It is assumed that all values of v correspond to row M/2.
"
"     Source contains versions for both fast and slow AP memory
"     Timing = 7.5 + 1.2 N + 3.3 M * N for slow memory
"              9.3 + 1.3 n + 1.7 M * N for fast memory
"
"     Programmer: W. D. Cotton, July 1980.
"
"        SET SPAD ASSIGNMENTS
"
UV       $EQU  0
VIS      $EQU  1
WT       $EQU  2
GRID     $EQU  3
CONX     $EQU  4
CONY     $EQU  5
NO2      $EQU  6
M        $EQU  7
LROW     $EQU  8.
"
"        SET WORK SPAD ASSIGMNENTS
"
IX       $EQU  0
FOUR     $EQU  0
A        $EQU  1                          "SUM OF WEIGHTS
N        $EQU  9.
IN       $EQU  10.
ICONX    $EQU  11.
INCR     $EQU  12.
C27      $EQU  13.
WTX      $EQU  13.
TWO      $EQU  13.
WTY      $EQU  14.
HAF      $EQU  14.
IADD     $EQU  14.
IHUN     $EQU  15.
"
"        SET MEMORY SPEED, 1 = FAST, 0 = SLOW
"
         FSSLO = 1
"
APGRD3:  INC UV; SETMA                    "FETCH X
         LDTMA; DB=!HALF                  "0.5 TO TM
         LDSPI IHUN; DB=100.              "100 TO IHUN
         LDSPI C27; DB=27.                "C27 = CONST.FOR FLOATING.
         DECMA;                           "FETCH Y
              MOVR LROW,HAF               "HAF = LROW / 2
         FIX  MD;                         "FIX X (ROUNDED)
              MOV IHUN,IHUN; DPX(3)<SPFN  "100. TO DPX(3) FOR FLOAT
         MOV VIS,VIS; SETMA;              "FETCH REAL ( VIS )
              FADD TM, MD                 "ADD 0.5 TO X
         FADD ZERO,MDPX(3); MOV C27,C27;  " FLOAT 100.
              DPX(2)<FA;                  "SAVE FIXED X
              DPY(-1)<MD                  "SAVE Y
         FIX  MD;                         "FIX Y (ROUNDED)
              DPY(1)<FA;                  "SAVE X + 0.5 IN DPY(1)
              DEC GRID                    "DECREMENT GRID BEFORE LOOP
         LDSPI IX; DB=DPX(2);             "FIXED X TO IX
              FADD TM, DPY(-1);           "ADD 0.5 TO Y
              DPX(3)<FA                   "SAVE 100.0 IN DPX(3)
         INCMA;                           "FETCH IMAG ( VIS )
              FADD ZERO,MDPX(2);
                   MOV C27,C27;           "FLOAT(IX)
                   DPX(-2)<FA             "FIXED Y TO DPX(-2)
         INC HAF;                         "HAF = LROW/2 + 1
              DPY(-1)<FA;                 "SAVE Y+0.5 IN DPY(-1)
              FADD                        "PUSH
         ADD HAF,IX;                      "ADD BIAS TO IX
              DPX(0)<MD;                  "SAVE REAL ( VIS )
              FSUBR DPY(1),FA             "IX - X - 0.5
         MOV LROW,IADD;                   "CHECKING FOR END OF ROW
              FADD                        "PUSH
         MOV WT,WT; SETMA;                "FETCH WEIGHT
              DPY(0)<MD;                  "SAVE IMAG(VIS)
              FMUL DPX(3),FA              "100.0*(IX-X-0.5)
         FADD ZERO,MDPX(-2);
                   MOV C27,C27            "FLOAT(FIX(Y))
         SUB NO2,IADD;                    "CHECKING FOR END OF ROW
              FADD                        "PUSH
         SUB IX,IADD;                     "CHECKING FOR END OF ROW.
              FSUBR DPY(-1),FA;           "FIX(Y)-Y-0.5
              DPX(1)<MD;                  "SAVE WEIGHT
              DPY(1)<MD                   "TEMP WEIGHT.
         MOVL NO2,N;                      "2 * N/2 TO N
              FADD ZERO,DPY(1);           "CHECK WEIGHT <= 0.0
              BGE .+4                     "BRANCH IF UPPER X LIMIT OK
         ADD IADD,N                       "REDUCE N FOR UPPER LIMIT.
         BGT .+2                          "MAKE SURE N POSITIVE
         JMP S999                         "N .LE. 0 - RETURN
         FMUL DPX(3),FA;                  "100 * (FIX(Y) - Y - 0.5)
              FADD;                       "PUSH
              MOVL LROW,A                 "CONSTRUCT GRID POINTERS
         FMUL;                            "PUSH
              ADD GRID, A                 "CONSTRUCT GRID POINTERS
         DPY(3)<FM;                       "STUPID RESTRICTIONS.
              FMUL;                       "PUSH
              BFGT .+2                    "BRANCH IF WEIGHT POSITIVE
         JMP S999                         "NON. POS. WEIGHT - RETURN
         INC N                            "N = 2 * NO2 + 1
         FIX  DPY(3);                     "FIX X CONV. FN. INDEX
              DPX(3)<FM                   "STUPID RESTRICTIONS.
         FIX  DPX(3)                      "FIX Y CONV. FN. INDEX
         DPY(-1)<FA;                      "X CONV INDEX TO DPY(-1)
              FADD                        "PUSH
         LDSPI WTX; DB=DPY(-1);           "X CONV. FN. INDEX TO WTX
              DPY(-2)<FA                  "Y CONV INDEX TO DPY(-2)
         LDSPI WTY; DB=DPY(-2)            "Y CONV. FN. INDEX TO WTY
         ADD WTX,CONX                     "X CONV. FN. FIRST ADDRESS
         ADD WTY,CONY                     "Y CONV. FN. FIRST ADDRESS
         ADD IHUN,CONY                    "POINTER=100*(FIX(Y)-Y-.5)+100
                                          "100 ADDED TO CONX IN LOOP
         SUB NO2,IX                       "CHECK FRONT OF ROW
         DEC IX                           "CHECK IX .GE. NO2 + 1
         MOV CONX,ICONX;                  "SAVE POINTER
              BGE LONG                    "BRANCH IF FRONT OK
"        FRONT END OF ROW ENCOUNTERED.
         ADD IX, N                        "REDUCE N
         BGT .+2                          "MAKE SURE N POSITIVE
         JMP S999                         "N .LE. 0 - RETURN
         CLR IADD
         SUB IX,IADD
         DEC IADD
         ADD IHUN,CONX;                   "UPDATE CONX
              BGT .-1
         MOV CONX,ICONX;
              BR START
LONG:    ADD IX,IX                        "FOR COMPLEX VALUES.
         ADD IX,A                         "FINISH SUM WT POINTER
         ADD IX,GRID                      "FINISH GRIDDED VIS POINTER
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
"
START:   MOVL LROW,INCR                  "2*LROW TO INCR
         SUB N,INCR
         ADD INCR,INCR                    "INCR = 4 * LROW - 2 * N
         MOV N,IN;
              BGE LOOP                    "
         JMP S999                         "SOMETHING WRONG - RETURN
LOOP:    ADD IHUN,ICONX; SETMA            "FETCH CONV X.
         NOP
         MOV CONY,CONY; SETMA             "FETCH CONV Y.
         FMUL DPX(1),MD                   "WT*CX
         INC A; SETMA;                    "FETCH SUM OF WEIGHTS
              FMUL                        "PUSH
         FMUL                             "PUSH
         FMUL FM,MD                       "WT*CX*CY = WEIGHT
         FMUL                             "PUSH
         INC GRID; SETMA;                 "FETCH REAL (GRID)
              FMUL                        "PUSH
         FADD FM,MD;                      "SUM WEIGHTS
              DPX(2)<FM;                  "SAVE WEIGHT
              FMUL FM,DPX(0)              "WEIGHT * REAL(VIS)
         INC GRID; SETMA;                 "FETCH IMAG(GRID)
              FMUL DPX(2),DPY(0)          "WEIGHT * IMAG(GRID)
         FMUL                             "PUSH
         FADD FM,MD;                      "UPDATE REAL(GRID)
              FMUL                        "PUSH
         FADD FM,MD;                      "UPDATE IMAG(GRID)
              DPY(1)<FA                   "SAVE SUM WEIGHTS IN DPY(1)
         MOV A, A; SETMA; MI<DPY(1)       "SAVE SUM OF WEIGHTS
         INC A                            "UPDATE A
         DEC GRID; SETMA; MI<FA           "SAVE REAL(GRID)
         DEC IN;                          "DECR. INNER LOOP COUNT
              FADD                        "PUSH
         INC GRID; SETMA; MI<FA;          "SAVE IMAG(GRID)
              BGT LEND                    "BRANCH IF INNER LOOP IS
                                          "NOT FINISHED.
"
"        INNER LOOP FINISHED
"
         DEC M                            "DECR OUTER LOOP COUNT
         MOV CONX,ICONX;                  "RESET X CONV. FN. POINTER.
              BGT .+2                     "BRANCH IF NOT FINISHED.
         BR S999                          "FINISHED, RETURN.
         ADD INCR,A                       "UPDATE SUM WEIGHTS POINTER
         ADD INCR,GRID                    "UPDATE GRID POINTER
         ADD IHUN,CONY                    "UPDATE Y CONV. FN. POINTER
         MOV N,IN                         "RESET INNER LOOP COUNT
LEND:    JMP LOOP                         "LOOP
         $ENDIF                            "END OF SLOW VERSION
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
START:   LDSPI C27; DB=27.                 "27 TO SPAD TO FLOAT N
         LDSPI FOUR; DB=4.                 "4 TO FOUR
         MOV N,N; DPX(-4)<SPFN             "FLOAT N
         FADD ZERO,MDPX(-4); MOV C27,C27;  "FLOAT N
              BGT .+2                      "MAKE SURE N>0
         JMP S999                          "N <= 0 - RETURN
         FADD;                             "PUSH
              LDSPI TWO; DB=2.             "2 TO TWO
         MOVL LROW,INCR;                   "2*LROW TO INCR
              LDTMA; DB=!ONE               "1.0 TO TM
         SUB N,INCR;                       "2*LROW - N
              DPX(-4)<FA                   "SAVE FLOAT N
         ADD INCR,INCR                     "4*LROW-2*N
         INC INCR;                         "INCR=4*LROW-2*N+1
              DPY(-4)<FA                   "SAVE FLOAT N IN DPY
         SUB INCR,GRID                     "DECREMENT GRID BEFORE LOOP
         SUB INCR,A                        "DECREMENT A BEFORE LOOP
         SUB IHUN,CONY                     "DECREMENT CONY BEFORE LOOP
         ADD IHUN,CONX                     "SET CONX FOR FAST MEMORY
"        INC A                             "UNDO DEC GRID DONE FOR
         INC GRID                          "SLOW MEMORY VERSION.
"
"        BEGIN OUTER LOOP
"
OLOOP:   INC A                             "SET A
         MOV CONX,ICONX; SETMA             "1.FETCH CX
         ADD IHUN,CONY; SETMA              "1.FECTH CY
         ADD INCR,A; SETMA                 "1.FETCH SUM OF WEIGHTS
          FMUL DPX(1),MD                    "1. WT*CX
         ADD INCR,GRID; SETMA;             "1.FETCH REAL(GRID)
              DPX(-1)<MD;                  "1.SAVE CY
              FMUL                         "1.PUSH
         INCMA;                            "1.FETCH IMAG(GRID)
              FMUL;                        "1.PUSH
              DPY(-4)<DPX(-4)              "  SAVE INNER LOOP COUNT
         FMUL FM,DPX(-1);                  "1. WT*CX*CY
              DPY(-1)<MD;                  "1.SAVE SUM WEIGHTS
              FSUBR TM,DPY(-4)             "  DECREMENT INNER LOOP COUNT
         DPX(-2)<MD;                       "1.SAVE REAL(GRID)
              FADD;                        "  PUSH
              FMUL                         "1.PUSH
         FMUL                              "1.PUSH
         FMUL FM,DPX(0);                   "1. WT*CX*CY*REAL(VIS)
              DPX(2)<FM;                   "1. SAVE WT*CX*CY
              SUB TWO,GRID;                "  SET GRID FOR ILOOP
              DPY(-4)<FA;                  "  SAVE NEW ILOOP COUNT
              BFGT ILOOP                   "  BRANCH IF N > 1
         JMP DP1                           "  N=1 SKIP LOOP
"
"        BEGIN INNER LOOP
"
ILOOP:   ADD IHUN,ICONX; SETMA;            "1.FETCH CX
              FMUL DPX(2),DPY(0)           "2.WT*CX*CY*IM(VIS)
         MOV CONY,CONY; SETMA;             "1.FETCH CY
              FMUL;                        "2.PUSH
              DPY(-2)<MD                   "2.SAVE IMAG(GRID)
         ADD TWO,A; SETMA;                 "1.FETCH SUM OF WEIGHTS
              FADD FM,DPX(-2);             "2.ADD REALS
              FMUL                         "2.PUSH
         FMUL DPX(1),MD;                   "1.WT*CX
              FADD FM,DPY(-2)              "2.ADD IMAG
         ADD FOUR,GRID; SETMA;             "1.FETCH REAL(VIS)
              DPX(-1)<MD;                  "1.SAVE CY
              FMUL;                        "1.PUSH
              FADD DPX(2),DPY(-1);         "2.SUM WEIGHTS
              DPY(-3)<FA                   "2.SAVE NEW REAL(GRID)
         INCMA;                            "1.FETCH IMAG(GRID)
              FADD;                        "1.PUSH
              FMUL;                        "1.PUSH
              DPX(-3)<FA                   "2.SAVE NEW IMAG(GRID)
         FMUL FM,DPX(-1);                  "1.WT*CX*CY
              DPY(-1)<MD;                  "1.SAVE SUM WEIGHT
              SUB TWO,A; SETMA; MI<FA;     "2.STORE NEW SUM OF WEIGHTS
              FSUBR TM ,DPY(-4)            "  DECREMENT ILOOP COUNT
         ADD TWO,A;                        "2.RESET A
              FMUL;                        "1.PUSH
              DPX(-2)<MD;                  "1.SAVE REAL(GRID)
              FADD                         "  PUSH
        FMUL;                              "1.PUSH
              DEC GRID; SETMA; MI<DPX(-3)  "2.STORE NEW IMAG(GRID)
        FMUL FM,DPX(0);                    "1.WT*CX*CY*REAL(VIS)
              DPX(2)<FM;                   "1.SAVE WT*CX*CY
              DEC GRID; SETMA; MI<DPY(-3); "2.STORE NEW REAL(GRID)
              DPY(-4)<FA;                  "  SAVE NEW ILOOP COUNT
              BFGT ILOOP                   "  LOOP IF NOT FINISHED
"
"       FINISHED INNER LOOP - DROP PASS 1
"
DP1:    FMUL DPX(2),DPY(0)                 "2.WT*CX*CY*IMAG(VIS)
        FADD DPX(2),DPY(-1);               "2.SUM WEIGHTS
             FMUL                          "2.PUSH
        FADD FM,DPX(-2);                   "2.ADD REALS
             FMUL                          "2.PUSH
        FADD FM,MD;                        "2.ADD IMAG
             MOV A, A; SETMA; MI<FA        "2.STORE NEW SUM WEIGHTS
        ADD TWO, GRID; SETMA; MI<FA;       "2.STORE NEW REAL GRID
             FADD                          "2.PUSH
        DEC M                              "  DECREMENT OLOOP COUNT
        INC GRID; SETMA; MI<FA;            "2.STORE NEW IMAG(GRID)
             BGT LEND                      "  LOOP IF NOT FINISHED
        JMP S999                           "FINISHED - RETURN
LEND:   JMP OLOOP                          "  LOOP
        $ENDIF
"
S999:   RETURN
        $END
"GRDMIX
         $TITLE GRDMIX
         $ENTRY GRDMIX,3.
"
"     MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"     GRDMIX combines two complex vectors (A and B) to form conjugate rows
"     in a grid file to be FFTed; such that when the file is FFTed,
"     the resulting real portion is the Fourier transform of A and the
"     imaginary portion is the Fourier transform of B. (A and B assumed
"     to be symmetric).
"
"            A => A + iB
"            B => Conjg(A) + i * Conjg(B)
"
"     CALLING SEQUENCE - CALL GRDMIX (A,B,N)
"         A = First complex vector base address (increment=2)
"         B = Second complex vector base address.
"         N = Element count.
"
"     Set SPAD
A        $EQU  0
B        $EQU  1
N        $EQU  2
AOUT     $EQU  3
BOUT     $EQU  4
TWO      $EQU  5
"     SETUP
GRDMIX:  DEC A                           "SUBTRACT 1 FROM A BEFORE LOOP
         DEC B                           "SUBTRACT 1 FROM B BEFORE LOOP
         MOV A,AOUT                      "INIT AOUT
         MOV B,BOUT                      "INIT BOUT
         DEC BOUT                        "DECREMENT BOUT BEFORE LOOP
         MOV N,N                         "CHECK N
         BGT .+2                         "IF N .LE. 0 RETURN
         JMP S999
         LDSPI TWO; DB=2.                "TWO = 2
"
"     LOOP
LOOP:    INC A; SETMA                    "FETCH AR
         ADD TWO, B; SETMA               "FETCH BI
         INC A; SETMA                    "FETCH AI
         DEC B; SETMA;                   "FETCH BR
              DPX(1)<MD                  "DPX(1)=AR
         DPY(2)<MD;                      "DPY(2)=BI
              FSUB DPX(1),MD;            "AOR = AR-BI
              INC B                      "RESET B
         DPX(2)<MD;                      "DPX(2) = AI
              FADD DPY(2),DPX(1)         "BOR = BI+AR
         DPY(1)<MD;                      "DPY(1)=BR
              FSUBR DPX(2),MD;           "BOI = BR-AI
              INC AOUT; SETMA; MI<FA     "SAVE AOR
         FADD DPX(2), DPY(1);            "AOI = AI+BR
              ADD TWO,BOUT; SETMA; MI<FA "SAVE BOR
         INCMA; MI<FA;                   "SAVE BOI
              FADD;                      "PUSH
              DEC N                      "DECREMENT LOOP COUNTER
         INC AOUT; SETMA; MI<FA;         "SAVE AOI
              BGT LOOP                   "LOOP
S999:    RETURN
         $END
         $TITLE CVMMAX
         $ENTRY CVMMAX,4.
"CVMMAX
"  MICROCODE ROUTINE FOR FPS AP 120-B ARRAY PROCESSOR
"
"  CVMMAX finds the maximum of the square modulus of a complex
"  vector.
"
"    CALLING SEQUENCE - CALL CVMMAX (A, I, C, N)
"                       A = Source vector base address
"                       I = Increment of A
"                       C = Destination vector.
"                                         0 = MAX(A ** 2) (real)
"                                         1  = location of max
"                                                (integer)
"                                         SPAD(15) = index of max.
"
"         Set SPAD
A         $EQU  0.
I         $EQU  1.
C         $EQU  2.
N         $EQU  3.
ADDR      $EQU  4.     "Address of maximum.
IND       $EQU  5.     "Current index.
SAVE      $EQU  6.     "Current address
INDEX     $EQU  15.    "Index of maximum
"
"     DPX = Current Maximum absolute value.
"
"                                        SETUP
CVMMAX:   MOV A,SAVE; SETMA            "1. FETCH FIRST REAL
          CLR INDEX                    "INIT INDEX TO 0
          INCMA;                       "1. FETCH FIRST IMAG.
               MOV A,ADDR;             "INIT ADDR TO A
               DPX<DB; DB=ZERO         "INIT MAX TO 0.0
          DPY<MD;                      "1. REAL TO DPY FOR FMUL
               MOV INDEX, IND          "INIT IND
          FMUL DPY, MD                 "1. SQUARE REAL
          DPY<MD                       "1. IMAG TO DPY FOR FMUL
          FMUL DPY, MD;                "1. SQUARE IMAG
               DEC N                   "1. CHECK LOOP COUNT
          FMUL;                        "1. PUSH
               BGT LOOP                "1. CHECK LOOP COUNT
          JMP LAST                     "FINISHED
"
"                                       LOOP
"
LOOP:     ADD I, A; SETMA;             "1. FETCH NEXT REAL
               FMUL;                   "2. PUSH
               DPY<FM                  "2. SAVE REAL SQUARED
          FADD FM, DPY;                "2. SUM SQUARES
               INC IND                 "1. INCREMENT INDEX
          INCMA;                       "1. FETCH NEXT IMAG
               FADD                    "2. PUSH
          DPY<MD;                      "1. SAVE REAL FOR FMUL
               FSUB DPX, FA            "2. CHECK FOR MAX
          FMUL DPY, MD;                "1. SQUARE REAL
               FADD ZERO, NC           "2. SAVE VALUE IN FA
          DPY<MD                       "1. SAVE IMAG FOR FMUL
          FMUL DPY, MD;                "1. SQUARE IMAG
               DEC N;                  "1. DEC LOOP COUNT
               FADD;                   "2. PUSH
               BFGE LEND               "2. CHECK NEW MAX.
"     NEW MAXIMUM
          MOV SAVE,ADDR;               "2. SAVE POSITION.
               DPX<FA                  "2. SAVE NEW MAX
          MOV IND, INDEX               "2. SAVE INDEX
          MOV N, N                     "1. RESET LOOP CHECK
LEND:     FMUL;                        "1. PUSH
               MOV A,SAVE;             "1. SAVE ADDRESS
               BGT LOOP                "LOOP
"
"     FINISHED - WIND DOWN.
"
LAST:    FMUL;                         "2. PUSH
              DPY<FM;                  "2. SAVE REAL SQUARE
              INC IND                  "2. INCREMENT INDEX
         FADD FM,DPY                   "2. SUM SQUARES
         FADD                          "2. PUSH
         FSUB DPX,FA;                  "2. CHECK FOR NEW MAX.
              DPY<FA                   "2. SAVE VALUE
         FADD                          "2. PUSH
         NOP                           "2. WAIT
         BFGE .+3                      "2. CHECK FOR NEW MAXIMUM.
         DPX<DPY;                      "2. NEW MAX.
              MOV SAVE,ADDR            "2. NEW POSITION
         MOV IND,INDEX                 "2. NEW INDEX
         MOV C,C; SETMA; MI<DPX        "2. STORE MAX.
         INCMA; MI<DB; DB=SPFN;
                   MOV ADDR,ADDR       "STORE POSITION
         RETURN
         $END
"APGRD4
         $TITLE APGRD4
         $ENTRY APGRD4,11.
"
"     MICROCODE ROUTINE FOR FPS 120-B ARRAY PROCESSOR
"
"     APGRD4 grids a single channel.  It assumes that NO points
"     lie within one half the convolving support size of the
"     outside of the edge.
"
"     CALLING SEQUENCE - CALL APGRD4(UV,VIS,WT,GRID,CONX,CONY,NO2,
"                          M,LROW,INC,NVIS)
"
"                        UV = Location of (u,v) values in cells.
"                        VIS = Location of (complex) visibilities.
"                        WT = Weight for data. Assumes any tapering
"                             has already been done.
"                        GRID = base address of gridded data.
"                               Order assumed to be the following
"                               for each of the M rows:
"                               2 * LROW visibilities
"                        CONX = base address of X convolving fn.
"                        CONY = base address of Y convolving fn.
"                        NO2 = INT( (# cells used on a row) / 2 )
"                        M = number of rows kept in the AP.
"                        LROW = length of a row.
"                        In the above, X refers to rows and y to columns
"                        in the gridded data, NOT on the sky.  The total
"                        numbers of rows and cells used on a row should
"                        be odd.
"                        INC = increment of UV, VIS, WT
"                        NVIS = element count
"
"     All AP memory  values are assumed floating.
"     It is assumed that all values of v correspond to row M/2+1.
"
"     Source contains versions for both fast and slow AP memory
"
"     Programmer: W. D. Cotton, August 1983.
"
"        SET SPAD ASSIGNMENTS
"
UV       $EQU  0
VIS      $EQU  1
WT       $EQU  2
GRID     $EQU  3
CONX     $EQU  4
CONY     $EQU  5
NO2      $EQU  6
M        $EQU  7
LROW     $EQU  8.
INC      $EQU  9.
NVIS     $EQU  10.
"
"        SET WORK SPAD ASSIGMNENTS
"
N        $EQU  6.
INCR     $EQU  8.
ICONX    $EQU  11.
CX       $EQU  11.
HAF      $EQU  11.
IN       $EQU  12.
CY       $EQU  12.
IX       $EQU  12.
C27      $EQU  12.
TWO      $EQU  13.
FOUR     $EQU  14.
IHUN     $EQU  15.
"
"       INSIDE THE LOOPS THE INPUT DATA ARE LOCATED AS FOLLOWS:
"
"       DPX(1)  = REAL ( VIS ) * WEIGHT
"       DPY(1)  = IMAG ( VIS ) * WEIGHT
"       DPY(-1) = CY  (Y CONVOLVING FUNCTION VALUE)
"       DPX(-4) = 100.
"       TM = 0.5
"
"       SET FLAG FOR MEMORY SPEED FSSLO = 1 FOR FAST, 0 FOR SLOW
"
         FSSLO = 0
"
"        COMPUTE POINTERS AND FETCH DATA.
"        STARTUP INSTRUCTIONS ARE DOING SEVERAL FUNCTIONS
"         A) COMPUTE CONVOLVING FUNCTION AND GRID BASE ADDRESSES.
"         B) MULTIPLYING DATA BY WEIGHT BEFORE THE LOOP.
"         C) MISCELLANEOUS VALUES COMPUTED.
"
"                SET UP FOR VISIBILITY LOOPING
"
APGRD4:  LDTMA; DB=!TEN                   "C. GET 10 TO MAKE 100.
"A0.
         LDSPI IX; DB=0.                  "FOR DPA
         SETDPA                           "DPA = 0
"
"A1.
         DPX<TM;                          "C. DPX=10 FOR FMUL
              MOVR LROW,HAF               "C. START HAF=LROW/2-NO2
"A2.
         FMUL TM,DPX;                     "C. 10*10
              SUB N,HAF                   "C. WORK ON HAF
"A3.
         FMUL;                            "C. PUSH
              MOVL NO2,N                  "C. N=2*N/2+1
"A4.
         FMUL;                            "C. PUSH
               INC N                      "C. FINISH N
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
         INC INCR                          "C. FAST INCREMENT IS
                                           "   SLOW + 2
         $ENDIF
"A5.
         DPX(-4)<FM;                      "C. DPX(-4)=100.
              SUBL N,INCR                 "C. INCR=GRID INCREMENT
"A6.
         LDSPI TWO; DB=2.                 "C. TWO = 2
"
"    SAVE SOME VALUES
"A8.
         LDSPI IX; DB=8.
         SETDPA                           "DPA = 8
"A9.
         MOV CONX,CONX; DPX(0)<SPFN       "SAVE CONX
"A10.
         MOV CONY,CONY; DPX(1)<SPFN       "SAVE CONY
"A11.
         MOV GRID,GRID; DPX(2)<SPFN       "SAVE GRID
"A12.
         MOV M,M; DPX(3)<SPFN             "SAVE M
"A13.
         MOV HAF,HAF; DPY(0)<SPFN         "SAVE HAF
"A14.
         LDTMA; DB=!HALF                  "C. 0.5 TO TM
"
"0.                 BEGIN COMPONENT LOOP.
"
NXTCMP:  LDSPI IX; DB=0.
         SETDPA                           "DPA = 8
"1.
         INC UV; SETMA                    "A. FETCH X
"2.
         LDSPI FOUR; DB=4.                "C. FOUR=4
"3.
         DEC UV; SETMA                    "A. FETCH Y
"4.
         FIX MD;                          "A. FIX X
              LDSPI C27; DB=27.           "C. C27=CONST FOR FLOAT
"5.
         FADD TM, MD                      "A. X+0.5
"6.
         FIX MD;                          "A. FIX Y
              DPX(3)<FA;                  "A. SAVE FIX(X) IN DPX(3)
              LDSPI IHUN; DB=100.         "C. IHUN=100
"7.
         FADD TM,MD;                      "A. Y+0.5
              DPY(-3)<FA                  "A. SAVE X+.5
"8.
         DPX(-2)<FA;                      "A. SAVE FIX(Y)
              MOV WT,WT; SETMA            "B. FETCH WEIGHT
"9.
         FSUBR ZERO,MDPX(3); MOV C27,C27   "A. FLOAT(FIX(X))
"10.
         DPX(-3)<FA;                      "A. SAVE Y+0.5
              MOV VIS,VIS; SETMA          "B. FETCH REAL(VIS)
"11.
         FSUBR ZERO,MDPX(-2); MOV C27,C27  "A. FLOAT(FIX(Y))
"12.
         FSUBR DPY(-3),FA;                "A. FIX(X)-X-.5
              DPY(-1)<MD;                 "B. SAVE WEIGHT
              INCMA                       "B. FETCH IMAG (VIS)
"13.
         FSUBR DPX(-3),FA;                "A. FIX(Y)-Y-.5
              FMUL DPY(-1),MD             "B. WEIGHT*REAL
"14.
         FMUL DPX(-4),FA;                 "A. 100*(FIX(X)-X-.5)
              FADD                        "A. PUSH
"15.
         LDSPI IX; DB=DPX(3)              "A. START GRID BIAS
"16.
         FMUL DPX(-4),FA;                 "A. 100*(FIX(Y)-Y-.5)
              ADDL HAF,IX                 "A. GRID BIAS = 2 *
                                          "    (FIX(X)+LROW/2)
"17.
         FMUL DPY(-1),MD;                 "B. WEIGHT*IMAG
              DPX(1)<FM;                  "B. SAVE REAL*WEIGHT
              ADD IX,GRID                 "A. ADD GRID BIAS
"18.
         FMUL;                            "A. PUSH
              DPX(2)<FM                   "A. CX TO DPX(2)
"19.
         FIX DPX(2);                      "A. FIX CX
              DPY(2)<FM;                  "A. CY TO DPY(2)
              FMUL                        "B. PUSH
"20.
         FIX DPY(2);                      "A. FIX CY
              DPY(1)<FM;                  "B. IMAG*WEIGHT
              ADD IHUN,CONY               "A. ADJUST CONY BY 100
"21.
         DPX(2)<FA;                       "A. CX TO DPX
              FADD;                       "A. PUSH
              ADD IHUN,CONX               "A. ADJUST CONX BY 100
"22.
         LDSPI CX; DB=DPX(2);             "A. CONX=100*(FIX(X)-X-.5)
              DPY(2)<FA                   "A. CY TO DPY
"23.
         LDSPI CY; DB=DPY(2)              "A. CONY=100*(FIX(Y)-Y-.5)
"24.
         ADD CX,CONX                      "A. FINISH X CONV ADDR.
"25.
         ADD CY,CONY                      "A. FINISH Y CONV ADDR
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
"
START:   MOV CONY,CONY; SETMA             "FETCH FIRST CY
         MOV N,IN                         "SET INNER LOOP COUNTER
         SUB TWO,GRID                     "DECREMENT GRID BEFORE LOOP
         SUB IHUN,CONX                    "PREPARE CONX FOR LOOP
         MOV CONX,ICONX;                  "SET ICONX
              DPY(-1)<MD; DPX(-1)<MD      "SAVE CY IN DPY(-1)
LOOP:    ADD IHUN,ICONX; SETMA;           "FETCH CONV X (CX)
            FMUL DPX(1),DPY(-1)           "CY*RE
"2.
         FMUL DPY(1),DPX(-1)              "CY*IM
"3.
         ADD TWO,GRID; SETMA;             "FETCH OLD SUM REAL
            FMUL                          "PUSH
"4.
         FMUL FM,MD                       "(CY*RE) * CX
"5.
         INCMA;                           "FETCH OLD SUM IMAG
              FMUL FM,MD                  "(CY*IM) * CX
"6.
         FMUL                             "PUSH
"7.
         FADD FM,MD                       "SUM REAL
"8.
         FMUL; FADD                       "PUSH
"9.
         FADD FM,MD                       "SUM IMAG
"10.
         DECMA; MI<FA;                    "STORE NEW SUM REAL.
              FADD                        "PUSH
"11.
         DEC IN                           "DECREMENT LOOP COUNTER
"12.
         INCMA; MI<FA;                    "STORE NEW SUM IMAG.
              BGT LOOP                         "BRANCH IF INNER LOOP NOT
                                          "FINISHED
"
"        INNER LOOP FINISHED
"
         DEC M                            "DECREMENT OUTER LOOP COUNTER
         ADD IHUN,CONY; SETMA;            "FETCH NEXT CY
              BGT .+2                     "CHECK IF FINISHED
         BR S990                          "FINISHED - RETURN
         MOV CONX,ICONX                   "RESET X CONV. FN POINTER
         ADD INCR,GRID                    "UPDATE VIS1 POINTER
         MOV N,IN;                        "RESET INNER LOOP COUNTER
            DPY(-1)<MD; DPX(-1)<MD        "SAVE NEW CY IN DPY(-1)
LEND:    JMP LOOP                         "LOOP
         $ENDIF
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
"        PREPARE POINTERS
"
START:   MOV CONY,CONY; SETMA            "FETCH FIRST CY
         MOV N,IN                        "SET INNER LOOP COUNT
         SUB INCR,GRID                   "DECREMENT GRID BEFORE LOOP
         DPY(-1)<MD; DPX(-1)<MD          "SAVE CY IN DPX AND Y(-1)
"
"        BEGIN OUTER LOOP
"
OLOOP:   MOV CONX,ICONX; SETMA;          "1. FETCH CX
              FMUL DPY(-1),DPX(1)        "1. CY*RE
"2.
         ADD INCR,GRID; SETMA;           "1. FETCH SUM REAL(VIS)
              FMUL DPX(-1),DPY(1)        "1. CY*IM
"3.
         INCMA;                          "1. FETCH SUM IMAG(VIS)
              DEC IN;                    "   DECREMENT LOOP COUNT
              FMUL                       "1. PUSH
"4.
         FMUL FM,MD;                     "1. (RE*CY) * CX
              SUB TWO,GRID;              "   PREPARE GRID FOR LOOP
              DPX(-3)<MD;                "1. SAVE CX IN DPX(-3)
              BGT .+2
"4.5
        FADD ZERO,MD;                    "1. SAVE OLD RE IN FA
              BR DP1                     "FINISHED INNER LOOP (N=1)
"5.
         FMUL FM,DPX(-3);                "1. (IM*CY) * CX
              FADD ZERO,MD               "1. SAVE OLD RE IN FA
"
"        BEGIN INNER LOOP
"
ILOOP:   ADD IHUN,ICONX; SETMA;          "1. FETCH CX
              FMUL DPX(1),DPY(-1);       "1. REAL * CY
              FADD;                      "2. PUSH
              DPY(-2)<MD                 "2. SAVE OLD IM IN DPY(-2)
"2.
         ADD FOUR,GRID; SETMA;           "1. FETCH SUM REAL
              FMUL DPY(1),DPX(-1);       "1. IMAG * CY
              FADD FM,FA                 "2. SUM REAL
"3.
         INCMA;                          "1. FETCH SUM IMAG
              FMUL;                      "1. PUSH
              FADD FM,DPY(-2);           "2. SUM IMAG
              DEC IN                     "   DECREMENT LOOP COUNT
"4.
         FMUL FM,MD;                     "1. (RE*CY) * CX
              SUB TWO,GRID; SETMA; MI<FA; "2. STORE NEW SUM REAL
              FADD;                      "2. PUSH
              DPX(-3)<MD;                "1. SAVE CX IN DPX(-3)
              BGT .+2                    "   CHECK LOOP COUNT
"4.5
        FADD ZERO,MD;                    "1. SAVE OLD RE IN FA
              BR DP1                     "FINISHED INNER LOOP (N=1)
"5.
         FMUL FM,DPX(-3);                "1. (IM*CY) * CX
              FADD ZERO,MD;              "1. SAVE OLD RE IN FA
              INCMA; MI<FA;              "2. STORE NEW SUM IMAG.
              BR ILOOP                   "   LOOP
"
"        FINISHED INNER LOOP
"
DP1:     FMUL FM,DPX(-3);                "1. (IM*CY) * CX
              INCMA; MI<FA;              "2. STORE NEW SUM IMAG.
              DPY(-2)<MD                 "1. SAVE OLD IM IN DPY(-2)
"6.
         ADD FOUR,GRID;                  "1. UPDATE GRID
              FMUL; FADD                 "2. PUSH
"7.
         FADD FM,FA;                     "2. SUM REAL
              FMUL;                      "2. PUSH
              ADD IHUN,CONY; SETMA       "   FETCH NEXT CY
"8.
         FADD FM,DPY(-2);                 "2. SUM IMAG
              MOV N,IN                    "   RESET INNER LOOP COUNT
"9.
         SUB TWO,GRID; SETMA; MI<FA;     "2. STORE NEW SUM REAL
              FADD                       "2. PUSH
"10.
         INCMA; MI<FA;                   "2. STORE NEW SUM IMAG.
              DPY(-1)<MD; DPX(-1)<MD;    "   SAVE NEXT CY IN DPY(-1)
              DEC M                      "   DECREMENT OUTER LOOP COUNT
         BGT .+2                        "  CHECK OUTER LOOP
         JMP S990                       "   FINISHED - RETURN
         JMP OLOOP                      "   OUTER LOOP
         $ENDIF
"
"                 SETUP FOR NEXT COMPONENT
"
S990:    DEC NVIS                       "CHECK VIS COUNT
         ADD INC,UV;                    "INCREMENT UV
              BGT .+2                   "BRANCH IF NOT FINISHED
         JMP S999                       "FINISHED
         ADD INC,WT                     "INCREMENT WEIGHT
         ADD INC,VIS                    "INCREMENT VIS
"                 RESTORE VALUES STORED IN HIGH DPX
         LDSPI IX; DB=8.
         SETDPA                           "DPA = 8
         LDSPI CONX; DB=DPX(0)          "RESTORE CONX
         LDSPI CONY; DB=DPX(1)          "RESTORE CONY
         LDSPI GRID; DB=DPX(2)          "RESTORE GRID
         LDSPI M; DB=DPX(3)             "RESTORE M
         LDSPI HAF; DB=DPY(0)           "RESTORE HAF
         JMP NXTCMP                     "LOOP BACK FOR NEXT
S999:    RETURN
         $END
"APINTP
         $TITLE APINTP
         $ENTRY APINTP,9.
"
"     MICROCODE ROUTINE FOR FPS 120-B ARRAY PROCESSOR
"     APINTP Interpolates model visibilities from a grid,
"     corrects the phase and subtracts from the observations.
"     Assumes that the observations are never within M/2
"     of the outside edge of the grid.
"
"   Inputs:
"         P I*4          UV = Location of (u,v) values in
"                               cells.
"         P I*4          VIS = Location of (complex)
"                               visibilities.
"         P I*4          PHAS = Phase correction, complex
"                               value to be multiplied by
"                               model vis.
"         P I*4          GRID = base address of gridded model
"                               vis. Order assumed to be the
"                               following  for each of
"                               the M rows:
"                               1) 2 * LROW visibilities
"         P I*4          INTP = base address of interpolation
"                               function.
"         P I*4          M = number of rows kept in the AP.
"                               Also support size on interp. fn
"          P I*4         LROW = length of a row.
"          P I*4         INC  = increment for UV,VIS and PHAS
"          P I*4         NVIS = number of visibility points to
"                               grid.
"
"     All AP memory values are assumed floating.
"     It is assumed that all values of v correspond to row M/2.
"---------------------------------------------------------------
"
"        SET SPAD ASSIGNMENTS
"
UV       $EQU  0
VIS      $EQU  1
PHAS     $EQU  2
GRID     $EQU  3
CONX     $EQU  4
M        $EQU  5
LROW     $EQU  6
INC      $EQU  7
NVIS     $EQU  8.
CONY     $EQU  9.
NO2      $EQU  10.
"
"        SET WORK SPAD ASSIGMNENTS
"
INCR     $EQU  6
N        $EQU  10.
ICONX    $EQU  11.
CX       $EQU  11.
HAF      $EQU  11.
IN       $EQU  12.
CY       $EQU  12.
IX       $EQU  12.
C27      $EQU  12.
TWO      $EQU  13.
FOUR     $EQU  14.
THUN     $EQU  15.
"
"       INSIDE THE LOOPS THE INPUT DATA ARE LOCATED AS FOLLOWS:
"
"       DPX(2)  = Phase correction REAL
"       DPY(2)  = Phase correction IMAG
"       DPX(3)  = Real(vis)
"       DPY(3)  = Imag(vis)
"       DPX(-4) = 200.
"       TM = 0.5
"       FA IS USED TO STORE THE REAL AND IMAG INTERPOLATED SUMS
"
"       SET FLAG FOR MEMORY SPEED FSSLO = 1 FOR FAST, 0 FOR SLOW
"
         FSSLO = 1
"
"        COMPUTE POINTERS AND FETCH DATA.
"        STARTUP INSTRUCTIONS ARE DOING SEVERAL FUNCTIONS
"         A) COMPUTE CONVOLVING FUNCTION AND GRID BASE ADDRESSES.
"         B) MULTIPLYING DATA BY WEIGHT BEFORE THE LOOP.
"         C) MISCELLANEOUS VALUES COMPUTED.
"
"                SET UP FOR VISIBILITY LOOPING
"
APINTP:  LDTMA; DB=!TEN                   "C. GET 10 TO MAKE 100.
"A0.
         LDSPI IX; DB=0.                  "FOR DPA
         SETDPA                           "DPA = 0
"
"A1.
         DPX<TM;                          "C. DPX=10 FOR FMUL
              MOVR M,IX                   "   IX=M/2
"A2.
         FMUL TM,DPX;                     "C. 10*10
              MOVR LROW,HAF               "C. START HAF=LROW/2-NO2
"A3.
         FMUL;                             "C. PUSH
              SUB IX,HAF                   "C. WORK ON HAF
"A4.
         FMUL;                             "C. PUSH
            MOV M,N                        "   N=M
"A5.
         DPX(-4)<FM;                      "C. DPX(-4)=100.
              SUBL N,INCR                 "C. INCR=GRID INCREMENT
"A6.
         LDSPI TWO; DB=2.;                "C. TWO = 2
            FADD FM,DPX(-4)               "C. 100.0 + 100.0
"          FOLLOWING FOR FAST MEMORY
         $IF FSSLO
"A7.
         FADD;                            "C. PUSH
              ADD TWO,INCR                "C. ADD 2 TO GRID
         $ENDIF
"          FOLLOWING FOR SLOW MEMORY
         $IF FSSLO - 1
"A7.
         FADD                             "C. PUSH
         $ENDIF
"A8.
         DPX(-4)<FA                       "C. DPX(-4)=200.
"
"    SAVE SOME VALUES
"A9.
         LDSPI IX; DB=8.
         SETDPA                           "DPA = 8
"A10.
         MOV CONX,CONX; DPX(0)<SPFN       "SAVE CONX
"A11.
         MOV CONX,CONY; DPX(1)<SPFN       "SAVE CONY=CONX
"A12.
         MOV GRID,GRID; DPX(2)<SPFN       "SAVE GRID
"A13.
         MOV M,M; DPX(3)<SPFN             "SAVE M
"A14.
         MOV HAF,HAF; DPY(0)<SPFN         "SAVE HAF
"A15.
         LDTMA; DB=!HALF                  "C. 0.5 TO TM
"
"0.                 BEGIN COMPONENT LOOP.
"
NXTCMP:  LDSPI IX; DB=0.
         SETDPA                           "DPA = 8
"1.
         INC UV; SETMA                    "A. FETCH X
"2.
         LDSPI FOUR; DB=4.                "C. FOUR=4
"3.
         DEC UV; SETMA                    "A. FETCH Y
"4.
         FIX MD;                          "A. FIX X
              LDSPI C27; DB=27.           "C. C27=CONST FOR FLOAT
"5.
         FADD TM, MD                      "A. X+0.5
"6.
         FIX MD;                          "A. FIX Y
              DPX(3)<FA;                  "A. SAVE FIX(X) IN DPX(3)
              LDSPI THUN; DB=200.         "C. THUN=200
"7.
         FADD TM,MD;                      "A. Y+0.5
              DPY(-3)<FA                  "A. SAVE X+.5
"8.
         DPX(-2)<FA;                      "A. SAVE FIX(Y)
              MOV PHAS,PHAS; SETMA        "B. FETCH REAL(PHAS)
"9.
         FSUBR ZERO,MDPX(3); MOV C27,C27   "A. FLOAT(FIX(X))
"10.
         DPX(-3)<FA;                      "A. SAVE Y+0.5
              INCMA                       "B. FETCH IMAG(PHAS)
"11.
         FSUBR ZERO,MDPX(-2); MOV C27,C27  "A. FLOAT(FIX(Y))
"12.
         FSUBR DPY(-3),FA;                "A. FIX(X)-X-.5
              DPX(2)<MD;                  "B. SAVE REAL(PHAS)
              MOV VIS,VIS; SETMA          "B. FETCH REAL(VIS)
"13.
         FSUBR DPX(-3),FA                 "A. FIX(Y)-Y-.5
"14.
         FMUL DPX(-4),FA;                 "A. 200*(FIX(X)-X-.5)
              INCMA;                      "B. FETCH IMAG (VIS)
              DPY(2)<MD;                  "B. SAVE IMAG(PHAS)
              FADD                        "   PUSH
"15.
         LDSPI IX; DB=DPX(3)              "A. START GRID BIAS
"16.
         FMUL DPX(-4),FA;                 "A. 200*(FIX(Y)-Y-.5)
              ADDL HAF,IX;                "A. GRID BIAS = 2 *
                                          "    (FIX(X)+LROW/2)
              DPX(3)<MD                   "B. SAVE REAL(VIS)
"17.
         FMUL;                            "B. PUSH
              ADD IX,GRID                 "A. ADD GRID BIAS
"18.
         FMUL;                            "A. PUSH
              DPY(1)<FM                   "A. CX TO DPY(1)
"19.
         FIX DPY(1);                      "A. FIX CX
              DPX(1)<FM                   "A. CY TO DPX(1)
              FMUL                        "B. PUSH
"20.
         FIX DPX(1);                      "A. FIX CY
              ADD THUN,CONY;              "A. ADJUST CONY BY 200
              DPY(3)<MD                   "A. SAVE IMAG(VIS)
"21.
         DPX(1)<FA;                       "A. CX TO DPX
              FADD;                       "A. PUSH
              ADD THUN,CONX               "A. ADJUST CONX BY 200
"22.
         LDSPI CX; DB=DPX(1);             "A. CONX=200*(FIX(X)-X-.5)
              DPY(1)<FA                   "A. CY TO DPY
"23.
         LDSPI CY; DB=DPY(1)              "A. CONY=200*(FIX(Y)-Y-.5)
"24.
         ADD CX,CONX                      "A. FINISH X CONV ADDR.
"25.
         ADD CY,CONY                      "A. FINISH Y CONV ADDR
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
"
START:   MOV CONY,CONY; SETMA;            "FETCH FIRST CY
              FADD ZERO,ZERO              "ZERO FA (REAL)
         MOV N,IN;                        "SET INNER LOOP COUNTER
              FADD ZERO,ZERO              "ZERO FA (IMAG)
         SUB TWO,GRID                     "DECREMENT GRID BEFORE LOOP
         SUB THUN,CONX                    "PREPARE CONX FOR LOOP
         MOV CONX,ICONX;                  "SET ICONX
              DPY(-1)<MD; DPX(-1)<MD      "SAVE CY IN DPY(-1)
LOOP:    ADD THUN,ICONX; SETMA            "FETCH CONV X (CX)
"2.
         NOP
"3.
         ADD TWO,GRID; SETMA              "FETCH REAL
"4.
         FMUL DPX(-1),MD                  "CY * CX
"5.
         INCMA;                           "FETCH IMAG
              FMUL                        "PUSH
"6.
         FMUL                             "PUSH
"7.
         FMUL FM,MD;                      "CX * CY * REAL
              DPX<FM                      "SAVE CX * CY
"8.
         FMUL DPX,MD                      "CX * CY * IMAG
"9.
         FMUL                             "PUSH
"10.
         FADD FM,FA;                      "SUM REAL
              FMUL                        "PUSH
"11.
         FADD FM,FA;                       "SUM IMAG
              DEC IN                       "DECREMENT LOOP COUNTER
"12.
         BGT LOOP                         "BRANCH IF INNER LOOP NOT
                                          "FINISHED
"
"        INNER LOOP FINISHED
"
         DEC M                            "DECREMENT OUTER LOOP COUNTER
         ADD THUN,CONY; SETMA;            "FETCH NEXT CY
              BGT .+2                     "CHECK IF FINISHED
         BR S990                          "FINISHED - RETURN
         MOV CONX,ICONX                   "RESET X CONV. FN POINTER
         ADD INCR,GRID                    "UPDATE VIS1 POINTER
         MOV N,IN;                        "RESET INNER LOOP COUNTER
            DPY(-1)<MD; DPX(-1)<MD        "SAVE NEW CY IN DPY(-1)
LEND:    JMP LOOP                         "LOOP
         $ENDIF
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
"        PREPARE POINTERS
"
START:   MOV CONY,CONY; SETMA;           "FETCH FIRST CY
            FADD ZERO,ZERO               "ZERO FA (REAL)
         MOV N,IN;                       "SET INNER LOOP COUNT
            FADD ZERO,ZERO               "ZERO FA (IMAG)
         SUB INCR,GRID;                  "DECREMENT GRID BEFORE LOOP
            DPX<FA; DPY<FA               "ZERO TO DPX,DPY
         DPY(-1)<MD; DPX(-1)<MD          "SAVE CY IN DPX AND Y(-1)
"
"        BEGIN OUTER LOOP
"
"        WARM UP LOOP
"1.
OLOOP:   MOV CONX,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX,DPY              "   CLEAR MULTIPLIER
"2.
         ADD INCR,GRID; SETMA;          "1. FETCH REAL
              FMUL DPX,DPY              "   CLEAR MULTIPLIER
"3.
         INCMA;                         "1. FETCH IMAG
              DEC IN                    "   DEC LOOP CNT
"4.
         ADD THUN,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX(-1),MD;          "2. CX*CY
              BGT .+2                   "   CHECK LOOP CNT
"4.5
         DPX(-3)<MD;                    "   SAVE REAL
              BR DP1                    "   EXIT LOOP
"5.
         ADD TWO,GRID; SETMA;           "1. FETCH REAL
              FMUL;                     "2. PUSH
              DPX<MD                    "2. SAVE REAL
"6.
         INCMA;                         "1. FETCH IMAG
              FMUL;                     "2. PUSH
              DPY<MD;                   "2. SAVE IMAG
              DEC IN                    " DEC LOOP CNT
"7.
         ADD THUN,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX(-1),MD;          "2. CX*CY
              DPX(1)<FM; DPY(1)<FM;     "3. SAVE CX*CY
              BGT .+2                   "   CHECK LOOP CNT
"7.5
         DPX(-3)<MD;                    "   SAVE REAL
              BR DP1                    "   EXIT LOOP
"8.
         ADD TWO,GRID; SETMA;           "1. FETCH REAL
              DPX<MD;                   "2. SAVE REAL
              FMUL DPX,DPY(1)           "3. CX*CY*RE
"9.
         INCMA;                         "1. FETCH IMAG
              DPY<MD;                   "2. SAVE IMAG
              FMUL DPY,DPX(1);          "3. CX*CY*IM
              DEC IN                    " DEC LOOP CNT
"
"     LOOP
"
"1/4/7/10
LOOP:    ADD THUN,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX(-1),MD;          "2. CX*CY
              DPX(1)<FM; DPY(1)<FM;     "3. SAVE CX*CY
              BGT .+2                   "   CHECK LOOP CNT
"1.5
         DPX(-3)<MD;                    "   SAVE REAL
              BR DP1                    "   EXIT LOOP
"2/5/8/11.
         ADD TWO,GRID; SETMA;           "1. FETCH REAL
              DPX<MD;                   "2. SAVE REAL
              FMUL DPX,DPY(1);          "3. CX*CY*RE
              FADD FM,FA                "4. SUM REAL
"3/6/9/12.
         INCMA;                         "1. FETCH IMAG
              DPY<MD;                   "2. SAVE IMAG
              FMUL DPY,DPX(1);          "3. CX*CY*IM
              FADD FM,FA;               "4. SUM IMAG
              DEC IN;                   " DEC LOOP CNT
              BR LOOP                   " LOOP
"
"    WIND DOWN LOOP
"
"5/8/11.
DP1:     DPY(-3)<MD;                    "2. SAVE IMAG
              FMUL DPX,DPY(1);          "3. CX*CY*RE
              FADD FM,FA;               "4. SUM REAL
              ADD THUN,CONY; SETMA      "   FETCH NEXT CY
"6/9/12.
         FMUL DPY,DPX(1);               "3. CX*CY*IM
              FADD FM,FA;               "4. SUM IMAG
              MOV N,IN                  "  RESET LOOP CNT
"7/10
         DPX(1)<FM; DPY(1)<FM;          "3. SAVE CX*CY
               FMUL                     "   PUSH
"8/11.
         FMUL DPX(-3),DPY(1);           "3. CX*CY*RE
              FADD FM,FA;               "4. SUM REAL
              DPX(-1)<MD; DPY(-1)<MD    "   NEW CY
"9/12.
         FMUL DPY(-3),DPX(1);           "3. CX*CY*IM
              FADD FM,FA                "4. SUM IMAG
"10.
         FMUL;                          "   PUSH
            DPX<ZERO; DPY<ZERO          "  0 TO DPX,DPY
"11.
         FMUL;                          "   PUSH
              FADD FM,FA;               "4. SUM REAL
              DEC M                     "  DEC OUTER LOOP CNT
"12.
         FADD FM,FA;                    "4. SUM IMAG
              BGT .+2                   "   LOOP
         JMP S990                       "   FINISHED - RETURN
         JMP OLOOP                      "   OUTER LOOP
         $ENDIF
"
"                 ROTATE AND SUBTRATC MODEL AND
"                 SETUP FOR NEXT COMPONENT
"                 DPX = REAL, DPX = IMAG
"
S990:    DPX<FA;                        "SAVE REAL
              FADD;                     "PUSH
              FMUL DPX(2),FA            "RE*RE(PHAS)
         ADD INC,UV;                    "INCREMENT UV
              FMUL DPY(2),FA;           "IM*IM(PHAS)
              DPY<FA                    "SAVE IMAG
         ADD INC,PHAS;                  "INCREMENT WEIGHT
              FMUL DPX,DPY(2)           "RE * IM(PHS)
         FMUL DPY,DPX(2);               "IM*RE(PHAS)
              DPX(-1)<FM                "SAVE RE*RE(PHAS)
         FSUBR FM,DPX(-1);              "MODEL REAL
              FMUL                      "PUSH
         DPX(-1)<FM;                    "SAVE RE*IM(PHAS)
              FMUL                      "PUSH
         FADD FM,DPX(-1)                "MODEL IMAG
         FSUB DPX(3),FA                 "SUB MODEL FROM OBS(RE)
         FSUB DPY(3),FA                 "SUB MODEL FROM OBS(IM)
         MOV VIS,VIS; SETMA; MI<FA;     "STORE NEW REAL
              FADD                      "PUSH
         INCMA; MI<FA;                  "STORE NEW IMAG
              ADD INC,VIS               "INCREMENT VIS
"                 RESTORE VALUES STORED IN HIGH DPX
         LDSPI IX; DB=8.
         SETDPA                           "DPA = 8
         LDSPI CONX; DB=DPX(0)          "RESTORE CONX
         LDSPI CONY; DB=DPX(1)          "RESTORE CONY
         LDSPI GRID; DB=DPX(2)          "RESTORE GRID
         LDSPI M; DB=DPX(3)             "RESTORE M
         LDSPI HAF; DB=DPY(0)           "RESTORE HAF
         DEC NVIS                      "CHECK VIS COUNT
         BGT .+2                       "BRANCH IF NOT FINISHED
         JMP S999                       "FINISHED
         JMP NXTCMP                     "LOOP BACK FOR NEXT
S999:    RETURN
         $END
"DIRADD
         $TITLE DIRADD
         $ENTRY DIRADD,4
"
"        Directed add AP subroutine (B. Clark)
"
"        CALLING SEQUENCE - CALL DIRADD (A,IA,B,N)
"             ____COMPLEX____
"
"        B(A(IA*J)) = B(A(IA*J))+A(IA*J+1)      FOR J = 0,N-1
"        B(A(IA*J)+1) = B(A(IA*J)+1)+A(IA*J+2)
"
"        SPAD parameters.
"
A        $EQU    0
IA       $EQU    1
B        $EQU    2
N        $EQU    3
"
BT       $EQU    4
BT1      $EQU    5
BT2      $EQU    6
"
DIRADD:  MOV A,A; SETMA                           "FETCH B OFFSET
         INCMA                                    "FIRST AUGEND
         INCMA                                    "SECOND AUGEND
         LDSPI BT; DB=MD                          "OFFSET TO SPAD
         DPX<MD;                                  "SAVE FIRST AUGEND
              DEC N
         DPY<MD;                                  "SAVE SECOND AUGEND
              BEQ LONE                            "BRANCH IF N=1
         ADD B,BT; SETMA                          "FETCH FIRST ADDEND
         INCMA                                    "     ETC
"
LOOP:    ADD IA,A; SETMA                          "FETCH B OFFSET
         INCMA;                                   "FETCH FIRST AUGEND
              FADD DPX,MD;                        "DO THE ADD
              DEC N
         INCMA;                                   "SECOND AUGEND
              FADD DPY,MD;
              MOV BT,BT1;                         "SAVE OLD LOCATION
              BEQ LEND                            "TERMINATE LOOP?
         LDSPI BT; DB=MD                          "OFFSET TO SPAD
         MOV BT1,BT1; SETMA; MI<FA;               "SAVE OLD RESULT
              FADD;                               "PUSH
              DPX<MD                              "SAVE FIRST AUGEND
         INCMA; MI<FA;
              DPY<MD                              "SAVE SECOND AUGEND
         ADD B,BT; SETMA                          "FETCH FIRST ADDEND
         INCMA;                                   "    ETC
              BR LOOP
LEND:    LDSPI BT; DB=MD                          "OFFSET TO SPAD
         MOV BT1,BT1; SETMA; MI<FA;               "SAVE OLD RESULT
              FADD;                               "PUSH
              DPX<MD                              "SAVE FIRST AUGEND
         INCMA; MI<FA;
              DPY<MD                              "SAVE SECOND AUGEND
LONE:    ADD B,BT; SETMA                          "FETCH FIRST ADDEND
         INCMA                                    "   ETC
"
         NOP
         FADD DPX,MD                              "DO THE ADD
         FADD DPY,MD;
              MOV BT,BT1                          "SAVE OLD LOCATION
         NOP
         MOV BT1,BT1; SETMA; MI<FA;               "SAVE OLD RESULT
              FADD                                "PUSH
         INCMA; MI<FA
"
         $RADIX 8
         RETURN
         $END
"CLNSUB
         $TITLE CLNSUB
         $ENTRY CLNSUB,5
         $EXT MAXMGV, SPUFLT
"
"   CLNSUB is an AP subroutine which CLEANS that portion of a
"   map residing in the AP.
"
"        SPAD ENTRY PARAMETERS
"
COMP     $EQU   0
"        COMP IS A LENGTH 4 FLOATING VECTOR:
"             COMPONENT INTENSITY
"             X LOCATION (CELLS)
"             Y LOCATION (CELLS)
"             CLEAN GAIN
"
AMAP     $EQU   1
"        AMAP IS THE MAP BASE ADDRESS. IT IS STORED AS (LOCATION,INTENSI
"        LOCATION = 2**14*X+Y (CELLS)
"        -1<X<NX   -1<Y<NY
"
LMAP     $EQU   2
"        NUMBER OF MAP POINTS
"
ABEAM    $EQU   3
"        ABEAM IS A RECTANGULAR PIECE OF BEAM.  THE Y DIRECTION IS MOST
"        RAPID VARIABLE: -BY<Y<BY
"        X VARIES LESS RAPIDLY, -1<X<BX
"
BBEAM    $EQU   4
"        BEAM DESCRIPTION VECTOR, (BX,BY)
"
"        OTHER SPAD REGISTERS
"
BEAM     $EQU   3                             "WHY NOT
MAPI     $EQU   5
MAPIP    $EQU   6
MAPIL    $EQU   7
SCRAT    $EQU   9.
TWO      $EQU   10.
BADR     $EQU   11.
KMAP     $EQU   12.
"
"        DATA PAD REGISTERS (ALL INDEXING - NO DPA CHANGES)
"
REF      $EQU   -4.
"        COMPONENT LOCATION
"
LIM      $EQU   -3.
"        BEAM PATCH SIZE
"
SEL      $EQU   -2.
"        SELECTION OF X OR Y
"
DATA     $EQU   -1.
"        YPAD   TEMP STORAGE OF MAP VALUE
"
T        $EQU   -1.
"        XPAD   AMOUNT TO SUBTRACT
"
ADDRO    $EQU    1.
"        YPAD    TEMPORARY STORAGE OF BEAM OFFSET
"
SIZE     $EQU    0.
"        YPAD    MAPSIZE/16384.
"
YSIZE    $EQU    0.
"        XPAD    YSIZE-2
"
TEMP     $EQU    3.
"
MAX      $EQU    1.
"
NULL     $EQU    2.
"        X- AND Y- PAD ADDRESS OF ZERO
"
"        OK, NOW GET EVERYTHING ORGANIZED.
"
CLNSUB:  MOV COMP,SCRAT; SETMA                  "FETCH COMPONENT
         LDDPA; DB=4;                           "TO MAKE THINGS PRETTY
              MOV LMAP,KMAP
         SPMDA; DPX(T)<MD;
              INCMA                             "FETCH X
         SPMDA; DPX(REF)<MD;
              INCMA                             "FETCH Y
         SPMDA; DPY(REF)<MD;
              INCMA                             "FETCH GAIN
         SPMDA; FMUL DPX(T),MD;                 "RESIDUAL*GAIN
              INCMA                             "FETCH SIZE
         FMUL;
              MOV BBEAM,SCRAT
         SPMDA; DPX(SIZE)<MD;
              FMUL; SETMA                       "FETCH BEAM SIZE
         DPX(T)<FM                              "COMPONENT=RESIDUAL*GAIN
         LDTMA; DB=!TWO
         SPMDA; DPX(LIM)<MD;
              INCMA
         SPMDA; DPY(LIM)<MD
         DPX(TEMP)<DPY(REF)
         FADD DPY(LIM),DPY(LIM)                "BEAM+BEAM
         FSUB DPX(TEMP),DPY(LIM)               "(Y-BEAM) TAKE CARE
                                               "OF ZERO OFFSET
         FSUBR TM,FA;                          "-(2-2*BEAM)
              DPY(LIM)<FA                      "2*BEAMSIZE
         LDTMA; DB=!ONE
         DPX(MAX)<ZERO
         NOP
         FADD TM,FA                            "1+2*BEAM
         FSUBR TM,DPY(LIM);                    "2*BEAM-1
              DPX(YSIZE)<FA
         DPY(REF)<FA; FADD
         DPX(TEMP)<FA
"-----------------------------------------------------------------------
" Patch jah 7/15/83.  Fixes upper y limit bug.
	 DPY(LIM)<FA
"-----------------------------------------------------------------------
         RPSF XSEL; DPX(SEL)<DB                "LOAD 16383*16384
         RPSF YSEL; DPY(SEL)<DB                "LOAD 16383
         RPSF P14; DPY(SIZE)<DB                "LOAD 16384
         RPSF S14; DPY(TEMP)<DB;
              BR S14+1
XSEL:    $FP    268419072.
YSEL:    $FP    16383.
P14:     $FP    16384.
S14:     $VAL   0,1FX,3400X,0
         FMUL DPX(LIM),DPY(SIZE)              "(BEAM*16384) SCALE X OFFS
         FMUL DPX(TEMP),DPY(TEMP)
         FMUL DPX(REF),DPY(SIZE)
         MOV COMP,COMP;
              MI<DPX(MAX); SETMA              "ZERO COMP(1)
         DPX(LIM)<FM; FMUL
         MOV BEAM,SCRAT;                      "MAKE A POINTER THAT POINT
                                              "TO COMP (=0.0) WHICH IS U
                                              "AS THE BEAM VALUE WHEN A
                                              "RESIDUAL POINT IS NOT IN
                                              "BEAM PATCH.
              DPY(SIZE)<FM;
              FMUL
         DPX(REF)<FM
         MOV TWO,TWO
         LDSP; DB=2
"  Patch jah 7/19/83.  Properly calculate offset for NULL beam value.
"  Mod. WDC  7/28/83  to work on 64 K and FPS 120B machines.
          MOV BEAM,15.
          LDDPA; DB=12.         "Move to different DP address space.
          JSR SPUFLT            "float BEAM
          DPY(2)<DPX(1);        "Save floated BEAM in DPY(2)
               MOV COMP,15.     "float COMP
          JSR SPUFLT
          FSUBR DPY(2),DPX(1)   "Get negative of result into FA.
          FADD
          LDDPA; DB=4.          "Revert to previous set of DP registers.
          DPX(NULL)<FA;         "Copy into NULL
               DPY(NULL)<FA
"
"        *********    INTRO   **********
"
"        LOOP1
"
         MOV AMAP,MAPI; SETMA                "GET NEW MAP POINT (LOCATIO
         DEC KMAP                            "WAIT FOR MEMORY
         NOP
         FAND DPX(SEL),MD;                   "SELECT X
              MOV AMAP,MAPIL                 "SETUP MAP RESIDUAL ADDRESS
         FAND DPY(SEL),MD;                   "SELECT Y
              DEC MAPIL
"
"        LOOP2
"
         FSUBR DPX(REF),FA                   "DX
         FSUBR DPY(REF),FA                   "DY
         NOP
         BFGE .+3                            "SKIP IF DX>0
         FSUB ZERO,FA                        "REFLECT
         FSUB DPX(YSIZE),FA
         FSUBR DPX(LIM),FA;                  "CHECK X LIMIT
              ADD TWO,MAPI; SETMA;           "GET NEW MAP POINT (LOCATIO
              FMUL DPY(SIZE),FA              "START ADDRESS CALCULATION
         FSUBR DPY(LIM),FA;                  "CHECK Y LIMIT
              DPY(TEMP)<FA;                  "SAVE DY
              FMUL
         FADD;
              FMUL;
              BFGE .+2                       "SKIP IF Y LOWER LIMIT OK
         BR NULLU
         FADD FM,DPY(TEMP);                  "ADDRESS CALCULATION FINISH
              BFGE NULLU                     "BRANCH IF X OUTSIDE UPPER
                                             "LIMIT
         FADD;
              BFGE NULLU                     "BRANCH IF Y OUTSIDE UPPER
                                             "LIMIT
REJOU:   FIX FA                              "FIX BEAM ADDRESS
         FAND DPX(SEL),MD;                   "SELECT X
              DEC KMAP                       "COUNT MAP POINTS
         FAND DPY(SEL),MD;                   "SELECT Y
              DPY(ADDRO)<FA                  "SAVE BEAM OFFSET
         BR LOOP3
"
NULLU:   FADD ZERO,DPX(NULL)
         FADD;
              BR REJOU
"
"        LOOP3
"
LOOP3:   FSUBR DPX(REF),FA                  "DX
         FSUBR DPY(REF),FA;                 "DY
              MOV BADR,BADR
         DB=DPY(ADDRO); LDSP                "BEAM OFFSET TO SPAD
         BFGE .+3;                          "SKIP IF DX>0
              ADD BEAM,BADR; SETMA          "FETCH BEAM VALUE
         FSUB ZERO,FA                       "REFLECT
         FSUB DPX(YSIZE),FA
         FSUBR DPX(LIM),FA;                 "CHECK X LIMIT
              FMUL DPY(SIZE),FA             "START ADDRESS CALCULATION
         FSUBR DPY(LIM),FA;                 "CHECK Y LIMIT
              DPY(TEMP)<FA;                 "SAVE DY
              FMUL                          "PUSH
         FSUB;
              FMUL DPX(T),MD;               "BEAM*COMPONENT
              BFGE .+2                      "SKIP IF Y LOWER LIMIT OK
         FADD FM,DPY(TEMP);                 "FINISH BEAM ADDRESS
              ADD TWO,MAPI; SETMA;          "FETCH NEW MAP POINT LOCATIO
              BR NULLV2
         FADD FM,DPY(TEMP);                 "BEAM ADDRESS FINISHED
              ADD TWO,MAPI; SETMA;          "FETCH NEW MAP POINT LOCATIO
              BFGE NULLV2                   "BRANCH IF X OUTSIDE UPPER L
         FADD;
              BFGE NULLV3                   "BRANCH IF Y OUTSIDE UPPER L
REJOV:   FIX FA;                            "FIX BEAM ADDRESS
              MOV AMAP,MAPIP                "SETUP MAP VALUE ADDRESSING
         FAND DPX(SEL),MD;                  "SELECT X
              DEC KMAP                      "COUNT MAP POINTS
         FAND DPY(SEL),MD;                  "SELECT Y
              DPY(ADDRO)<FA;                "SAVE BEAM OFFSET
              INC MAPIP;SETMA               "FETCH MAP VALUE
         BR LOOP
NULLV2:  FADD ZERO,DPX(NULL)
         FADD;
              BR REJOV
NULLV3:  FADD ZERO,DPX(NULL)
         FADD;
              BR REJOV
"
"        *******   LOOP   ********
"
LOOP:    FSUBR DPX(REF),FA                 "DX
         FSUBR DPY(REF),FA;                "DY
              MOV BADR,BADR                "SET SPD
         DB=DPY(ADDRO); LDSP               "BEAM OFFSET TO SPAD
         BFGE .+3;                         "SKIP IF DX>0
              DPY(DATA)<MD;                "SAVE MAP VALUE
              ADD BEAM,BADR; SETMA         "FETCH BEAM VALUE
         FSUB ZERO,FA                      "REFLECT
         FSUB DPX(YSIZE),FA
         FSUBR DPX(LIM),FA;                "CHECK X LIMIT
              FMUL DPY(SIZE),FA;           "START ADDRESS CALCULATION
              ADD BEAM,BADR; SETMA         "FETCH BEAM VALUE
         FSUBR DPY(LIM),FA;                "CHECK Y LIMIT
              DPY(TEMP)<FA;                "SAVE DY
              FMUL                         "PUSH
         FSUBR FM,DPY(DATA);               "RESIDUAL
              FMUL DPX(T),MD;              "BEAM*COMPONENT
              BFGE DOWN                    "BRANCH IF Y LOWER LIMIT OK
         FADD FM,DPY(TEMP);                "BEAM ADDRESS CALCULATION COM
              BR NULL2
UPSY:    FAND DPX(SEL),MD                  "SELECT X
         DEC KMAP                          "COUNT MAP POINTS
         FAND DPY(SEL),MD;                 "SELECT Y
              DPY(ADDRO)<FA;               "SAVE BEAM OFFSET
              ADD TWO,MAPIP; SETMA;        "FETCH MAP VALUE
              BGT LOOP                     "LOOP
         BR CODA                           "END OF LOOP
DOWN:    FADD FM,DPY(TEMP);                "BEAM ADDRESS CALCULATION COM
              BFGE NULL2                   "BRANCH IF X OUTSIDE LIMIT
         ADD TWO,MAPIL; MI<FA; SETMA;      "STORE RESIDUAL
              BFGE NULL3                   "BRANCH IF Y OUTSIDE UPPER LI
REJOIN:  ADD TWO,MAPI; SETMA               "FETCH NEW MAP POINT LOCATION
         FADD
         FIX FA;                           "FIX BEAM ADDRESS
              BR UPSY
"
"        NULLS=DON'T SUBTRACT RESIDUALS
"
NULL2:   FADD ZERO,DPY(NULL);              "LOAD ADDRESS OF ZERO
              ADD TWO,MAPIL; MI<FA; SETMA; "STORE RESIDUAL
              BR REJOIN
NULL3:   FADD ZERO,DPX(NULL);
              BR REJOIN
"
"        ******   CODA  ******
"
"        LOOP N-2
"
CODA:    FSUBR DPX(REF),FA                 "DX
         FSUBR DPY(REF),FA;                "DY
              MOV BADR,BADR
         DB=DPY(ADDRO); LDSP               "BEAM OFFSET TO SPAD
         BFGE .+3;                         "SKIP IF DX>0
              DPY(DATA)<MD;                "SAVE MAP VALUE
              ADD BEAM,BADR; SETMA         "FETCH BEAM VALUE
         FSUB ZERO,FA                      "REFLECT
         FSUB DPX(YSIZE),FA
         FSUBR DPX(LIM),FA;                "CHECK X LIMIT
              FMUL DPY(SIZE),FA            "START ADDRESS CALCULATION
              ADD BEAM,BADR; SETMA         "FETCH BEAM VALUE
         FSUBR DPY(LIM),FA;                "CHECK Y LIMIT
               DPY(TEMP)<FA;               "SAVE DY
              FMUL                         "PUSH
         FSUBR FM,DPY(DATA);               "RESIDUAL
              FMUL DPX(T),MD;              "BEAM*COMPONENT
              BFGE .+2                     "BRANCH IF Y OUTSIDE LOWER LI
         FADD FM,DPY(TEMP);                "FINISH BEAM ADDRESS CALCULAT
              BR NULLW2
         FADD FM,DPY(TEMP);                "BEAM ADDRESS CALCULATION COM
              BFGE NULLW2                  "BRANCH IF X OUTSIDE UPPER LI
         ADD TWO,MAPIL; MI<FA; SETMA;      "STORE RESIDUAL
              BFGE NULLW3                  "BRANCH IF Y OUTSIDE UPPER LI
REJOW:   FADD
         FIX FA                            "FIX BEAM ADDRESS
         FADD
         DPY(ADDRO)<FA;                    "SAVE BEAM OFFSET
              ADD TWO,MAPIP; SETMA         "FETCH MAP VALUE
         SPMDA;
              BR LOOX
NULLW2:  FADD ZERO,DPY(NULL);
              ADD TWO,MAPIL; MI<FA; SETMA; "STORE RESIDUAL
              BR REJOW
NULLW3:  FADD ZERO,DPX(NULL);
              BR REJOW
"
"        LOOP N-1
"
LOOX:    DPY(DATA)<MD;                     "SAVE MAP VALUE
              MOV BADR,BADR
         DB=DPY(ADDRO); LDSP               "BEAM OFFSET TO SPAD
         ADD BEAM,BADR; SETMA;             "FETCH BEAM VALUE
              FMUL
         FMUL; SPMDA                       "PUSH, ETC
         FSUBR FM,DPY(DATA);               "RESIDUAL
              FMUL DPX(T),MD               "BEAM*COMPONENT
         FADD
         ADD TWO,MAPIL; MI<FA; SETMA       "STORE RESIDUAL
         ADD TWO,MAPIP; SETMA              "FETCH MAP VALUE
"
         BR LOOY;
              SPMDA                        "OH, WHY HURRY?
"
"        LOOP N
"
LOOY:    DPY(DATA)<MD                      "SAVE MAP VALUE
         FMUL
         FMUL
         FSUBR FM,DPY(DATA)                "RESIDUAL
         FADD
         ADD TWO,MAPIL; MI<FA; SETMA       "STORE RESIDUAL
"
         BR AFTER
"
"        *******   AFTER WORD  ********
"
"        LOCATE NEXT CLEAN COMPONENT
"
AFTER:   MOV LMAP,3                        "SETUP SPAD FOR MAXMGV
         MOV COMP,13.                      "SAVE THIS A SEC
         MOV AMAP,14.                      "DITTO
         MOV COMP,2
         MOV AMAP,0
         MOV TWO,1
         INC 0                             "FOR MAP VALUES
         JSR MAXMGV                        "CALL MAXMGV
"********************************
"   CARE SHOULD BE TAKEN IN USING MAXMGV - DIFFERENT FPS VERSIONS ARE
"   DIFFERENT.
"********************************
         DEC 15.
         MOVL 15.,MAPI
         INC MAPI                          "(INDEX-1)*2+1
         ADD 14.,MAPI; SETMA               "ADDRESS OF MAX., FETCH
         SPMDA; DPX<MD
         MOV 13.,13.; SETMA; MI<DPX        "VALUE TO OUTPUT ARRAY
         DEC MAPI; SETMA                   "FETCH LOCATION
         RPSF XSEL; DPX(SEL)<DB            "RESTORE THESE-MAXMGV USES AL
                                           "DPX,DPY
         RPSF YSEL; DPY(SEL)<DB
         RPSF S14; DPX(TEMP)<DB
         FAND DPX(SEL),MD                  "SELECT X
         FAND DPY(SEL),MD;                 "SELECT Y
              INC 13.
         FMUL DPX(TEMP),FA;                "SCALE X
              FADD
         INC 13.; MI<FA; SETMA;            "STORE Y
              FMUL
         FMUL
         DEC 13.; MI<FM; SETMA             "STORE X
         RETURN
         $END
"APINT
         $TITLE APINT
         $ENTRY APINT,9.
"
"     MICROCODE ROUTINE FOR FPS 120-B ARRAY PROCESSOR
"     APINT Interpolates model visibilities from a grid,
"     corrects the phase and returns the results.
"     Assumes that the observations are never within M/2
"     of the outside edge of the grid.
"
"   Inputs:
"         P I*4          UV =   Location of (u,v) values in
"                               cells.
"         P I*4          MOD =  Base address of resultant complex model
"                               increment = 4.
"         P I*4          PHAS = Phase correction, complex
"                               value to be multiplied by
"                               model vis. Incr = 4.
"         P I*4          GRID = base address of gridded model
"                               vis. Expects M complex rows
"                               LROW long with zero spatial freq.
"                               in the LROW/2 + 1 position.
"         P I*4          INTP = base address of interpolation
"                               function.
"         P I*4          M = number of rows kept in the AP.
"                               Also support size on interp. fn
"         P I*4          LROW = length of a row.
"         P I*4          INC  = increment for UV.
"         P I*4          NMOD = number of visibility points to
"                               grid.
"
"     All AP memory values are assumed floating.
"     It is assumed that all values of v correspond to row M/2.
"---------------------------------------------------------------
"
"        SET SPAD ASSIGNMENTS
"
UV       $EQU  0
MOD      $EQU  1
PHAS     $EQU  2
GRID     $EQU  3
CONX     $EQU  4
M        $EQU  5
LROW     $EQU  6
INC      $EQU  7
NMOD     $EQU  8.
CONY     $EQU  9.
NO2      $EQU  10.
"
"        SET WORK SPAD ASSIGMNENTS
"
INCR     $EQU  6
N        $EQU  10.
ICONX    $EQU  11.
CX       $EQU  11.
HAF      $EQU  11.
IN       $EQU  12.
CY       $EQU  12.
IX       $EQU  12.
C27      $EQU  12.
TWO      $EQU  13.
FOUR     $EQU  14.
THUN     $EQU  15.
"
"       INSIDE THE LOOPS THE INPUT DATA ARE LOCATED AS FOLLOWS:
"
"       DPX(2)  = Phase correction REAL
"       DPY(2)  = Phase correction IMAG
"       DPX(-4) = 200.
"       TM = 0.5
"       FA IS USED TO STORE THE REAL AND IMAG INTERPOLATED SUMS
"
"       SET FLAG FOR MEMORY SPEED FSSLO = 1 FOR FAST, 0 FOR SLOW
"
         FSSLO = 1
"
"        COMPUTE POINTERS AND FETCH DATA.
"        STARTUP INSTRUCTIONS ARE DOING SEVERAL FUNCTIONS
"         A) COMPUTE CONVOLVING FUNCTION AND GRID BASE ADDRESSES.
"         B) MULTIPLYING DATA BY WEIGHT BEFORE THE LOOP.
"         C) MISCELLANEOUS VALUES COMPUTED.
"
"                SET UP FOR VISIBILITY LOOPING
"
APINT:   LDTMA; DB=!TEN                   "C. GET 10 TO MAKE 100.
"A0.
         LDSPI IX; DB=0.                  "FOR DPA
         SETDPA                           "DPA = 0
"
"A1.
         DPX<TM;                          "C. DPX=10 FOR FMUL
              MOVR M,IX                   "   IX=M/2
"A2.
         FMUL TM,DPX;                     "C. 10*10
              MOVR LROW,HAF               "C. START HAF=LROW/2-NO2
"A3.
         FMUL;                             "C. PUSH
              SUB IX,HAF                   "C. WORK ON HAF
"A4.
         FMUL;                             "C. PUSH
            MOV M,N                        "   N=M
"A5.
         DPX(-4)<FM;                      "C. DPX(-4)=100.
              SUBL N,INCR                 "C. INCR=GRID INCREMENT
"A6.
         LDSPI TWO; DB=2.;                "C. TWO = 2
            FADD FM,DPX(-4)               "C. 100.0 + 100.0
"          FOLLOWING FOR FAST MEMORY
         $IF FSSLO
"A7.
         FADD;                            "C. PUSH
              ADD TWO,INCR                "C. ADD 2 TO GRID
         $ENDIF
"          FOLLOWING FOR SLOW MEMORY
         $IF FSSLO - 1
"A7.
         FADD                             "C. PUSH
         $ENDIF
"A8.
         DPX(-4)<FA                       "C. DPX(-4)=200.
"
"    SAVE SOME VALUES
"A9.
         LDSPI IX; DB=8.
         SETDPA                           "DPA = 8
"A10.
         MOV CONX,CONX; DPX(0)<SPFN       "SAVE CONX
"A11.
         MOV CONX,CONY; DPX(1)<SPFN       "SAVE CONY=CONX
"A12.
         MOV GRID,GRID; DPX(2)<SPFN       "SAVE GRID
"A13.
         MOV M,M; DPX(3)<SPFN             "SAVE M
"A14.
         MOV HAF,HAF; DPY(0)<SPFN         "SAVE HAF
"A15.
         LDTMA; DB=!HALF                  "C. 0.5 TO TM
"
"0.                 BEGIN COMPONENT LOOP.
"
NXTCMP:  LDSPI IX; DB=0.
         SETDPA                           "DPA = 8
"1.
         INC UV; SETMA                    "A. FETCH X
"2.
         LDSPI FOUR; DB=4.                "C. FOUR=4
"3.
         DEC UV; SETMA                    "A. FETCH Y
"4.
         FIX MD;                          "A. FIX X
              LDSPI C27; DB=27.           "C. C27=CONST FOR FLOAT
"5.
         FADD TM, MD                      "A. X+0.5
"6.
         FIX MD;                          "A. FIX Y
              DPX(3)<FA;                  "A. SAVE FIX(X) IN DPX(3)
              LDSPI THUN; DB=200.         "C. THUN=200
"7.
         FADD TM,MD;                      "A. Y+0.5
              DPY(-3)<FA                  "A. SAVE X+.5
"8.
         DPX(-2)<FA;                      "A. SAVE FIX(Y)
              MOV PHAS,PHAS; SETMA        "B. FETCH REAL(PHAS)
"9.
         FSUBR ZERO,MDPX(3); MOV C27,C27   "A. FLOAT(FIX(X))
"10.
         DPX(-3)<FA;                      "A. SAVE Y+0.5
              INCMA                       "B. FETCH IMAG(PHAS)
"11.
         FSUBR ZERO,MDPX(-2); MOV C27,C27  "A. FLOAT(FIX(Y))
"12.
         FSUBR DPY(-3),FA;                "A. FIX(X)-X-.5
              DPX(2)<MD                   "B. SAVE REAL(PHAS)
"13.
         FSUBR DPX(-3),FA                 "A. FIX(Y)-Y-.5
"14.
         FMUL DPX(-4),FA;                 "A. 200*(FIX(X)-X-.5)
              DPY(2)<MD;                  "B. SAVE IMAG(PHAS)
              FADD                        "   PUSH
"15.
         LDSPI IX; DB=DPX(3)              "A. START GRID BIAS
"16.
         FMUL DPX(-4),FA;                 "A. 200*(FIX(Y)-Y-.5)
              ADDL HAF,IX                 "A. GRID BIAS = 2 *
                                          "    (FIX(X)+LROW/2)
"17.
         FMUL;                            "B. PUSH
              ADD IX,GRID                 "A. ADD GRID BIAS
"18.
         FMUL;                            "A. PUSH
              DPY(1)<FM                   "A. CX TO DPY(1)
"19.
         FIX DPY(1);                      "A. FIX CX
              DPX(1)<FM                   "A. CY TO DPX(1)
              FMUL                        "B. PUSH
"20.
         FIX DPX(1);                      "A. FIX CY
              ADD THUN,CONY               "A. ADJUST CONY BY 200
"21.
         DPX(1)<FA;                       "A. CX TO DPX
              FADD;                       "A. PUSH
              ADD THUN,CONX               "A. ADJUST CONX BY 200
"22.
         LDSPI CX; DB=DPX(1);             "A. CONX=200*(FIX(X)-X-.5)
              DPY(1)<FA                   "A. CY TO DPY
"23.
         LDSPI CY; DB=DPY(1)              "A. CONY=200*(FIX(Y)-Y-.5)
"24.
         ADD CX,CONX                      "A. FINISH X CONV ADDR.
"25.
         ADD CY,CONY                      "A. FINISH Y CONV ADDR
"
"        FOLLOWING FOR SLOW MEMORY
"
         $IF FSSLO - 1
"
START:   MOV CONY,CONY; SETMA;            "FETCH FIRST CY
              FADD ZERO,ZERO              "ZERO FA (REAL)
         MOV N,IN;                        "SET INNER LOOP COUNTER
              FADD ZERO,ZERO              "ZERO FA (IMAG)
         SUB TWO,GRID                     "DECREMENT GRID BEFORE LOOP
         SUB THUN,CONX                    "PREPARE CONX FOR LOOP
         MOV CONX,ICONX;                  "SET ICONX
              DPY(-1)<MD; DPX(-1)<MD      "SAVE CY IN DPY(-1)
LOOP:    ADD THUN,ICONX; SETMA            "FETCH CONV X (CX)
"2.
         NOP
"3.
         ADD TWO,GRID; SETMA              "FETCH REAL
"4.
         FMUL DPX(-1),MD                  "CY * CX
"5.
         INCMA;                           "FETCH IMAG
              FMUL                        "PUSH
"6.
         FMUL                             "PUSH
"7.
         FMUL FM,MD;                      "CX * CY * REAL
              DPX<FM                      "SAVE CX * CY
"8.
         FMUL DPX,MD                      "CX * CY * IMAG
"9.
         FMUL                             "PUSH
"10.
         FADD FM,FA;                      "SUM REAL
              FMUL                        "PUSH
"11.
         FADD FM,FA;                       "SUM IMAG
              DEC IN                       "DECREMENT LOOP COUNTER
"12.
         BGT LOOP                         "BRANCH IF INNER LOOP NOT
                                          "FINISHED
"
"        INNER LOOP FINISHED
"
         DEC M                            "DECREMENT OUTER LOOP COUNTER
         ADD THUN,CONY; SETMA;            "FETCH NEXT CY
              BGT .+2                     "CHECK IF FINISHED
         BR S990                          "FINISHED - RETURN
         MOV CONX,ICONX                   "RESET X CONV. FN POINTER
         ADD INCR,GRID                    "UPDATE VIS1 POINTER
         MOV N,IN;                        "RESET INNER LOOP COUNTER
            DPY(-1)<MD; DPX(-1)<MD        "SAVE NEW CY IN DPY(-1)
LEND:    JMP LOOP                         "LOOP
         $ENDIF
"
"        FOLLOWING FOR FAST MEMORY
"
         $IF FSSLO
"
"        PREPARE POINTERS
"
START:   MOV CONY,CONY; SETMA;           "FETCH FIRST CY
            FADD ZERO,ZERO               "ZERO FA (REAL)
         MOV N,IN;                       "SET INNER LOOP COUNT
            FADD ZERO,ZERO               "ZERO FA (IMAG)
         SUB INCR,GRID;                  "DECREMENT GRID BEFORE LOOP
            DPX<FA; DPY<FA               "ZERO TO DPX,DPY
         DPY(-1)<MD; DPX(-1)<MD          "SAVE CY IN DPX AND Y(-1)
"
"        BEGIN OUTER LOOP
"
"        WARM UP LOOP
"1.
OLOOP:   MOV CONX,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX,DPY              "   CLEAR MULTIPLIER
"2.
         ADD INCR,GRID; SETMA;          "1. FETCH REAL
              FMUL DPX,DPY              "   CLEAR MULTIPLIER
"3.
         INCMA;                         "1. FETCH IMAG
              DEC IN                    "   DEC LOOP CNT
"4.
         ADD THUN,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX(-1),MD;          "2. CX*CY
              BGT .+2                   "   CHECK LOOP CNT
"4.5
         DPX(-3)<MD;                    "   SAVE REAL
              BR DP1                    "   EXIT LOOP
"5.
         ADD TWO,GRID; SETMA;           "1. FETCH REAL
              FMUL;                     "2. PUSH
              DPX<MD                    "2. SAVE REAL
"6.
         INCMA;                         "1. FETCH IMAG
              FMUL;                     "2. PUSH
              DPY<MD;                   "2. SAVE IMAG
              DEC IN                    " DEC LOOP CNT
"7.
         ADD THUN,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX(-1),MD;          "2. CX*CY
              DPX(1)<FM; DPY(1)<FM;     "3. SAVE CX*CY
              BGT .+2                   "   CHECK LOOP CNT
"7.5
         DPX(-3)<MD;                    "   SAVE REAL
              BR DP1                    "   EXIT LOOP
"8.
         ADD TWO,GRID; SETMA;           "1. FETCH REAL
              DPX<MD;                   "2. SAVE REAL
              FMUL DPX,DPY(1)           "3. CX*CY*RE
"9.
         INCMA;                         "1. FETCH IMAG
              DPY<MD;                   "2. SAVE IMAG
              FMUL DPY,DPX(1);          "3. CX*CY*IM
              DEC IN                    " DEC LOOP CNT
"
"     LOOP
"
"1/4/7/10
LOOP:    ADD THUN,ICONX; SETMA;         "1. FETCH CX
              FMUL DPX(-1),MD;          "2. CX*CY
              DPX(1)<FM; DPY(1)<FM;     "3. SAVE CX*CY
              BGT .+2                   "   CHECK LOOP CNT
"1.5
         DPX(-3)<MD;                    "   SAVE REAL
              BR DP1                    "   EXIT LOOP
"2/5/8/11.
         ADD TWO,GRID; SETMA;           "1. FETCH REAL
              DPX<MD;                   "2. SAVE REAL
              FMUL DPX,DPY(1);          "3. CX*CY*RE
              FADD FM,FA                "4. SUM REAL
"3/6/9/12.
         INCMA;                         "1. FETCH IMAG
              DPY<MD;                   "2. SAVE IMAG
              FMUL DPY,DPX(1);          "3. CX*CY*IM
              FADD FM,FA;               "4. SUM IMAG
              DEC IN;                   " DEC LOOP CNT
              BR LOOP                   " LOOP
"
"    WIND DOWN LOOP
"
"5/8/11.
DP1:     DPY(-3)<MD;                    "2. SAVE IMAG
              FMUL DPX,DPY(1);          "3. CX*CY*RE
              FADD FM,FA;               "4. SUM REAL
              ADD THUN,CONY; SETMA      "   FETCH NEXT CY
"6/9/12.
         FMUL DPY,DPX(1);               "3. CX*CY*IM
              FADD FM,FA;               "4. SUM IMAG
              MOV N,IN                  "  RESET LOOP CNT
"7/10
         DPX(1)<FM; DPY(1)<FM;          "3. SAVE CX*CY
               FMUL                     "   PUSH
"8/11.
         FMUL DPX(-3),DPY(1);           "3. CX*CY*RE
              FADD FM,FA;               "4. SUM REAL
              DPX(-1)<MD; DPY(-1)<MD    "   NEW CY
"9/12.
         FMUL DPY(-3),DPX(1);           "3. CX*CY*IM
              FADD FM,FA                "4. SUM IMAG
"10.
         FMUL;                          "   PUSH
            DPX<ZERO; DPY<ZERO          "  0 TO DPX,DPY
"11.
         FMUL;                          "   PUSH
              FADD FM,FA;               "4. SUM REAL
              DEC M                     "  DEC OUTER LOOP CNT
"12.
         FADD FM,FA;                    "4. SUM IMAG
              BGT .+2                   "   LOOP
         JMP S990                       "   FINISHED - RETURN
         JMP OLOOP                      "   OUTER LOOP
         $ENDIF
"
"                 ROTATE AND STORE MODEL AND
"                 SETUP FOR NEXT COMPONENT
"                 DPX = REAL, DPX = IMAG
"
S990:    DPX<FA;                        "SAVE REAL
              FADD;                     "PUSH
              FMUL DPX(2),FA            "RE*RE(PHAS)
         ADD INC,UV;                    "INCREMENT UV
              FMUL DPY(2),FA;           "IM*IM(PHAS)
              DPY<FA                    "SAVE IMAG
         ADD FOUR,PHAS;                 "INCREMENT PHAS
              FMUL DPX,DPY(2)           "RE * IM(PHS)
         FMUL DPY,DPX(2);               "IM*RE(PHAS)
              DPX(-1)<FM                "SAVE RE*RE(PHAS)
         FSUBR FM,DPX(-1);              "MODEL REAL
              FMUL                      "PUSH
         DPX(-1)<FM;                    "SAVE RE*IM(PHAS)
              FMUL                      "PUSH
         FADD FM,DPX(-1)                "MODEL IMAG
         MOV MOD,MOD; SETMA; MI<FA;     "STORE MODEL REAL
              FADD                      "PUSH
         INCMA; MI<FA;                  "STORE MODEL IMAG
              ADD FOUR,MOD              "INCREMENT MOD
"                 RESTORE VALUES STORED IN HIGH DPX
         LDSPI IX; DB=8.
         SETDPA                         "DPA = 8
         LDSPI CONX; DB=DPX(0)          "RESTORE CONX
         LDSPI CONY; DB=DPX(1)          "RESTORE CONY
         LDSPI GRID; DB=DPX(2)          "RESTORE GRID
         LDSPI M; DB=DPX(3)             "RESTORE M
         LDSPI HAF; DB=DPY(0)           "RESTORE HAF
         DEC NMOD                       "CHECK MODEL LOOP COUNT
         BGT .+2                        "BRANCH IF NOT FINISHED
         JMP S999                       "FINISHED
         JMP NXTCMP                     "LOOP BACK FOR NEXT
S999:    RETURN
         $END
"CLNMAX
         $TITLE CLNMAX
         $ENTRY CLNMAX,1
         $EXT MAXMGV
"
"   CLNMAX is an AP-CLEAN subroutine finds the maximum values in
"   each field and puts results in the field descriptor vector.
"
"        SPAD ENTRY PARAMETERS
"
FLDESC   $EQU   0
"   FLDESC  Field descriptor vector base address.
"           0 = Number of fields (REAL value)
"      for each field:
"           0 = Start address of residuals (REAL value) (AMAP)
"              (location,intensity), intensity=2**14*x + y
"           1 = Number of points in the map. (REAL value) (LMAP)
"           2 = Current max. flux density (this location is FCOMP)
"           3 = X position of current max.
"           4 = Y position of current max.
"           5 = CLEAN gain
"
"              SPAD useage:
A        $EQU   0.                         "for MAXMGV
I        $EQU   1.                         "for MAXMGV
C        $EQU   2.                         "for MAXMGV
N        $EQU   3.                         "for MAXMGV
NFIELD   $EQU   6.                         "number of fields counter
WORK     $EQU   7.                         "input vector pointer
MAXL     $EQU   8.                         "address of maximum
TWO      $EQU   9.                         "value 2
ADDR     $EQU  10.                         "Base address of vector
"        DATA PAD REGISTERS (ALL INDEXING - NO DPA CHANGES)
"
SEL      $EQU    1.                        "selection of X or Y
TEMP     $EQU    2.                        "scaling factor for X
"
"        OK, now get everything organized.
"
CLNMAX:  MOV FLDESC,WORK; SETMA             "Fetch no. fields
         INC WORK                           "WORK to first field
         LDSPI TWO; DB=2.;                  "set value of 2
"     Set some constants
              BR S14+1                      "don't execute data
XSEL:    $FP  268419072.                    "16383*16384
YSEL:    $FP      16383.                    "16383
S14:     $VAL 0,1FX,3400X,0                 "(2**-14)
         FIX MD                             "Fix number of fields
         SUB TWO,WORK;                      "set up for loop
              FADD
         DPX<FA
         LDSPI NFIELD; DB=DPX
         MOV NFIELD,NFIELD
         BGT .+2                            "check that MFIELD>0
         JMP S999
"                   Begin field loop
LOOP:    ADD TWO,WORK; SETMA                "fetch start address
         MOV TWO,I                          "increment for MAXMGV
         INCMA                              "fetch length
         FIX MD;                            "fix address
              MOV WORK,C                    "output for MAXMGV
         ADD TWO,C;                         "MAXMGV to write to
"                                            WORK+2
              FADD
         FIX MD;                            "fix length
              DPX<FA
         LDSPI A; DB=DPX;                   "address to SPAD
              FADD
         DPX<FA;
              INC A                         "set to value
         MOV A,ADDR                         "save base address
         LDSPI N; DB=DPX                    "length to SPAD
         MOV N,N
         BGT .+2
         JMP ENDL                           "Skip if N<=0
"
"        LOCATE NEXT CLEAN COMPONENT
"
         JSR MAXMGV                        "CALL MAXMGV
"********************************
"   CARE SHOULD BE TAKEN IN USING MAXMGV - DIFFERENT FPS VERSIONS ARE
"   DIFFERENT.
"********************************
         DEC 15.                           "index returned in SPAD 15
         MOVL 15.,MAXL                     "(INDEX-1)*2
         ADD ADDR,MAXL; SETMA              "address of max., fetch
         SPMDA; DPX<MD
         ADD TWO,WORK; SETMA; MI<DPX       "value to output array
         DEC MAXL; SETMA                   "fetch max. resid. location
         RPSF XSEL; DPX(SEL)<DB            "set masks, X scale factor
         RPSF YSEL; DPY(SEL)<DB
         RPSF S14; DPX(TEMP)<DB
         FAND DPX(SEL),MD                  "select X
         FAND DPY(SEL),MD                  "select Y
         FMUL DPX(TEMP),FA;                "scale X
              FADD
         ADD TWO,WORK; MI<FA; SETMA;       "store Y
              FMUL
         FMUL
         DEC WORK; MI<FM; SETMA;           "store X
            BR .+3
ENDL:    ADD TWO,WORK                      "set WORK to correct value
         INC WORK                          " add 3 to make up for skiping
"                                            the bulk of the work
"
         INC WORK
         DEC NFIELD                        "decrement loop count
         BEQ S999                          "check if done
         JMP LOOP
S999:    RETURN
         $END
"CLNPKS
         $TITLE CLNPKS
         $ENTRY CLNPKS,2
         $EXT MAXMGV,SPFLT
"
"   CLNPKS is an AP-CLEAN subroutine that finds the maximum values in
"   each field in the field descriptor vector.  Also copies the result
"   to the output array COMP
"
"        SPAD ENTRY PARAMETERS
"
FLDESC   $EQU   0
"   FLDESC  Field descriptor vector base address.
"           0 = Number of fields (REAL value)
"      for each field:
"           0 = Start address of residuals (REAL value) (AMAP)
"              (location,intensity), intensity=2**14*x + y
"           1 = Number of points in the map. (REAL value) (LMAP)
"           2 = Current max. flux density (this location is FCOMP)
"           3 = X position of current max.
"           4 = Y position of current max.
"           5 = CLEAN gain
"
COMP     $EQU   1
"   COMP    Base address of component vector 4 words per comp.:
"            1 = component intensity.
"            2 = x location (cells)
"            3 = y location (cells)
"            4 = field number
"              SPAD useage:
A        $EQU   0.                         "for MAXMGV
I        $EQU   1.                         "for MAXMGV
C        $EQU   2.                         "for MAXMGV
N        $EQU   3.                         "for MAXMGV (no. fields)
WORK     $EQU   7.                         "input vector pointer
MAXL     $EQU   8.                         "address of maximum
ADDR     $EQU  12.                         "address of 1 field
INDEX    $EQU  13.                         "Field number (as index)
"      Output values in SPAD:
AMAP     $EQU   4.                         "Base address of residual
LMAP     $EQU   5.                         "Number of residuals
FCOMP    $EQU   6.                         "Base address of component
"                                           vector
"
"        OK, now get everything organized.
"
CLNPKS:  MOV FLDESC,ADDR; SETMA             "Fetch no. fields
         INC ADDR                           "
         MOV ADDR,A                         "set start addr. for MAXMGV
         INC A
         FIX MD;                            "Fix number of fields
              INC A                         "A=loc of values
         MOV COMP,WORK;                     "save address of COMP
              FADD
         MOV COMP,C;                        "use COMP for MAXMGV
              DPX<FA
         LDSPI N; DB=DPX                    "get number of fields
         MOV N,N
         BGT .+2                            "Check that N>0
         JMP S999                           "quit
         LDSPI I; DB=6.                     "increment for MAXMGV
"    MAXMGV doesn't work for N=1, test this case.
         LDSPI 15.; DB=1.                   "FIELD=1 in case
         DEC# N                             "decr (no load) test N=1
         BEQ .+2                            "skip MAXMGV if N=1
"
"        find field with largest residual
"
         JSR MAXMGV                        "CALL MAXMGV
"********************************
"   CARE SHOULD BE TAKEN IN USING MAXMGV - DIFFERENT FPS VERSIONS ARE
"   DIFFERENT.  HERE THE INDEX IS EXPECTED IN SPAD 15.
"********************************
         MOV 15.,INDEX                     "index = field number
         DEC INDEX                         "index returned in SPAD 15*2
         MOVL INDEX,INDEX                  "(INDEX-1)*2
         MOVL INDEX,FCOMP                  "(INDEX-1)*4
         ADD INDEX,FCOMP                   "(6*(INDEX-1))
"                                           start location
         ADD ADDR,FCOMP; SETMA             "address of address
         NOP
         INC FCOMP; SETMA                  "fetch length
         FIX MD                            "fix address
         INC FCOMP; SETMA;                 "fetch flux and leave FCOMP
              FADD                         "          at correct value
         FIX MD;                           "FIX address
              DPX<FA
         INCMA;                            "fetch X
            LDSPI AMAP; DB=DPX;            "save start address
            FADD
         DPX<FA; DPY(0)<MD                 "DPY(0)=flux
         LDSPI LMAP; DB=DPX;               "save no. residuals
            INCMA                          "fetch Y
         DPY(1)<MD                         "DPY(1)=X
         JSR SPFLT                         "Float field no.=>DPX(1)
         DPY(2)<MD                         "DPY(2)=Y
         MOV WORK,WORK; SETMA; MI<DPY(0)   "store FLUX
         DPY(3)<MD                         "DPY(3)=field no.
         INCMA; MI<DPY(1)                  "store X
         NOP
         INCMA; MI<DPY(2)                  "store Y
         NOP
         INCMA; MI<DPX(1)                  "store field no.
S999:    RETURN
         $END
         $ENDLIB
