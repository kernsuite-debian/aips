      SUBROUTINE QCFFT (C, N, F)
C-----------------------------------------------------------------------
C;  Copyright (C) 1995
C;  Associated Universities, Inc. Washington DC, USA.
C;
C;  This program is free software; you can redistribute it and/or
C;  modify it under the terms of the GNU General Public License as
C;  published by the Free Software Foundation; either version 2 of
C;  the License, or (at your option) any later version.
C;
C;  This program is distributed in the hope that it will be useful,
C;  but WITHOUT ANY WARRANTY; without even the implied warranty of
C;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C;  GNU General Public License for more details.
C;
C;  You should have received a copy of the GNU General Public
C;  License along with this program; if not, write to the Free
C;  Software Foundation, Inc., 675 Massachusetts Ave, Cambridge,
C;  MA 02139, USA.
C;
C;  Correspondence concerning AIPS should be addressed as follows:
C;         Internet email: aipsmail@nrao.edu.
C;         Postal address: AIPS Project Office
C;                         National Radio Astronomy Observatory
C;                         520 Edgemont Road
C;                         Charlottesville, VA 22903-2475 USA
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C   Full complex 1-D FFT.
C
C   Inputs:
C      C  I*4  Base address (0-rel) of complex array to transform
C      N  I*4  Number of points in array (must be power of two).
C      F  I*4  Transform direction; 1 -> Forward
C                                  -1 -> Backward
C
C   Alliant version (uses FX/SERIES Scientific Library routine CFFT)
C   NOTE: CFFT is takes DOUBLE PRECISION arguments so we have the extra
C   overhead of conversion loops.  Normally, a 1K double precision CFFT
C   would take 3-4 msecs with 8 CE's, but the conversion loops add
C   another 3-4 msecs.  Alliant needs to provide a single precision
C   version such that AIPS 1K FFT's would take 2-3 msecs instead of 6-8.
C   Also CFFT yields a normalized transform and we need an un-normalized
C   one, so we use the second conversion loop for this).
C-----------------------------------------------------------------------
      INTEGER*4 C, N, F, IF, I
C                                       FFT scratch array big enough
C                                       for 4096 FFT's.
      REAL*8 FFTSCR(8192)
      INCLUDE 'INCS:DAPC.INC'
      INCLUDE 'INCS:CAPC.INC'
      INCLUDE 'INCS:EAPC.INC'
C-----------------------------------------------------------------------
C                                        Copy R*4 APCORE to R*8 scratch
C                                        array FFTSCR
      DO I = 1,N*2
         FFTSCR(I) = APCORE(C+I)
         END DO
C                                        CFFT is an Alliant FX/series
C                                        scientific library routine:
C                                           -1 => forward transform
C                                            0 => initialize work area
C                                           +1 => inverse transform
      IF (N.EQ.FFTSZE) GO TO 10
C                                        Initialize FFT work area
         CALL CFFT (N, FFTSCR, 0, WKVEC7)
         FFTSZE = N
C                                        CFFT's transform direction
C                                        convention opposite from AIPS's
 10   IF = -F
      CALL CFFT (N, FFTSCR, IF, WKVEC7)
C                                        Copy R*8 scratch array
C                                        FFTSCR to R*4 APCORE
      IF (IF.EQ.1) THEN
C                                        De-normalize
         DO I = 1,N*2
            APCORE(C+I) = FFTSCR(I) * N
            END DO
      ELSE
         DO I = 1,N*2
            APCORE(C+I) = FFTSCR(I)
            END DO
         ENDIF
C
 999  RETURN
      END
